<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jefflike&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-16T06:34:22.811Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jefflike</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Object与Class</title>
    <link href="http://yoursite.com/2018/08/16/Object%E4%B8%8EClass/"/>
    <id>http://yoursite.com/2018/08/16/Object与Class/</id>
    <published>2018-08-16T06:20:19.000Z</published>
    <updated>2018-08-16T06:34:22.811Z</updated>
    
    <content type="html"><![CDATA[<p>大家都知道Object对象的意思，所有的面向对象一般都有这样一个超级父类，所有的类都默认继承这个类，Object的设计就很重要了，它要包含面向对象最基本实现的方法，所以我想知道它的内部代码都写了点什么，这些方法属性都有什么作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家都知道Object对象的意思，所有的面向对象一般都有这样一个超级父类，所有的类都默认继承这个类，Object的设计就很重要了，它要包含面向对象最基本实现的方法，所以我想知道它的内部代码都写了点什么，这些方法属性都有什么作用。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据库的事务隔离级别</title>
    <link href="http://yoursite.com/2018/08/05/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2018/08/05/mysql数据库的事务隔离级别/</id>
    <published>2018-08-05T03:36:43.000Z</published>
    <updated>2018-08-08T10:05:03.755Z</updated>
    
    <content type="html"><![CDATA[<p>本篇就是简单说说Java的四个事务管理级别。<a id="more"></a></p><h2 id="查询当前的数据库的事务隔离级别"><a href="#查询当前的数据库的事务隔离级别" class="headerlink" title="查询当前的数据库的事务隔离级别"></a>查询当前的数据库的事务隔离级别</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@global.tx_isolation,@@tx_isolation;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@global.tx_isolation,@@tx_isolation;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| @@global.tx_isolation | @@tx_isolation  |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| REPEATABLE-READ       | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看出mysql的默认事务隔离级别是可重复读。</p><h2 id="修改当前数据库的事务隔离级别"><a href="#修改当前数据库的事务隔离级别" class="headerlink" title="修改当前数据库的事务隔离级别"></a>修改当前数据库的事务隔离级别</h2><p>为了测试不同的事务隔离级别所以首先第一步我们要知道如何修改当前的事务隔离级别。这里我们只修改当前会话的事务隔离级别即可：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</span><br></pre></td></tr></table></figure></p><p>session指的就是当前会话，read uncommitted就是读未提交的事务隔离级别，事务隔离级别的最低等级。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read uncommitted;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.tx_isolation,@@tx_isolation;</span><br><span class="line">+-----------------------+------------------+</span><br><span class="line">| @@global.tx_isolation | @@tx_isolation   |</span><br><span class="line">+-----------------------+------------------+</span><br><span class="line">| REPEATABLE-READ       | READ-UNCOMMITTED |</span><br><span class="line">+-----------------------+------------------+</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure></p><h2 id="读未提交-amp-可重复读"><a href="#读未提交-amp-可重复读" class="headerlink" title="读未提交&amp;可重复读"></a>读未提交&amp;可重复读</h2><p>我开启两个会话窗口，一个事务隔离级别调整为读未提交，一个事务仍旧是可重复读。并且开启两个窗口的事务：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p><img src="http://p94ypeu3q.bkt.clouddn.com/读未提交与可重复读.png" alt="读未提交与可重复读"><br>下面我的叙述分为左会话(read uncommitted),右会话(repeatable read)，我在左会话查询整表时，在右会话中也可以查询到整表信息(此时没有表锁);<br><img src="http://p94ypeu3q.bkt.clouddn.com/读未提交两个会话皆可查询整表.png" alt="读未提交两个会话皆可查询整表"><br>当然读取行也是可以的<img src="http://p94ypeu3q.bkt.clouddn.com/读未提交的行也可读.png" alt="读未提交的行也可读"><br>当修改某一行的时候：<img src="http://p94ypeu3q.bkt.clouddn.com/读未提交修改.png" alt="读未提交修改"><br>此时左会话修改了第一行，但是事务未提交，那么右会话想修改这一行是不可能修改的，事务默认锁住了这一行，直至左会话提交事务。<br>此时由于右会话是可重复读，已经解决了脏读问题，所以右会话查询结果是修改前的数据，还不是左会话未提交的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 右会话</span><br><span class="line">mysql&gt; select * from biao where id = 1;</span><br><span class="line">+----+---------+--------+---------+</span><br><span class="line">| id | sick_id | doc_id | describ |</span><br><span class="line">+----+---------+--------+---------+</span><br><span class="line">|  1 |    1001 | 100001 | 腹痛    |</span><br><span class="line">+----+---------+--------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>接着我们将左会话提交，在右会话中查询，得到的结果：<br><img src="http://p94ypeu3q.bkt.clouddn.com/可重复读的数据读的都是一样的.png" alt="可重复读的数据读的都是一样的"><br>为什么我左会话已经提交了，但是右会话查询到的还是之前的数据呢，简单地说就是因为右会话的事务隔离级别是可重复读，那么右会话在左会话commit之前实际上是查询了一次的，查询后并未提交事务，因为当前事务隔离级别是可重复读，所以在上一次查询事务还未结束的情况下，是不可以出现不可重复读的问题，所以独到的仍然是修改前的值。此时我们将右会话commit就可以得到当前修改后的数据了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 右会话</span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from biao where id = 1;</span><br><span class="line">+----+---------+--------+-----------+</span><br><span class="line">| id | sick_id | doc_id | describ   |</span><br><span class="line">+----+---------+--------+-----------+</span><br><span class="line">|  1 |    1001 | 100001 | 没毛病    |</span><br><span class="line">+----+---------+--------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>为了查看读未提交的特性，我们修改右会话的数据，然后对左会话进行测试，基本上一致，除了一点，当我们修改右会话数据的时候，左会话修改同样因为锁而阻塞，查询数据时会出现脏读现象：<img src="http://p94ypeu3q.bkt.clouddn.com/脏读.png" alt="脏读"><br>脏读即读取到对方事务还未提交的数据，这个事务可能回滚数据，所以读到的数据没有有效性，就是一段脏数据。<br><img src="http://p94ypeu3q.bkt.clouddn.com/脏读与事务回滚.png" alt="脏读与事务回滚"><br>解决脏读的方法就是事务隔离级别改为读已提交。</p><h2 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h2><p>首先，我们将左会话的事务隔离级别改为读已提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read committed;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.tx_isolation,@@tx_isolation;</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| @@global.tx_isolation | @@tx_isolation |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| REPEATABLE-READ       | READ-COMMITTED |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>读已提交的事务隔离级别可以解决脏读问题，但是却存在着不可重复读的问题：<br><img src="http://p94ypeu3q.bkt.clouddn.com/读已提交的不可重复读问题.png" alt="读已提交的不可重复读问题"><br>可以看出，在我的左会话的两次查询一次事务中，我查到了两组不同的数据，并且第一次查询的数据不可再现(右会话已经提交修改数据)，这并不是我们希望看到的，对于首次查询的结果不可再现的情况，我们称为不可重复读，解决这种问题，需要我们的事务隔离级别为可重复读。</p><h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><p>我们在读未提交里其实已经可以看到读已提交的效果了，在一次事务会话里，即使数据库中的数据已经改变了，我们依然可以读到之前的数据以保持在一次回话中数据不会发生不可重复读的情况，直到此次事务结束，我们才可以获得当前数据库中真实的值，防止一次回话中的多个线程修改同一条数据，每次查到的结果都不一样，让人不知所措。那么我们知道可重复读并不是事务隔离级别的最高级，最高级是串行化用来解决幻读问题。<br>实现以下幻读的效果，首先将两边的回话都改为可重复读的隔离级别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level repeatable read;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.tx_isolation,@@tx_isolation;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| @@global.tx_isolation | @@tx_isolation  |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| REPEATABLE-READ       | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure></p><h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><p>解决幻读问题。</p><h2 id="for-update"><a href="#for-update" class="headerlink" title="for update"></a>for update</h2><p>不论哪种隔离级别，查询因为并不会修改数据，所以都不会阻塞，但是我们如果希望某一段之内我操作不论增删改查都不允许第三方操作，那么我们就需要使用for update强行加锁。<br><img src="http://p94ypeu3q.bkt.clouddn.com/for%20update.png" alt="for update"><br>此时先抢占到锁的就会执行此行，其他的sql会被阻塞住。直到抢占方commit后，执行结束，其他sql立刻去操作，抢占加锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇就是简单说说Java的四个事务管理级别。
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SSM之SpringMVC</title>
    <link href="http://yoursite.com/2018/07/25/SSM%E4%B9%8BSpringMVC/"/>
    <id>http://yoursite.com/2018/07/25/SSM之SpringMVC/</id>
    <published>2018-07-25T12:59:59.000Z</published>
    <updated>2018-07-25T13:00:36.365Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SSM系列之Spring</title>
    <link href="http://yoursite.com/2018/07/24/SSM%E7%B3%BB%E5%88%97%E4%B9%8BSpring/"/>
    <id>http://yoursite.com/2018/07/24/SSM系列之Spring/</id>
    <published>2018-07-24T10:20:41.000Z</published>
    <updated>2018-08-03T14:44:03.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><p>Spring的优点：</p><ol><li>非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API，也就是说Spring是一个轻量级的框架，松耦合；</li><li>依赖注入：DI——Dependency Injection，反转控制(IOC)最经典的实现；</li><li>面向切面编程：Aspect Oriented Programming——AOP，IoC与AOP是Spring的核心；</li><li>容器：Spring是一个容器，因为它包含并且管理应用对象的生命周期，统一管理JavaBean的生成与销毁的过程，就是Bean的工厂，用的时候可以直接拿到Bean对象；</li><li>组件化：Spring实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象。真正的实现了只要配置注解就实现功能的操作，大大加速开发效率；</li></ol><p>从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从spring中受益。简单来说，spring就是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架。</p><p>注：关于耦合的问题，我这里简单的说一下，耦合指的是我们的业务逻辑代码与框架之间的联系，Spring的低耦合就是我们的代码可以像可插拔似的，与框架之间的联系不会太紧密，当业务发生改变时我们也不必大量的重写我们的代码（只改变相关业务的部分），关于系统耦合的问题，有机会可以写一篇相关的博客。</p><p>Spring框架是一个分层架构，由7个定义良好的模块组成。Spring模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式。<br><img src="http://p94ypeu3q.bkt.clouddn.com/Spring组成.png" alt="Spring组成"><br>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。</p><p>我们这里只说一说Spring的核心实现部分IoC与AOP。</p><h2 id="IoC概念"><a href="#IoC概念" class="headerlink" title="IoC概念"></a>IoC概念</h2><p>IoC的设计目的就是为了解耦，控制反转与我们平时获取对象的方式不同，在JavaSE中我们想要获取一个类的对象，一般会直接new一个对象，而在Spring中对象统一管理在IoC容器，通过DI使用对象。控制反转的方式将我们硬编码方式的创建对象的方式改为框架统一管理对象，这就是解耦。</p><p><strong>简单的来说：控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法。</strong></p><h3 id="IoC在Spring中的实现"><a href="#IoC在Spring中的实现" class="headerlink" title="IoC在Spring中的实现"></a>IoC在Spring中的实现</h3><p>IOC思想必须基于IoC容器来完成， 而IOC容器在最底层实质上就是一个对象工厂。</p><ol><li>在通过IOC容器读取Bean的实例之前，需要先将IOC容器本身实例化。</li><li>Spring提供了IOC容器的两种实现方式：①BeanFactory：IOC容器的基本实现，是Spring内部的基础设施，是面向Spring本身的，不是提供给开发人员使用的。②ApplicationContext：BeanFactory的子接口，提供了更多高级特性。面向Spring的使用者，几乎所有场合都使用ApplicationContext而不是底层的BeanFactory。</li></ol><p>从IoC容器中获取对象的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//1. 创建Spring IOC 容器对象</span><br><span class="line">ApplicationContext  ctx = </span><br><span class="line">new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line"></span><br><span class="line">//2. 从IOC容器对象中获取Person对象</span><br><span class="line">Person person = ctx.getBean(&quot;person&quot;, Person.class);</span><br><span class="line"></span><br><span class="line">//3. 使用对象</span><br><span class="line">person.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里就存在着一些疑问了，我们在配置文件中提供的Bean对象是怎么一步步的到最后被使用的。那么我们就来说说这个完成调用的整个过程。<br>(一) 读取配置文件，找到所有被IoC容器管理的类；<br>(二) 通过反射机制与工厂模式创建Bean对象；<br>(三) Spring IOC容器对bean的生命周期进行管理(构造器，设置属性，初始化方法，调用对象，销毁对象)；</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>Spring中的工厂类的实现与继承关系：<br><img src="http://p94ypeu3q.bkt.clouddn.com/工厂Bean的继承关系.png" alt="工厂Bean的继承关系"></p><p>Spring中Bean对象的创建是典型的工厂模式，这一系列的Bean工厂，也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在Spring中有许多的IOC容器的实现供用户选择和使用。IoC实现：<br><img src="http://p94ypeu3q.bkt.clouddn.com/ioc实现.png" alt="ioc实现"><br>我们的关注点放在第一个BeanFactory中定义了IOC容器的基本功能规范(得到Bean对象的多个重载方法):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactory &#123;</span><br><span class="line">    // 对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，如果需要得到工厂本身，需要转义 </span><br><span class="line">    String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</span><br><span class="line"></span><br><span class="line">    // 通过字符串得到一个Object类型的Bean对象 </span><br><span class="line">    Object getBean(String var1) throws BeansException;</span><br><span class="line">    // 重载方法通过Bean对象名与Bean对象类型获得IoC容器中的Bean对象</span><br><span class="line">    &lt;T&gt; T getBean(String var1, Class&lt;T&gt; var2) throws BeansException;</span><br><span class="line">    // 重载方法通过Bean对象类型获得IoC容器中的Bean对象，当前此方法返回的对象类型不再是Object</span><br><span class="line">    &lt;T&gt; T getBean(Class&lt;T&gt; var1) throws BeansException;</span><br><span class="line">    // 重载方法通过Bean对象名与多参数Object列表IoC容器中的Object类型Bean对象</span><br><span class="line">    Object getBean(String var1, Object... var2) throws BeansException;</span><br><span class="line"></span><br><span class="line">    // 是否有某个Bean对象</span><br><span class="line">    boolean containsBean(String var1);</span><br><span class="line"></span><br><span class="line">    // 是否只在服务器启动时创建一个实例，并且整个项目都只有一个对象</span><br><span class="line">    boolean isSingleton(String var1) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    // 是否创建多个实例</span><br><span class="line">    boolean isPrototype(String var1) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    // 某个Bean对象是否是某个类型 </span><br><span class="line">    boolean isTypeMatch(String var1, Class&lt;?&gt; var2) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    // 获取Bean对象的类型</span><br><span class="line">    Class&lt;?&gt; getType(String var1) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    // 根据别名检索出原名</span><br><span class="line">    String[] getAliases(String var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BeanFactory只对IOC容器的基本行为作了定义，根本不关心你的bean是如何定义怎样加载的。正如我们只关心工厂生产什么产品，而不关注它怎么生产的一样。</p><p>我们关注的第二个是DefaultListableBeanFactory实现类，该类实现了其上所有的接口方法。代码很多，主要功能是为了区分在Spring内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。ListableBeanFactory接口表示这些Bean是可列表的，而HierarchicalBeanFactory表示的是这些Bean是有继承关系的，也就是每个Bean有可能有父Bean。AutowireCapableBeanFactory接口定义 Bean 的自动装配规则。这四个接口共同定义了Bean的集合、Bean之间的关系、以及Bean行为。</p><p>Spring关注工厂怎么生产产品的步骤的实现类有很多，最常使用的就是ApplicationContext，它是Spring提供的一个高级的IoC容器创建对象，它除了能够提供IoC容器的基本功能外，还为用户提供了一些附加服务，这些服务是ApplicationContext接口通过继承获得的。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《spring技术内慕》</li><li><a href="https://www.cnblogs.com/ITtangtang/p/3978349.html" target="_blank" rel="noopener">https://www.cnblogs.com/ITtangtang/p/3978349.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring概述&quot;&gt;&lt;a href=&quot;#Spring概述&quot; class=&quot;headerlink&quot; title=&quot;Spring概述&quot;&gt;&lt;/a&gt;Spring概述&lt;/h2&gt;&lt;p&gt;Spring的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非侵入式：基于Spring开发的应用中的对象
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>文件的上传与下载</title>
    <link href="http://yoursite.com/2018/07/23/%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/07/23/文件的上传与下载/</id>
    <published>2018-07-23T09:02:39.000Z</published>
    <updated>2018-08-08T11:08:51.517Z</updated>
    
    <content type="html"><![CDATA[<p>文件的上传从本质上来说就是将本地的文件通过I/O流将本地文件复制到服务器的某个文件夹下，下载是一个与它相反的操作，将读取服务器的文件，copy到本地文件存储。所以说上传下载，首先就离不开文件读写与复制。</p><h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><p>Java没有内置的方法可以实现copy，copy操作需要一边读文件一边写到文件中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jeff_code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File f1 = <span class="keyword">new</span> File(<span class="string">"File/1.avi"</span>);</span><br><span class="line">    File f2 = <span class="keyword">new</span> File(<span class="string">"File/2.avi"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!f2.exists())&#123;</span><br><span class="line">        f2.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> FileCopy().copy(f1, f2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(File a, File b)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(a);</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(b);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = bis.read(buffer);</span><br><span class="line">        <span class="keyword">while</span> (len != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buffer, <span class="number">0</span>, len);<span class="comment">// 每次读取数组的实际长度，最后一次长度可不一定是1024，如果只是buffer就会读到多余的字符</span></span><br><span class="line">            len = bis.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码是原地复制，即在当前计算机复制到当前计算机，上传下载的基本原理与其类似，实际中并不实用，操作系统一般都有复制剪切等功能的系统调用，不需要我们实现。</p><h2 id="JavaWEB中的上传下载"><a href="#JavaWEB中的上传下载" class="headerlink" title="JavaWEB中的上传下载"></a>JavaWEB中的上传下载</h2><p>在不使用Spring框架提供的上传下载的情况下，我们实现上传下载还是非常麻烦的一件事，我们一般也不会写这样的上传下载的代码，但是框架实现上传下载的方式与它还是比较相似的。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>jsp页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;download&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  满汉全席-还不是因为你长得不好看：&lt;a href=&quot;download?musicName=还不是因为你长得不好看.mp3&quot;&gt;点击下载&lt;/a&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>下载代码(省略servlet配置)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">download</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取文件的名</span></span><br><span class="line">        String musicName = req.getParameter(<span class="string">"musicName"</span>);</span><br><span class="line">        <span class="comment">// 每一个WEB容器共享同一个ServletContext对象</span></span><br><span class="line">        ServletContext application = getServletContext();</span><br><span class="line">        <span class="comment">// 2. 获取当前文件存储的实际位置</span></span><br><span class="line">        String realPath = application.getRealPath(<span class="string">"/WEB-INF/music/"</span>+musicName);</span><br><span class="line">        <span class="comment">// 3. 将文件的后缀名/文件类型传给浏览器</span></span><br><span class="line">        String mimeType = application.getMimeType(musicName);<span class="comment">//根据路径的后缀名匹配文件的真实类型</span></span><br><span class="line">        resp.setContentType(mimeType);</span><br><span class="line">        <span class="comment">// 4. 解决乱码问题</span></span><br><span class="line">        String header = req.getHeader(<span class="string">"User-Agent"</span>);</span><br><span class="line">        <span class="keyword">if</span>(header.contains(<span class="string">"Firefox"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 火狐单独的解决乱码方式</span></span><br><span class="line">            musicName = <span class="string">"=?utf-8?B?"</span>+<span class="keyword">new</span> BASE64Encoder()</span><br><span class="line">                    .encode(musicName.getBytes(<span class="string">"utf-8"</span>))+<span class="string">"?="</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            musicName = URLEncoder.encode(musicName, <span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Content-Disposition字段，激活文件下载对话框，它的文件名框自动填充了头中指定的文件名</span></span><br><span class="line">        resp.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span>+musicName);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line">        <span class="comment">// 通过reponse对象的输出流将文件写给浏览器</span></span><br><span class="line">        ServletOutputStream sos = resp.getOutputStream();</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((len=fis.read(bs))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            sos.write(bs, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//文件传输完毕</span></span><br><span class="line">        sos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以下载的主要操作就是将文件文件流写到浏览器，浏览器完成下载（copy的操作）。</p><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jeff_code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.FileItem;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.FileUploadBase;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.disk.DiskFileItemFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.servlet.ServletFileUpload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  上传需要导入使用第三方工具进行解析：  IOUtils.jar： 用来处理流的 ， FileUpload.jar: 解析处理后流中的多部件内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">upload</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、创建解析工厂对象</span></span><br><span class="line">        DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">        <span class="comment">//2、通过解析工厂 创建Request解析器对象</span></span><br><span class="line">        ServletFileUpload fileUpload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">        <span class="comment">//3、通过解析器对象处理请求对象中的流数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//FileItem: 文件上传时，一个fileitem代表一个表单项数据</span></span><br><span class="line">            List&lt;FileItem&gt; list = fileUpload.parseRequest(req);</span><br><span class="line">            <span class="comment">//4、遍历多部件</span></span><br><span class="line">            <span class="keyword">for</span> (FileItem fileItem : list) &#123;</span><br><span class="line">                <span class="comment">//4.1 判断正在遍历的fileitem是文本表单项还是文件表单项</span></span><br><span class="line">                <span class="keyword">if</span>(fileItem.isFormField()) &#123;<span class="comment">//isFormField 判断是不是一个文本表单项，如果是返回true</span></span><br><span class="line">                    String fieldName = fileItem.getFieldName();</span><br><span class="line">                    String value = fileItem.getString(<span class="string">"UTF-8"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//文件表单项</span></span><br><span class="line">                    <span class="comment">//先判断上传的文件的大小，如果长度为0，不用保存</span></span><br><span class="line">                    <span class="keyword">if</span>(fileItem.getSize()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        String fieldName = fileItem.getFieldName();</span><br><span class="line">                        <span class="comment">// 文件表单项不会读取value值的String value = fileItem.getString("UTF-8");</span></span><br><span class="line">                        <span class="comment">//将用户上传的文件保存到服务器内部</span></span><br><span class="line">                        String fileName = fileItem.getName();<span class="comment">//上传的文件名</span></span><br><span class="line">                        <span class="comment">//在服务器内部创建一个文件夹用来保存上传的文件</span></span><br><span class="line">                        ServletContext application = getServletContext();</span><br><span class="line">                        <span class="comment">//获取upload文件夹的真实路径</span></span><br><span class="line">                        String realPath = application.getRealPath(<span class="string">"/upload"</span>);</span><br><span class="line">                        <span class="comment">//如果文件夹不存在则创建</span></span><br><span class="line">                        File uploadFile = <span class="keyword">new</span> File(realPath);</span><br><span class="line">                        <span class="keyword">if</span>(!uploadFile.exists()) &#123;</span><br><span class="line">                            uploadFile.mkdirs();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//保存图片时，需要保证图片名唯一  否则后上传的会覆盖之前的</span></span><br><span class="line">                        fileName = System.currentTimeMillis()+<span class="string">"_"</span>+UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>)+<span class="string">"_"</span>+fileName;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//文件夹已存在，将图片可以写入文件夹中</span></span><br><span class="line">                        File saveFile = <span class="keyword">new</span> File(uploadFile, fileName);<span class="comment">//将要保存的图片名和保存文件的路径创建一个新的文件</span></span><br><span class="line">                        fileItem.write(saveFile);<span class="comment">//将用户上传的图片内容通过刘写入到saveFile中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            resp.getWriter().write(<span class="string">"上传成功"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这是我们自己实现的上传功能，当然实际生产我们而不可能使用这种方式，Spring为我们提供了上与下载功能，这使得我们开发精力更多的放在业务上，而不是繁杂的代码上。</p><h2 id="Spring的上传下载功能"><a href="#Spring的上传下载功能" class="headerlink" title="Spring的上传下载功能"></a>Spring的上传下载功能</h2><p>配置文件需要进行参数配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置上传 组件 </span><br><span class="line"> 注意:  id必须指定成 multipartResolver</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=&quot;multipartResolver&quot; </span><br><span class="line">class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</span><br><span class="line">&lt;!-- 指定成与 上传表单所在的页面的编码一致 --&gt;</span><br><span class="line">&lt;property name=&quot;defaultEncoding&quot;  value=&quot;utf-8&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;!-- 设置最大的上传文件大小 --&gt;</span><br><span class="line">&lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/download&quot;)</span><br><span class="line">public  ResponseEntity&lt;byte[]&gt;  download(HttpSession session ) throws Exception&#123;</span><br><span class="line">byte[] images = null ;</span><br><span class="line">//将要下载的图片进行读取，存储到字节数据中</span><br><span class="line">ServletContext sc = session.getServletContext();</span><br><span class="line">//获取要下载的文件的输入流</span><br><span class="line">InputStream in  = </span><br><span class="line">sc.getResourceAsStream(&quot;download&quot;+File.separator+&quot;xg.jpg&quot;);</span><br><span class="line"></span><br><span class="line">// in.available()流中读取到的最大长度</span><br><span class="line">images = new byte[in.available()];</span><br><span class="line">//将字节读取到数组中 </span><br><span class="line">in.read(images);</span><br><span class="line"></span><br><span class="line">//构造ResponseEntity</span><br><span class="line"></span><br><span class="line">HttpHeaders headers = new HttpHeaders();</span><br><span class="line">//设置响应头信息   告诉浏览器数据格式，以及如何进行处理. </span><br><span class="line">headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=xg.jpg&quot;);</span><br><span class="line"></span><br><span class="line">HttpStatus  statusCode = HttpStatus.OK;  // 200</span><br><span class="line"></span><br><span class="line">ResponseEntity&lt;byte []&gt; re= </span><br><span class="line">new ResponseEntity&lt;byte[]&gt;(images, headers, statusCode);</span><br><span class="line"></span><br><span class="line">return re ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上传-1"><a href="#上传-1" class="headerlink" title="上传"></a>上传</h3><p>配置上传信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置上传 组件 </span><br><span class="line"> 注意:  id必须指定成 multipartResolver</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=&quot;multipartResolver&quot; </span><br><span class="line">class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</span><br><span class="line">&lt;!-- 指定成与 上传表单所在的页面的编码一致 --&gt;</span><br><span class="line">&lt;property name=&quot;defaultEncoding&quot;  value=&quot;utf-8&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;!-- 设置最大的上传文件大小 --&gt;</span><br><span class="line">&lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>上传：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/upload&quot;)</span><br><span class="line">public String  testFileUpload(@RequestParam(&quot;uploadFile&quot;)MultipartFile  uploadFile,</span><br><span class="line">@RequestParam(&quot;desc&quot;)String desc,HttpSession session )</span><br><span class="line">throws Exception&#123;</span><br><span class="line">System.out.println(&quot;desc:&quot; +desc );</span><br><span class="line">//将上传过来的文件 保存到 upload文件夹下。</span><br><span class="line">ServletContext sc  = session.getServletContext();</span><br><span class="line">//获取上传文件的名字</span><br><span class="line">String fileName = uploadFile.getOriginalFilename(); </span><br><span class="line">//获取upload文件夹的真实路径</span><br><span class="line">String realPath = sc.getRealPath(&quot;upload&quot;);</span><br><span class="line">//通过File描述目标文件</span><br><span class="line">File  targetFile = new File(realPath+File.separator + fileName );</span><br><span class="line"></span><br><span class="line">uploadFile.transferTo(targetFile);</span><br><span class="line"></span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文件的上传从本质上来说就是将本地的文件通过I/O流将本地文件复制到服务器的某个文件夹下，下载是一个与它相反的操作，将读取服务器的文件，copy到本地文件存储。所以说上传下载，首先就离不开文件读写与复制。&lt;/p&gt;
&lt;h2 id=&quot;复制文件&quot;&gt;&lt;a href=&quot;#复制文件&quot; c
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>电商项目-项目初始化阶段</title>
    <link href="http://yoursite.com/2018/07/18/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%BF%83%E5%BE%97-%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/07/18/电商项目心得-二/</id>
    <published>2018-07-18T12:29:02.000Z</published>
    <updated>2018-07-18T12:33:35.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库初始化"><a href="#数据库初始化" class="headerlink" title="数据库初始化"></a>数据库初始化</h2><p>分配了测试数据库的用户及密码，测试数据已经模拟好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库初始化&quot;&gt;&lt;a href=&quot;#数据库初始化&quot; class=&quot;headerlink&quot; title=&quot;数据库初始化&quot;&gt;&lt;/a&gt;数据库初始化&lt;/h2&gt;&lt;p&gt;分配了测试数据库的用户及密码，测试数据已经模拟好了。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>电商项目-数据表设计部分</title>
    <link href="http://yoursite.com/2018/07/18/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%BF%83%E5%BE%97-%E4%B8%80/"/>
    <id>http://yoursite.com/2018/07/18/电商项目心得-一/</id>
    <published>2018-07-18T11:24:33.000Z</published>
    <updated>2018-07-18T12:28:31.306Z</updated>
    
    <content type="html"><![CDATA[<p>最近接手一个电商项目，在独立完成这个项目的过程中学习到一些实用的代码习惯和设计思路，并且熟练使用一些不错的开发工具，整个项目完成让我对于Java项目的开发有了比较系统的理解，所以整理一下最近学到的东西。具体代码细节不好发出来就简单来谈谈，留作以后学习使用。</p><h2 id="项目表Design"><a href="#项目表Design" class="headerlink" title="项目表Design"></a>项目表Design</h2><h3 id="用户表"><a href="#用户表" class="headerlink" title="用户表"></a>用户表</h3><ol><li>用户名是唯一字段，是不可以重复的，我们这里采取的方案是将唯一判断交给mysql来做，我们的代码里不做就实现，这样做的好处是一方面减少了我们代码，另一方面可用于后期的分布式的架构依然可以以简单的方式实现。</li><li>增加了密保问题及密保答案字段，用于密码丢失修改操作的凭证。</li><li>用户身份字段，为用户权限的操作的设计。</li><li>时间字段分为创建用户时间字段，和最后一次修改的时间字段，这个时间字段我们所有的表中都要使用到，这两个时间之间的区间可以帮助我们减少trouble shooting的时间。<h3 id="商品分类表"><a href="#商品分类表" class="headerlink" title="商品分类表"></a>商品分类表</h3></li><li>表设计必须可以递归，分类可能无限多层级扩展，所以我们设置一个父类id字段，一级分类的父id设置为0作为跳出递归的条件。<h3 id="商品信息表"><a href="#商品信息表" class="headerlink" title="商品信息表"></a>商品信息表</h3></li><li>商品展示主图片存在数据库中以相对路径方式存储，这样图片服务器进行迁移后，只需要修改相关的配置文件图片依然可以正常获得。</li><li>商品详细多图展示不限制图片数量，使用json格式存储，数据库字段使用text不限制长度。</li><li>主图默认就使用子图的第一张，项目里很多时候都只展示主图，单独字段增加冗余性。<h3 id="购物车id"><a href="#购物车id" class="headerlink" title="购物车id"></a>购物车id</h3></li><li>购物车信息进行持久化操作。</li><li>设置勾选状态字段，用于订单生成时做判断。<h3 id="信息支付表"><a href="#信息支付表" class="headerlink" title="信息支付表"></a>信息支付表</h3></li><li>用于支付宝对接的信息记录。</li><li>包括支付宝端的流水号和支付状态。<h3 id="订单表"><a href="#订单表" class="headerlink" title="订单表"></a>订单表</h3></li><li>订单表也是设计为唯一索引。</li><li>实际付款金额字段，此处不可使用外键查询，不是因为外间查询效率问题，而是订单生成时的价格和当前的价格可能不相同，所以商品价格变化时使用外间查询的到的价格是错误的价格。<h3 id="订单明细表"><a href="#订单明细表" class="headerlink" title="订单明细表"></a>订单明细表</h3></li><li>此处的用户id没有进行连表查询是因为增加冗余，sql查询效率更高，我们在实际的生产中真的会减少联表查询来增加sql查询的效率。<h3 id="收货地址表"><a href="#收货地址表" class="headerlink" title="收货地址表"></a>收货地址表</h3></li><li>没什么特别的。</li></ol><p>这个数据表比较的简单，设计的时候也没有使用到外键，触发器等，扩展分布分表有外键不利于扩展，数据清理的外键关系处理起来也非常的麻烦。为了保证数据库可以容纳更多用户操作，冗余字段(主图字段)的设计必不可少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近接手一个电商项目，在独立完成这个项目的过程中学习到一些实用的代码习惯和设计思路，并且熟练使用一些不错的开发工具，整个项目完成让我对于Java项目的开发有了比较系统的理解，所以整理一下最近学到的东西。具体代码细节不好发出来就简单来谈谈，留作以后学习使用。&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>动态代理</title>
    <link href="http://yoursite.com/2018/07/16/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/16/动态代理/</id>
    <published>2018-07-16T12:40:10.000Z</published>
    <updated>2018-08-07T03:40:05.244Z</updated>
    
    <content type="html"><![CDATA[<p>有关于代理模式我之前的简单设计模式中也有提到过，当时说得是静态代理模式，动态代理与之实现的情景比较相似，可以继承实现接口、类的方式更为通用。代理设计模式的原理：使用一个代理对象将目标对象包装起来，然后用该代理对象”取代”原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p><h2 id="coding"><a href="#coding" class="headerlink" title="coding"></a>coding</h2><p>关于动态代理，大的方面可以分为两部分：代理对象与原始对象。我们一JDK的动态代理为基础来讲解，JDK动态代理需要目标对象有接口类需要实现。</p><h3 id="原始对象"><a href="#原始对象" class="headerlink" title="原始对象"></a>原始对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jeff_code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArithmeticCal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jeff_code.ArithmeticCalImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jeff_code.ArithmeticCal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArithmeticCalImpl</span> <span class="keyword">implements</span> <span class="title">ArithmeticCal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i * j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i / j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要给原始对象扩展功能，关闭修改。使用动态代理再合适不过，这里就简单添加一个打印日志的功能。</p><h3 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jeff_code.DynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jeff_code.ArithmeticCal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类不是代理对象，代理对象在这个类中获取到，Proxy.newProxyInstance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是原始对象，作为代理对象的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> ArithmeticCal target ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(ArithmeticCal target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取代理对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object proxy = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ClassLoader loader = target.getClass().getClassLoader();</span><br><span class="line">        Class[] interfaces = target.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">        proxy = Proxy.newProxyInstance(loader, interfaces,<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Object proxy :  代理对象.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Method method : 正在被调用的方法</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Object [] args: 方法的参数</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">//获取方法的名字</span></span><br><span class="line">                String methodName = method.getName();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//日志</span></span><br><span class="line">                System.out.println(<span class="string">"Proxy==&gt;The method "</span> + methodName + <span class="string">" begin with : "</span> + Arrays.asList(args));</span><br><span class="line">                <span class="comment">// 执行 真正的目标方法: +  -  *  /</span></span><br><span class="line">                Object result = method.invoke(target, args);</span><br><span class="line">                <span class="comment">//日志</span></span><br><span class="line">                System.out.println(<span class="string">"Proxy==&gt;The method "</span> + methodName +<span class="string">" ends with : "</span> + result );</span><br><span class="line">                <span class="keyword">return</span> result ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy类是所有动态代理类的父类，主要就是生成代理类或者直接生成代理对象。<br>返回代理类的Class对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Class&lt;?&gt; getProxyClass(ClassLoader loader,Class&lt;?&gt;... interfaces)</span><br></pre></td></tr></table></figure></p><p>返回代理类实例对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span><br></pre></td></tr></table></figure></p><p>我们这里就直接使用Proxy类生成一个代理类实例对象。newProxyInstance中的三个参数分别是原始对象的类加载器，原始对象类的继承接口们以及InvocationHandler的匿名内部类。匿名内部类中执行代理对象操作原始对象的方法，并且此方法除了代理对象的方法还增加额外的日志功能。这个过程就是动态的生成加载出一个代理类对象(要使用到类加载器加载出这个类，这个代理类要和原始类有一样的接口，这样调用这个代理类就和使用原始类感觉上没差了)。</p><p>那么我们的动态代理类中进行了哪些操作呢？我们使用伪代码来展示一下细节部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class $Proxy0000 extends Proxy implements ArithmeticCalculator&#123;</span><br><span class="line"></span><br><span class="line">protected $Proxy0000(InvocationHandler h) &#123;</span><br><span class="line">super(h);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int add(int i, int j) &#123;</span><br><span class="line"></span><br><span class="line">//return  super.h.invoke(this,&quot;add&quot;,[i,j]);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int sub(int i, int j) &#123;return 0;&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int mul(int i, int j) &#123;return 0;&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int div(int i, int j) &#123;return 0;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个代理类就是实现我我们生成动态代理对象的类，这个类继承了代理类的父类Proxy然后实现了原始类的所有的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Proxy() &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>Proxy中的无参构造器是私有的，所以子类是不可以直接调用他的无参构造的，所以我们需要给子类增加一个构造器，调用父类的有参构造器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Proxy(InvocationHandler h) &#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    this.h = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>父类的有参构造器都需要一个参数就是InvocationHandler对象，所以我们的子类调用父类的有参构造器也需要相应的传入需要的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return  super.h.invoke(this,&quot;add&quot;,[i,j]);</span><br></pre></td></tr></table></figure></p><p>此时我们super.h的参数就是我们传入的匿名内部类的InvocationHandler(子类的有参构造器传入的，父类的成员变量在父类构造器中被赋值，所以这三个h都是用同一个InvocationHandler对象，即我们传入的InvocationHandler对象)，我们的实现类中(伪代码)，每一个父类的接口都实现了并且执行了invoke方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 使用getClass实现</span><br><span class="line">Class proxyClass = Proxy.getProxyClass(loader, interfaces);</span><br><span class="line"></span><br><span class="line">//获取到代理类中的构造器</span><br><span class="line">Constructor con = proxyClass.getDeclaredConstructor(InvocationHandler.class);</span><br><span class="line"></span><br><span class="line">proxy = con.newInstance(new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">//获取方法的名字</span><br><span class="line">String methodName = method.getName();</span><br><span class="line"></span><br><span class="line">//日志</span><br><span class="line">System.out.println(&quot;Proxy2==&gt;The method &quot; + methodName + &quot; begin with : &quot; + Arrays.asList(args));</span><br><span class="line">// 执行 真正的目标方法: +  -  *  /</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">//日志</span><br><span class="line">System.out.println(&quot;Proxy2==&gt;The method &quot; + methodName +&quot; ends with : &quot; + result );</span><br><span class="line">return result ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>我们使用反编译工具将动态生成的代理的对象的.class代码转换成.java代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="line">// (powered by Fernflower decompiler)</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">package com.sun.proxy;</span><br><span class="line"></span><br><span class="line">import com.jeff_code.ArithmeticCal;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">public final class $Proxy0 extends Proxy implements ArithmeticCal &#123;</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m5;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m4;</span><br><span class="line">    private static Method m6;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int mul(int var1, int var2) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var4) &#123;</span><br><span class="line">            throw var4;</span><br><span class="line">        &#125; catch (Throwable var5) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int add(int var1, int var2) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m3, new Object[]&#123;var1, var2&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var4) &#123;</span><br><span class="line">            throw var4;</span><br><span class="line">        &#125; catch (Throwable var5) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int sub(int var1, int var2) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m4, new Object[]&#123;var1, var2&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var4) &#123;</span><br><span class="line">            throw var4;</span><br><span class="line">        &#125; catch (Throwable var5) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int div(int var1, int var2) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m6, new Object[]&#123;var1, var2&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var4) &#123;</span><br><span class="line">            throw var4;</span><br><span class="line">        &#125; catch (Throwable var5) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m0, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m5 = Class.forName(&quot;com.jeff_code.ArithmeticCal&quot;).getMethod(&quot;mul&quot;, Integer.TYPE, Integer.TYPE);</span><br><span class="line">            m3 = Class.forName(&quot;com.jeff_code.ArithmeticCal&quot;).getMethod(&quot;add&quot;, Integer.TYPE, Integer.TYPE);</span><br><span class="line">            m4 = Class.forName(&quot;com.jeff_code.ArithmeticCal&quot;).getMethod(&quot;sub&quot;, Integer.TYPE, Integer.TYPE);</span><br><span class="line">            m6 = Class.forName(&quot;com.jeff_code.ArithmeticCal&quot;).getMethod(&quot;div&quot;, Integer.TYPE, Integer.TYPE);</span><br><span class="line">            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与我们伪代码实现的方式思路是一致的，这段代码是我们实现这个过程的细节，我们实际生成动态代理对象的时候使用的就是Proxy的getProxyClass()或者newProxyInstance()即可，底层由Proxy父类实现。</p><p>上述过程是基于接口的JDK动态代理。</p><h2 id="Spring的AOP编程"><a href="#Spring的AOP编程" class="headerlink" title="Spring的AOP编程"></a>Spring的AOP编程</h2><p>Spring的AOP编程就是基于动态代理实现的。简单来说动态代理分为两类，基于接口或者基于继承，当代理的原始对象实现了接口的时候，AOP会根据实际情况实现基于接口的动态代理，当原始对象没有实现接口的时候，相应的Spring的AOP会实现一个而基于继承的动态代理类。</p><h3 id="AOP的简介"><a href="#AOP的简介" class="headerlink" title="AOP的简介"></a>AOP的简介</h3><ol><li>AOP(Aspect-Oriented Programming，面向切面编程)：是一种新的方法论，是对传统 OOP(Object-Oriented Programming，面向对象编程)的补充。</li><li>AOP编程操作的主要对象是切面(aspect)，而切面模块化横切关注点。</li><li>在应用AOP编程时，仍然需要定义公共功能，但可以明确的定义这个功能应用在哪里，以什么方式应用，并且不必修改受影响的类。这样一来横切关注点就被模块化到特殊的类里——这样的类我们通常称之为“切面”。</li><li>每个事物逻辑位于一个位置，代码不分散，便于维护和升级同时业务模块更简洁，只包含核心业务代码。</li></ol><p>关于Spring的AOP编程，有时间再细谈，其主要的实现就是基于动态代理实现的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有关于代理模式我之前的简单设计模式中也有提到过，当时说得是静态代理模式，动态代理与之实现的情景比较相似，可以继承实现接口、类的方式更为通用。代理设计模式的原理：使用一个代理对象将目标对象包装起来，然后用该代理对象”取代”原始对象。任何对原始对象的调用都要通过代理。代理对象决
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>2018夏季减肥大会伊始</title>
    <link href="http://yoursite.com/2018/07/12/2018%E5%A4%8F%E5%AD%A3%E5%87%8F%E8%82%A5%E5%A4%A7%E4%BC%9A%E4%BC%8A%E5%A7%8B/"/>
    <id>http://yoursite.com/2018/07/12/2018夏季减肥大会伊始/</id>
    <published>2018-07-12T14:28:18.000Z</published>
    <updated>2018-08-04T14:31:34.499Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下今年锻炼的战绩，过年前是119<code>*</code>500g。年后去了趟上海涨了20<em>500g。后来起起伏伏，最近要开始抽时间控制一下了，正所谓七月不减肥，八月徒伤悲。7.12减脂大会正式开幕。<br>记不得过了几天了，今天是180804体重掉下130`</em><code>500g 了,现在是129.6</code>*`500g，加油，8月你是最胖的。</p><p>day16,17 skip 0<br>height： 132.2<code>*</code>500g<br>学习第一。。。推推轮子，跳绳暂时停一下</p><p>day16,17 skip 0<br>学习第一。。。推推轮子，跳绳暂时停一下</p><p>day15 skip 0<br>height： 132.4<code>*</code>500g<br>忙休一天</p><p>day15 skip 2250次<br>height： 131.4<code>*</code>500g</p><p>day14 skip 2250次<br>height： 132.5<code>*</code>500g</p><p>day13 skip 0<br>height： 134.1<code>*</code>500g<br>下雨，休息。</p><p>day12 skip 0<br>height： 135.9<code>*</code>500g<br>下雨，休息。</p><p>day11 skip 2234次<br>height： 133.5<code>*</code>500g<br>推推轮子，一周赶超lb，fighting，吃了很多，返璞归真。</p><p>day10 skip n次，n&gt;2000<br>height： 134.2<code>*</code>500g<br>推推轮子，一周赶超lb，fighting，吃了很多，返璞归真。</p><p>day09 zero<br>height： 133.7<code>*</code>500g<br>推推轮子吧，突如其来的大雨。</p><p>day08 skip 2156次<br>height： 131.9<code>*</code>500g<br>推推轮子，一周赶超lb，fighting。</p><p>day07 skip 2222次<br>height： 133.0<code>*</code>500g<br><img src="http://p94ypeu3q.bkt.clouddn.com/20180718225445.png" alt="20180718225445"><br>推推轮子，一周赶超lb，fighting。</p><p>day06 zero<br>height： 135.9<code>*</code>500g<br>下大雨，继续鸽咯。</p><p>day05 zero<br>height： 136.1<code>*</code>500g<br>下大雨，继续鸽咯。</p><p>day04 zero<br>height： 134.6*500g<br>继续放鸽子，好久不运动现在已经推不动轮子了。</p><p>day03 skip 2254次<br>height： 133.8*500g<br><img src="http://p94ypeu3q.bkt.clouddn.com/IMG_20180714_222233.jpg" alt="IMG_20180714_222233"></p><p>day02 zero<br>第二天就放鸽子了。。。不太妙啊。</p><p>day01 skip 2101次<br>init体重：133.8*500g<br><img src="http://p94ypeu3q.bkt.clouddn.com/IMG_20180712.jpg" alt="IMG_20180712"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一下今年锻炼的战绩，过年前是119&lt;code&gt;*&lt;/code&gt;500g。年后去了趟上海涨了20&lt;em&gt;500g。后来起起伏伏，最近要开始抽时间控制一下了，正所谓七月不减肥，八月徒伤悲。7.12减脂大会正式开幕。&lt;br&gt;记不得过了几天了，今天是180804体重掉下130`
      
    
    </summary>
    
      <category term="Life" scheme="http://yoursite.com/categories/Life/"/>
    
    
      <category term="Life" scheme="http://yoursite.com/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>JSP(含EL表达式)</title>
    <link href="http://yoursite.com/2018/07/03/JSP/"/>
    <id>http://yoursite.com/2018/07/03/JSP/</id>
    <published>2018-07-03T06:38:20.000Z</published>
    <updated>2018-07-05T03:08:38.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是JSP"><a href="#什么是JSP" class="headerlink" title="什么是JSP"></a>什么是JSP</h2><p>JSP全称Java Server Pages，指运行在java服务器中的页面，也就是在我们JavaWeb中的动态页面，JSP本质就是一个Servlet。</p><h2 id="JSP文件的组成"><a href="#JSP文件的组成" class="headerlink" title="JSP文件的组成"></a>JSP文件的组成</h2><p>JSP的主要构成有HTML网页代码、Java代码片段、JSP标签几部分组成，后缀是.jsp。</p><p>Tips：用户访问jsp页面时，服务器会将jsp页面翻译为Servlet.java 存到工作空间的tomcat的work文件夹内，再将其编译为class文件，处理用户请求时，其实是服务器调用了翻译后的servlet的生命周期方法处理的请求（_jspService方法）。翻译后的类又继承了HttpServlet[HttpJspBase extends HttpServlet]（HttpJspBase的三大周期函数的封装为_jspInit，_jspDestroy和_jspService），所有访问.jsp文件的请求都被服务器处理了，配置文件在tomcat配置文件的web.xml里。</p><p>服务器将jsp翻译成servlet的规则：</p><ol><li>html内容[标签+html注释]:原封不动作为out.writer()的字符串参数写入到响应体中;</li><li>jsp脚本片段[java代码，相当于在service方法内写java代码]:原封不动按顺序拷贝到翻译后的service方法中;</li><li>jsp表达式[变量 ， 相当于将变量的值交给out.print()使用]:作为out.print()的参数将变量的值写入到响应体中。<h2 id="Why-JSP"><a href="#Why-JSP" class="headerlink" title="Why JSP"></a>Why JSP</h2>html写的页面没法动态显示，也不能写入逻辑代码，控制循环语句等，非常的死板，一些功能也不好实现。servlet倒是可以写逻辑代码，也能在response中返回HTML页面，但是对于复杂页面，写起来就非常的复杂，所以服务器会将一种特定语法的文件转译成Java的servlet，这种文件语法更简单，它本质就是servlet，这种特定语法的文件就是jsp文件和语法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">//1、获取用户提交的username参数</span><br><span class="line">String username = request.getParameter(&quot;username&quot;);</span><br><span class="line"></span><br><span class="line">//2、处理业务逻辑</span><br><span class="line"></span><br><span class="line">//3、给用户响应一个动态页面，在页面中显示用户名</span><br><span class="line">PrintWriter writer = response.getWriter();</span><br><span class="line">writer.write(&quot;&lt;h1 style=&apos;color:red;&apos;&gt;&quot;);</span><br><span class="line">if(username!=null) &#123;</span><br><span class="line">writer.write(&quot;您的用户名是：&quot;);</span><br><span class="line">writer.write(username);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">writer.write(&quot;游客您好，您还没有登录&quot;);</span><br><span class="line">&#125;</span><br><span class="line">writer.write(&quot;&lt;/h1&gt;&quot;);</span><br></pre></td></tr></table></figure></li></ol><p>此为servlet动态生成一个HTML文件的操作(静态页面没有变量无法动态修改username的值动态显示)，只是返回一个H1标签就可以看出其繁琐程度。JSP就是特定语法结构的servlet，用页面开发servlet(服务器自行转换为Java代码)，所以浏览器本身是不可以直接打开JSP文件的。</p><h2 id="JSP的优势"><a href="#JSP的优势" class="headerlink" title="JSP的优势"></a>JSP的优势</h2><p>与HTML相比：JSP相比HTML页面来说，最直观的功能就是可以在页面中使用变量，这些变量一般是从域对象中获取。有了变量我们的页面就可以动态的显示信息。<br>与Servlet相比：相比于一般的Servlet，JSP更加善于处理显示页面，而Servlet跟擅长处理业务逻辑，两种技术各有专长，所以一般我们会将Servlet和JSP结合使用，Servlet负责业务，JSP负责显示。</p><h2 id="如何使用JSP"><a href="#如何使用JSP" class="headerlink" title="如何使用JSP"></a>如何使用JSP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   &lt;%-- 这是一个HTML标签  --%&gt;</span><br><span class="line">&lt;h3&gt;我的第一个动态页面&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">   &lt;%--这是一个jsp脚本片段(Java代码)--%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">//java注释</span><br><span class="line">int a = 1;</span><br><span class="line">System.out.println(&quot;.........&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%--这是一个jsp表达式--%&gt;</span><br><span class="line">&lt;%=a %&gt;</span><br><span class="line">&lt;%=new Date() %&gt;</span><br></pre></td></tr></table></figure><p>tomcat服务器将这段jsp代码转化成Java的servlet：<img src="http://p94ypeu3q.bkt.clouddn.com/JSP转Java类.png" alt="JSP转Java类"></p><h3 id="JSP的指令"><a href="#JSP的指令" class="headerlink" title="JSP的指令"></a>JSP的指令</h3><h4 id="page"><a href="#page" class="headerlink" title="page"></a>page</h4><p>page指令的作用是控制页面的设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot; %&gt;</span><br><span class="line">&lt;!-- page指令</span><br><span class="line">    language   页面支持的语言类型  只有一个值java(此前设计时认为可能会扩展到多门语言，但是此时只有一种语言)</span><br><span class="line">    contentType   相当于response.setContenType();</span><br><span class="line">    pageEncoding  jsp页面被jsp引擎翻译为Servlet时使用的编码，默认使用ISO8859-1，国际化以后都使用utf-8</span><br><span class="line">    import   导包</span><br><span class="line">    </span><br><span class="line">    &lt;%--基本上使用不到的属性 --%&gt;</span><br><span class="line">    errorPage 指定错误页面，当前页面发生错误后会跳转到错误页面</span><br><span class="line">    isErrorPage 设置当前页面是否为错误页面，默认false不是</span><br><span class="line">    isELIgnored 是否忽略EL表达式，默认false不忽略</span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure></p><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>include指令是静态包含指令，可以将其他页面静态导入到当前页面中，静态导入的意思就是原封不动将目标页面的代码拷贝到当前页面中，在早期版本修改被导入的页面服务器不会捕捉，tomcat7以后会自动修改。<br><code>&lt;%@ include file=&quot;/helloworld.jsp&quot;  %&gt;</code><br>file指向的绝对路径由服务器解析，静态导入的文件是不会被服务器编译成class文件的，相当于编译的时候将include文件直接覆盖原文件的include语句然后tomcat服务器只编译这一个文件即可。</p><h4 id="taglib"><a href="#taglib" class="headerlink" title="taglib"></a>taglib</h4><p>taglib指令是标签库引入指令。</p><h3 id="JSP动作标签"><a href="#JSP动作标签" class="headerlink" title="JSP动作标签"></a>JSP动作标签</h3><p>为了简化开发，jsp将某些功能java代码封装成了类似标签的样式，其实本质仍然是java代码，JSP动作标签与HTML标签不同，HTML标签由浏览器来解析，而JSP动作标签需要服务器（Tomcat）来运行。<br>转发动作标签：<code>&lt;jsp:forward &gt;&lt;/jsp:forward&gt;</code>;<br>page转发路径：<code>&lt;jsp:forward page=&quot;/helloworld.jsp&quot;&gt;&lt;/jsp:forward&gt; --%&gt;</code><br>动态包含标签：可以将目标页面动态包含到当前页面中,目标文件和当前文件都会被编译，效率低一般不会使用。<code>&lt;jsp:include page=&quot;/helloworld.jsp&quot;&gt;&lt;/jsp:include&gt;</code></p><h2 id="JSP九大内置对象"><a href="#JSP九大内置对象" class="headerlink" title="JSP九大内置对象"></a>JSP九大内置对象</h2><p>因为jsp页面在翻译后，jsp脚本片段和表达式会被翻译到service方法内（最终调用生命周期方法service），所以在表达式和脚本片段中可以直接使用翻译后的service方法中声明的9个变量。因为这九个变量是声明在service方法里的，所以我们可以在jsp的表达式和脚本片段中使用这9大内置对象。</p><h3 id="pageContext"><a href="#pageContext" class="headerlink" title="pageContext"></a>pageContext</h3><p>类型是PageContext，代表了jsp页面的上下文对象（jsp当前页的共享信息，共享对象），作用是在当前页面的范围内共享数据，每个页面由自己唯一的一个页面上下文对象，jsp页面特有，它可以获取jsp的其他8个隐含对象。</p><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>类型是HttpServletRequest，代表了请求对象/请求域，作用是获取请求报文数据，转发，在一次请求中共享数据(域对象： 转发 )。</p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>类型是HttpSession，代表了一次会话，浏览器打开第一次访问服务器开始到浏览器关闭的一次过程就是一次会话，作用： 在一次会话的过程中共享数据(域对象)。</p><h3 id="application"><a href="#application" class="headerlink" title="application"></a>application</h3><p>类型是ServletContext，作用是在整个项目范围内共享数据，一个项目对应唯一的一个全局上下文对象，存在于服务器关闭或重启前。</p><p>这四个内置对象也是jsp的四大域对象。</p><h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><p>类型是HttpServletResponse，代表了响应对象，作用是设置响应体、响应头、重定向。</p><h3 id="out"><a href="#out" class="headerlink" title="out"></a>out</h3><p>类型是JspWriter，代表了响应体的输出流，作用是向响应体中写数据，service中将jsp翻译成servlet就是使用的这个对象。</p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>类型是ServletConfig，代表了翻译后的servlet的配置文件对象。</p><h3 id="page-1"><a href="#page-1" class="headerlink" title="page"></a>page</h3><p>类型是Object，代表了翻译后的servlet的实例， 使用Object类型接收。</p><h3 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h3><p>只有当jsp页面为错误页面时才有exception对象，将page设置为isErrorPage=”true” ， 错误页面中可以获取其他页面的错误信息，类型是Throwable最大的异常错误类，代表了上个页面发生的错误异常，作用是获取上个页面的错误异常信息，根据错误给用户提示。</p><p>除了四个域对象使用的比较多，其他的域对象基本上很少使用，exception在当前的生产已经不适用了。关于为什么一些技术不使用，过时了还是要看，因为在一些老的项目里时常会遇到一些奇特的代码，而当时的技术局限，很可能使用的就是我们现在所谓的过时的技术，过时的代码，所以还是需要有印象，在遇到的时候能解决问题。</p><h2 id="JSP四大域对象"><a href="#JSP四大域对象" class="headerlink" title="JSP四大域对象"></a>JSP四大域对象</h2><p>Java域对象底层就是Map<string ,="" object="">，域对象都有的方法：</string></p><ol><li>向域中存储数据的方法： void setAttribute(String key ,Object value);</li><li>从域中获取数据的方法：Object getAttribute(String key);</li><li>移除域中指定属性的方法：void removeAttribute(String key);<br>四大域对象作用是能够在web项目的不同资源中共享数据，使用时，必须先存储再获取。<h2 id="Expression-Language表达式"><a href="#Expression-Language表达式" class="headerlink" title="Expression Language表达式"></a>Expression Language表达式</h2>EL表达式是JSP内置的表达式语言（不可以在HTML和servlet中使用），用以访问页面的上下文以及不同作用域中的对象 ，取得对象属性的值，或执行简单的运算或判断操作。EL在得到某个数据时，会自动进行数据类型的转换。EL表达式用于代替JSP表达式(&lt;%= %&gt;)在页面中做输出操作。EL表达式仅仅用来读取数据，而不能对数据进行修改，当读取的数据是null的时候EL表达式会自动忽略，即不输出。<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="EL基本使用"><a href="#EL基本使用" class="headerlink" title="EL基本使用"></a>EL基本使用</h3><h4 id="全域查询"><a href="#全域查询" class="headerlink" title="全域查询"></a>全域查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;key &#125;</span><br></pre></td></tr></table></figure><p>默认全域查询key对应的值，从最小域到最大域遍历查询，找到则返回停止遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 实现思路</span><br><span class="line">Object val = null;</span><br><span class="line">val = pageContext.getAttribute(&quot;key&quot;);</span><br><span class="line">if(val==null)&#123;</span><br><span class="line">    //page域中没有获取到</span><br><span class="line">    val = request.getAttribute(&quot;key&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if(val==null)&#123;</span><br><span class="line">    //request域中没有获取到</span><br><span class="line">    val = session.getAttribute(&quot;key&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if(val==null)&#123;</span><br><span class="line">    //session域中没有获取到</span><br><span class="line">    val = application.getAttribute(&quot;key&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if(val==null)&#123;</span><br><span class="line">    val=&quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="指定域获取属性"><a href="#指定域获取属性" class="headerlink" title="指定域获取属性"></a>指定域获取属性</h4><p>pageScope,requestScope,sessionScope,applicationScope;<br>域对象的类型是Map<string ,="" object="">。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;指定域Scope.key &#125;</span><br></pre></td></tr></table></figure></string></p><h4 id="域中的对象的属性"><a href="#域中的对象的属性" class="headerlink" title="域中的对象的属性"></a>域中的对象的属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;user.属性名&#125;</span><br></pre></td></tr></table></figure><p>EL会自动调用user对象的get属性名方法(“get” + 属性名首字母大写)，不论这个对象里有没有这个属性名，只要能找到”get” + 属性名首字母大写属性方法即可，此属性方法必须有返回值，与其他的get方法一致。</p><h4 id="域中的list指定下标的元素"><a href="#域中的list指定下标的元素" class="headerlink" title="域中的list指定下标的元素"></a>域中的list指定下标的元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;list[index]&#125;</span><br></pre></td></tr></table></figure><h4 id="域中的map指定键对应的值"><a href="#域中的map指定键对应的值" class="headerlink" title="域中的map指定键对应的值"></a>域中的map指定键对应的值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&#123;map.key &#125;</span><br><span class="line"></span><br><span class="line">// map中有特殊键时，键有特殊符号，key为t2-1时，会被EL表达式认为是map.t2-1,即(map.t2)-1，得到答案是-1，不是它对应的值</span><br><span class="line">$&#123;map[&apos;key&apos;]&#125;   </span><br><span class="line">// 例如：</span><br><span class="line">$&#123;map[&apos;t2-1&apos;]&#125;</span><br></pre></td></tr></table></figure><h3 id="EL的十一个内置对象"><a href="#EL的十一个内置对象" class="headerlink" title="EL的十一个内置对象"></a>EL的十一个内置对象</h3><ol><li>四个域对象：pageScope、requestScope、sessionScope、applicationScope；</li><li>pageContext：用来获取jsp的其他8个隐含对象，等于EL一个内置对象就包含了jsp的九个内置对象；</li><li>param：获取请求中的参数，类型是Map<string ,="" string="">，<code>${param.name}</code>；</string></li><li>paramValues:获取请求参数的多个值，类型是：Map<string ,="" string[]="">，<code>${paramValues.key[index] }</code>；</string></li><li>header：请求头数据，类型是：Map<string ,="" string="">，<code>${header.name }</code>或<code>${header[&#39;User-Agent&#39;] }</code>；</string></li><li>headerValues：一个请求头的键对应多个值，类型是：Map<string ,="" string[]="">,基本上用不上；</string></li><li>initParam：翻译后的Servlet配置的初始化参数，类型是：Map&lt;String,String&gt;，基本上用不上；</li><li>cookie：获取浏览器请求报文中的Cookie，类型是：Map<string ,cookie="">，<br>使用内置对象获取当前项目的地址：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageContext.request.scheme &#125;://$&#123;pageContext.request.serverName &#125;:$&#123;pageContext.request.serverPort &#125;$&#123;pageContext.request.contextPath &#125;/</span><br></pre></td></tr></table></figure></string></li></ol><h3 id="EL支持运算符"><a href="#EL支持运算符" class="headerlink" title="EL支持运算符"></a>EL支持运算符</h3><p>EL表达式支持一般的运算符，且+不表示拼接，也可以使用三元表达式等运算符。比较特殊的是empty运算符，empty判断集合或字符串是否为空，如果集合字符串==null或者长度为0，那么empty认为是空，即数组、集合、字符串等可以直接判断长度的为空直接会被省略，但是自定义的类没有给定length，size等判断长度的方法，则不会被当作是空。</p><h2 id="JSP-Standard-Tag-Library"><a href="#JSP-Standard-Tag-Library" class="headerlink" title="JSP Standard Tag Library"></a>JSP Standard Tag Library</h2><p>EL表达式配合JSTL的流程控制就是取代原生JSP的，原生JSP的if，for写起来非常繁琐，而且无法调试，页面一庞大就很难找到页面的bug，用起来非常的不人性化，所以使用JSTL替代JSP脚本片段，就是将JSP的脚本片段进行封装，得以使用jsp标签形式使用Java代码，将代码量大大减少，层级结构更清晰，所以调试起来就更简单了。</p><h3 id="常用的JSTL标签库"><a href="#常用的JSTL标签库" class="headerlink" title="常用的JSTL标签库"></a>常用的JSTL标签库</h3><p>使用前先导入jar包，然后在项目的头部导入，使用taglib指令，uri属性是指向引入标签库的唯一标志，prefix属性是标签库在页面中使用时的前缀，例如：<code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;</code>。</p><h4 id="核心标签库core"><a href="#核心标签库core" class="headerlink" title="核心标签库core"></a>核心标签库core</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;%</span><br><span class="line"> request.setAttribute(&quot;address&quot;, &quot;家里&quot;);</span><br><span class="line"> request.setAttribute(&quot;code&quot;,&quot;&lt;script&gt;alert(&apos;hehe&apos;)&lt;/script&gt;&quot;);</span><br><span class="line"> %&gt;</span><br><span class="line">&lt;c:out value=&quot;$&#123;address &#125;&quot; default=&quot;未知&quot;&gt;&lt;/c:out&gt;</span><br><span class="line">&lt;%-- $&#123;code &#125; --%&gt;</span><br><span class="line">&lt;c:out value=&quot;$&#123;code &#125;&quot; escapeXml=&quot;true&quot;&gt;&lt;/c:out&gt;</span><br></pre></td></tr></table></figure><p>&lt;c:out &gt;&lt;/c:out&gt;是标签输出，value是输出的值，可以使用EL表达式，default可以设置默认值，可以防止XSS攻击（不转换XML格式）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set scope=&quot;page&quot; var=&quot;uname&quot; value=&quot;laowang1&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:set scope=&quot;request&quot; var=&quot;uname&quot; value=&quot;laowang2&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:set scope=&quot;session&quot; var=&quot;uname&quot; value=&quot;laowang3&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:set scope=&quot;application&quot; var=&quot;uname&quot; value=&quot;laowang4&quot;&gt;&lt;/c:set&gt;</span><br></pre></td></tr></table></figure><p>&lt;c:set &gt;&lt;/c:set&gt;向域中设置值，scope设置到哪个域中，默认设置到page域，var设置的属性名，value设置的属性值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:remove scope=&quot;session&quot; var=&quot;uname&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>&lt;c:remove /&gt;移除域中的值，scope指出移除哪个值，var指定移除的属性名，默认移除所有域中var对应的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:if test=&quot;$&#123;param.age&gt;=18 &#125;&quot;&gt;</span><br><span class="line">&lt;h2&gt;你成年了....&lt;/h2&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><p> &lt;c:if “&gt;&lt;/c:if&gt;语句就是if条件判断语句，只有if没有else部分，当条件比较多的时候也不使用它，因为多个if分支执行的时候都会被判断一遍(没有else)，效率低。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">&lt;c:when test=&quot;$&#123;param.score&gt;=90 &#125;&quot;&gt;</span><br><span class="line">&lt;h3&gt;恭喜你，prefect...&lt;/h3&gt;</span><br><span class="line">&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test=&quot;$&#123;param.score&gt;=80 &#125;&quot;&gt;</span><br><span class="line">&lt;h3&gt;恭喜你，考的不错...&lt;/h3&gt;</span><br><span class="line">&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test=&quot;$&#123;param.score&gt;=60 &#125;&quot;&gt;</span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line"> &lt;c:when test=&quot;$&#123;param.score&gt;=70 &#125;&quot;&gt;</span><br><span class="line"> &lt;h3&gt;恭喜你，比60高了...&lt;/h3&gt;</span><br><span class="line"> &lt;/c:when&gt;</span><br><span class="line"> &lt;c:otherwise&gt;</span><br><span class="line"> &lt;h3&gt;恭喜你，及格万岁...&lt;/h3&gt;</span><br><span class="line"> &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br><span class="line">&lt;/c:when&gt;</span><br><span class="line">&lt;c:otherwise&gt;</span><br><span class="line">&lt;h3&gt;恭喜你，wandan了...&lt;/h3&gt;</span><br><span class="line">&lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure><p>c:choose:创建一个if-else语句结构，c:when相当于if或else if，test属性为语句执行的条件，c:otherwise相当于else。</p><ol><li>choose中可以有多个when子语句，语句之间有互斥关系；</li><li>一般最多有一个otherwise(不是绝对的)；</li><li>choose中只能有when和otherwise子语句(这是绝对的)，在choose中子语句内嵌套if-else结构 ，必须将when和otherwise写在choose标签内；</li><li>条件之间有包含关系，条件范围小写在上面(switch case一致)；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 遍历数组</span><br><span class="line"> &lt;c:forEach begin=&quot;1&quot; end=&quot;5&quot; var=&quot;index&quot; step=&quot;2&quot;&gt;</span><br><span class="line"> &lt;a href=&quot;PageServlet?pageNumber=$&#123;index &#125;&quot;&gt;$&#123;index &#125;&lt;/a&gt;</span><br><span class="line"> &lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p> &lt;c:forEach &gt;&lt;/c:forEach&gt;遍历，begin起始，end结束，var自动会将正在遍历的索引值存到pageContext域中，var的值就是属性名，step步进。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 遍历List集合</span><br><span class="line"> &lt;c:forEach items=&quot;$&#123;list &#125;&quot; var=&quot;item&quot;&gt;</span><br><span class="line"> &lt;h4&gt;呵呵-- $&#123;pageScope.item &#125;&lt;/h4&gt;</span><br><span class="line"> &lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure></p><p>items属性是要遍历的集合，一般通过EL表达式取出设置给标签使用，标签会自动根据集合元素的个数进行遍历。var属性是标签自动会将每次遍历到的元素存到pageContext域中，var的值就是属性名，标签执行完毕后自动会将域中存的遍历数据移除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 遍历map集合</span><br><span class="line"> &lt;c:forEach items=&quot;$&#123;requestScope.map &#125;&quot; var=&quot;item&quot; varStatus=&quot;vs&quot;&gt;</span><br><span class="line"> $&#123;item &#125;--&gt; $&#123;item.key &#125;--&gt;$&#123;item.value &#125;&lt;br/&gt;</span><br><span class="line"> 遍历状态： $&#123;vs.current &#125;--&gt;$&#123;vs.index &#125;--&gt;$&#123;vs.count &#125;--&gt;$&#123;vs.first &#125;--&gt;$&#123;vs.last &#125;&lt;br/&gt;</span><br><span class="line"> &lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure></p><p>${item }取出kv值，${item.key }只取key，${item.value }只取value。varStatus指定变量名，将遍历状态的对象存到pageContext域中，开始时都会创建一个状态对象，每次遍历都会更新状态值，即当前遍历元素的索引，当前已经遍历了几个元素，当前正在遍历的元素，当前遍历的是不是第一个，是不是最后一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:redirect url=&quot;/jstl01.jsp&quot;&gt;&lt;/c:redirect&gt;</span><br></pre></td></tr></table></figure><p>&lt;c:redirect &gt;&lt;/c:redirect&gt;重定向，绝对路径由服务器解析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是JSP&quot;&gt;&lt;a href=&quot;#什么是JSP&quot; class=&quot;headerlink&quot; title=&quot;什么是JSP&quot;&gt;&lt;/a&gt;什么是JSP&lt;/h2&gt;&lt;p&gt;JSP全称Java Server Pages，指运行在java服务器中的页面，也就是在我们JavaWeb中的
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="http://yoursite.com/2018/07/02/servlet/"/>
    <id>http://yoursite.com/2018/07/02/servlet/</id>
    <published>2018-07-02T11:00:08.000Z</published>
    <updated>2018-08-16T14:20:34.778Z</updated>
    
    <content type="html"><![CDATA[<p>Servlet是一门开发动态web资源的技术。Sun公司在其API中提供了一个Servlet接口，我们写一个实现此接口的类，在类中完成与Dao层交互数据并渲染在页面后返回，将这个类部署到web服务器上，那么当请求访问这个资源时这个类只是处理返回页面的逻辑，隐藏了与dao层交互的相关信息，我们称这个类叫做Servlet。<a id="more"></a><br><img src="http://p94ypeu3q.bkt.clouddn.com/Java程序web后端响应过程.png" alt="Java程序web后端响应过程"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Servlet接口源码</span></span><br><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个接口的实现方法只有五个，但是囊括了初始化，配置信息，服务运行，销毁等整个过程的核心方法。<br>init():第一次访问创建对象后立即调用完成初始化操作,根据初始化的执行顺序，他可以用来获取数据库连接参数、设置共享数据等，它如何获取到参数和设置共享数据的呢，主要与他的形参ServletConfig有关，这个config里面可以getServletName获取servlet的名称，getServletContext获取全局唯一的共享对象ServletContext，getInitParameter获取到web.xml的配置文件中的配置的参数；<br>getServletConfig获取servletConfig对象，这也是一个接口，一会说，他能获取到servletContext对象；<br>service处理业务逻辑的方法；<br>getServletInfo获取servlet信息的方法；<br>destroy是servlet销毁方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface ServletConfig &#123;</span><br><span class="line">    String getServletName();</span><br><span class="line"></span><br><span class="line">    ServletContext getServletContext();</span><br><span class="line"></span><br><span class="line">    String getInitParameter(String var1);</span><br><span class="line"></span><br><span class="line">    Enumeration&lt;String&gt; getInitParameterNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getServletName获取servlet别名；<br>getServletContext获取servlet的共享对象servletContext；<br>getInitParameter获取到配置中的配置信息；<br>getInitParameterNames是一个类似迭代器的接口，用于获取所有的配置文件中的参数名；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Enumeration&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    boolean hasMoreElements();</span><br><span class="line"></span><br><span class="line">    E nextElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void init(ServletConfig servletConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    Enumeration&lt;String&gt; initParameterNames = servletConfig.getInitParameterNames();</span><br><span class="line"></span><br><span class="line">    while (initParameterNames.hasMoreElements())&#123; // 迭代获取项目的配置参数</span><br><span class="line">        System.out.println(&quot;配置参数&quot; + initParameterNames.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p><img src="http://p94ypeu3q.bkt.clouddn.com/servlet请求流程.jpg" alt="servlet请求流程"></p><h2 id="写一个demo"><a href="#写一个demo" class="headerlink" title="写一个demo"></a>写一个demo</h2><p>我们将项目部署在tomcat的web容器里，首先我们需要在项目中导入tomcat的环境。</p><p>然后我们要配置web.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- 配置Servlet --&gt;</span><br><span class="line"> &lt;!--1、Servlet的全类名  --&gt;</span><br><span class="line"> &lt;servlet&gt;</span><br><span class="line"> &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line"> &lt;servlet-class&gt;com.jeff_code.ServletDemo1&lt;/servlet-class&gt;</span><br><span class="line"> &lt;/servlet&gt;</span><br><span class="line">&lt;!--2、配置Servlet的访问路径：给Servlet映射一个虚拟的url访问地址 </span><br><span class="line"> 浏览器不能运行java程序</span><br><span class="line"> 静态页面不能动态的处理请求</span><br><span class="line"> - 映射地址必须以/开头， 后面跟任意的字符串</span><br><span class="line"> - 相当于将Servlet映射的访问路径是：http://localhost:8080/项目名/abc</span><br><span class="line"> 将Servlet映射到了根目录下，可以在项目路径下直接访问，访问时代码由服务器管理执行</span><br><span class="line"> --&gt;</span><br><span class="line"> &lt;!-- 3、在两个Servlet的配置标签中加入一个Servlet-name值，用来将url地址和servlet全类名关联 --&gt;</span><br><span class="line"> &lt;servlet-mapping&gt;</span><br><span class="line"> &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line"> &lt;url-pattern&gt;/abc&lt;/url-pattern&gt;</span><br><span class="line"> &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p><p>/abc是一个虚拟的路径，路径的虚拟地址是在web发布文件夹下的。当用户在浏览器输入<a href="http://localhost:8080/abc" target="_blank" rel="noopener">http://localhost:8080/abc</a><br>时，当前TomCat发布的web文件夹下并没有一个真实存在的abc文件，此时会去web.xml配置文件下找，匹配到一个url-pattern，对应的全类名指定一个Java类com.jeff_code.ServletDemo1，Java会查找有没有这样一个Servlet类实例对象已经生成，如果没有则会调用构造函数和init()方法生成实例对象，根据实例对象调用service方法，然后一直执行service中的逻辑返回给浏览器一个页面（跳转或者转发）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jeff_code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个实现了Servlet的类就叫做Servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo1</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、获取用户的请求信息</span></span><br><span class="line">        System.out.println(<span class="string">"接受到了浏览器的请求。。。。。。"</span>);</span><br><span class="line">        <span class="comment">//2、调用其他类处理请求[处理业务逻辑]</span></span><br><span class="line">        System.out.println(<span class="string">"正在处理请求，调用dao，并渲染出一个html页面"</span>);</span><br><span class="line">        <span class="comment">//3、根据处理结果给用户响应[页面显示响应的内容]</span></span><br><span class="line">        PrintWriter writer = servletResponse.getWriter();</span><br><span class="line">        writer.write(<span class="string">"hello jeff"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Servlet对象是Servlet容器创建的，生命周期方法都是由容器调用的，在很多情景下我们都会自己手动创建类对象或者调用方法，但是在框架中很多情况下都是通过反射的机制生成对象或者是调用方法。</p><p>Servlet对象的创建：<br>默认情况下，Servlet容器第一次收到HTTP请求时创建对应Servlet对象，并且对象是默认是单例的，只创建一次。</p><p>Servlet对象初始化：<br>Servlet容器创建Servlet对象之后，会调用init(ServletConfig config)方法，对其进行初始化。在javax.servlet.Servlet接口中，public void init(ServletConfig config)方法要求容器将ServletConfig的实例对象传入，这也是我们获取ServletConfig的实例对象的根本方法。</p><p>处理请求：<br>在javax.servlet.Servlet接口中，定义了service(ServletRequest req, ServletResponse res)方法处理HTTP请求，同时要求容器将ServletRequest对象和ServletResponse对象传入。</p><p>Servlet对象销毁：<br>服务器重启或服务器停止执行时会销毁Servlet对象，而销毁之前为了执行一些诸如释放缓存、关闭连接、保存数据等操作，所以设计了public void destroy()方法。</p><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><p>作用：每个Servlet都有自己唯一的一个配置对象，服务器在启动时，当用户第一次访问Servlet，服务器调用init方法，服务器会创建此对象将对象传入到init中。<br>获取servlet的别名：<code>config.getServletName();</code>。<br>获取Servlet在配置文件中配置的初始化参数(配置在web.xml配置文件中):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;AServlet1&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;com.jeff.servlet.AServlet&lt;/servlet-class&gt;</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">    &lt;param-name&gt;url&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;jdbc:mysql://localhost:3306/databasename&lt;/param-value&gt;</span><br><span class="line">  &lt;/init-param&gt;</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">    &lt;param-name&gt;user&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;root&lt;/param-value&gt;</span><br><span class="line">  &lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;AServlet1&lt;/servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/AServlet&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">  &lt;param-name&gt;hehe&lt;/param-name&gt;</span><br><span class="line">  &lt;param-value&gt;haha&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure></p><p>可以在Servlet的init()中获取到配置中的参数以及全局共享的ServletContext对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void init(ServletConfig servletConfig) throws ServletException &#123;</span><br><span class="line">    String user = servletConfig.getInitParameter(&quot;user&quot;);</span><br><span class="line">    ServletContext application = servletConfig.getServletContext();</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    System.out.println(application);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Web应用程序中的所有Servlet都共享同一个ServletContext对象，所以ServletContext对象也被称为 application 对象（Web应用程序对象）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">## HttpServlet</span><br><span class="line">HttpServlet继承了GenericServlet，GenericServlet继承了Servlet。调用继承了HttpServlet的类，会根据请求的类型执行doGet或者doPost下的方法，但是doGet绝不是生命周期函数。虽然doGet和doPost不是生命周期方法，但是由于HttpServlet中service方法的层层调用，最终请求肯定会交给doget或doPost处理。</span><br><span class="line">```text</span><br><span class="line">    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        String method = req.getMethod();</span><br><span class="line">        long lastModified;</span><br><span class="line">        if (method.equals(&quot;GET&quot;)) &#123;</span><br><span class="line">            lastModified = this.getLastModified(req);</span><br><span class="line">            if (lastModified == -1L) &#123;</span><br><span class="line">                this.doGet(req, resp);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                long ifModifiedSince;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);</span><br><span class="line">                &#125; catch (IllegalArgumentException var9) &#123;</span><br><span class="line">                    ifModifiedSince = -1L;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (ifModifiedSince &lt; lastModified / 1000L * 1000L) &#123;</span><br><span class="line">                    this.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    this.doGet(req, resp);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    resp.setStatus(304);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (method.equals(&quot;HEAD&quot;)) &#123;</span><br><span class="line">            lastModified = this.getLastModified(req);</span><br><span class="line">            this.maybeSetLastModified(resp, lastModified);</span><br><span class="line">            this.doHead(req, resp);</span><br><span class="line">        &#125; else if (method.equals(&quot;POST&quot;)) &#123;</span><br><span class="line">            this.doPost(req, resp);</span><br><span class="line">        &#125; else if (method.equals(&quot;PUT&quot;)) &#123;</span><br><span class="line">            this.doPut(req, resp);</span><br><span class="line">        &#125; else if (method.equals(&quot;DELETE&quot;)) &#123;</span><br><span class="line">            this.doDelete(req, resp);</span><br><span class="line">        &#125; else if (method.equals(&quot;OPTIONS&quot;)) &#123;</span><br><span class="line">            this.doOptions(req, resp);</span><br><span class="line">        &#125; else if (method.equals(&quot;TRACE&quot;)) &#123;</span><br><span class="line">            this.doTrace(req, resp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);</span><br><span class="line">            Object[] errArgs = new Object[]&#123;method&#125;;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            resp.sendError(501, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>HttpServlet重写了父类的service的方法，可以根据请求的方式调用相应的方法，最后会调用HttpServlet的doGet方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Servlet是一门开发动态web资源的技术。Sun公司在其API中提供了一个Servlet接口，我们写一个实现此接口的类，在类中完成与Dao层交互数据并渲染在页面后返回，将这个类部署到web服务器上，那么当请求访问这个资源时这个类只是处理返回页面的逻辑，隐藏了与dao层交互的相关信息，我们称这个类叫做Servlet。
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>golang的function</title>
    <link href="http://yoursite.com/2018/06/28/golang%E7%9A%84function/"/>
    <id>http://yoursite.com/2018/06/28/golang的function/</id>
    <published>2018-06-28T08:57:17.000Z</published>
    <updated>2018-07-02T07:09:21.918Z</updated>
    
    <content type="html"><![CDATA[<p>函数是Golang的一等公民，golang中大量使用函数式编程，所以理解函数十分有必要。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(形参)</span> 返回值类型</span> &#123;</span><br><span class="line">函数体</span><br><span class="line"><span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是go的函数允许多个返回值，并且在很多情况我们都会返回两个以上的返回值，前面多个是函数功能应该返回的返回值，最后一个返回值则是error的返回值。</p><p>golang的函数func与其他语言的function略有不同，需要讨论一下的就是声明时的函数返回值类型。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"hello jefflike"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个无参无返回值的function，此时我们可以省略返回值类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func test2() int &#123;</span><br><span class="line">return 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a:=test2()</span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure></p><p>当函数有返回值时，声明是必须标明返回值的类型。多个返回值的时候也可以这样写返回值，但是需要使用()将返回值放进去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func test3(a,b,c int) (int,int,int) &#123;</span><br><span class="line">return a,b,c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a,b,c := test3(1,2,3)</span><br><span class="line">fmt.Printf(&quot;a=%d, b=%d, c=%d\n&quot;, a, b, c)</span><br></pre></td></tr></table></figure></p><p>对于多个返回值，golang有一种推荐写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func test4() (a int,b int,c int) &#123;</span><br><span class="line">a = 1</span><br><span class="line">b = 2</span><br><span class="line">c = 3</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a,b,c := test4()</span><br><span class="line">fmt.Printf(&quot;a=%d, b=%d, c=%d\n&quot;, a, b, c)</span><br></pre></td></tr></table></figure></p><p>一般多个返回值时，golang推荐写法是上述的写法。在有返回值的function里必须要返回return。</p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>也叫做函数指针.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 类型别名</span><br><span class="line">// 类型别名的关键字就是一个type</span><br><span class="line">type bigint int64</span><br><span class="line"></span><br><span class="line">var a bigint</span><br><span class="line">fmt.Printf(&quot;a type is %T\n&quot;, a)// a type is main.bigint</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func add(a, b int) int &#123;</span><br><span class="line">return a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(a, b int) int &#123;</span><br><span class="line">return a-b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">// 用别名定义一个匿名的函数，myFunc此时是一个函数类型，代表一个传入两个int参数，返回一个int值的函数类型的统称</span><br><span class="line">type myFunc func(int, int) int</span><br><span class="line">// 定义一个与此函数相同的形参与返回值的函数名</span><br><span class="line">var myFunc1 myFunc</span><br><span class="line">myFunc1 = add</span><br><span class="line">va := myFunc1(3 ,5)</span><br><span class="line">fmt.Println(va)//8</span><br><span class="line"></span><br><span class="line">myFunc1 = min</span><br><span class="line">va = myFunc1(3 ,5)</span><br><span class="line">fmt.Println(va)//-2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个type别名代表一个函数，然后可以像python这样动态语言一样将自定义类型的函数名附上相同的形参与返回值的函数名，加上()就可以直接调用，这两个函数名都具有一样的操作效果。即声明所有myFunc类型，都可以变成一个两个形参一个返回值（都是int类型）的函数来使用。myFunc此时是一个函数类型，代表一个传入两个int参数，返回一个int值的函数类型的统称。</p><h2 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h2><p>作为golang的一等公民，func可以当作实参传递到函数中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func operation(op func(int, int) int,a, b int) int &#123;</span><br><span class="line">//打印出op的值</span><br><span class="line">p := reflect.ValueOf(op).Pointer() // 此时调用的p的指针内容是： 4761920</span><br><span class="line">opName := runtime.FuncForPC(p).Name()//获取到这个指针的ame, 此时调用的p的指针内容是： main.add</span><br><span class="line">fmt.Println(&quot;此时调用的p的指针内容是：&quot;, opName)</span><br><span class="line">return op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func add(m, n int) int &#123;</span><br><span class="line">return m + n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func div(a,b int)(q,r int)&#123;</span><br><span class="line">return a / b, a % b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">v := operation(add, 5, 6)</span><br><span class="line">fmt.Println(v)</span><br><span class="line"></span><br><span class="line">//使用匿名函数，go的lambda就是比较极简</span><br><span class="line">v2 := operation(func(i,j int) int&#123;</span><br><span class="line">return i+j</span><br><span class="line">&#125;, 6, 7)// 此时调用的p的指针内容是： main.main.func1,因为我是一个匿名函数，所以在这里我们叫做func1</span><br><span class="line">fmt.Println(v2)//13</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>func作为实参传递的基础就是函数指针。</p><h2 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一般函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">//函数被调用时a被分配一块内存空间</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span><span class="comment">//初始化的a为0值</span></span><br><span class="line">a++<span class="comment">//a=1</span></span><br><span class="line"><span class="keyword">return</span> a*a<span class="comment">//函数调用完毕，a被释放,下一次还是0值开始</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">biBao</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line"><span class="comment">//闭包函数不关心这些捕获的变量是否超过了作用域，只要闭包还在使用，这些变量就还会存在</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">a++</span><br><span class="line"><span class="keyword">return</span> a * a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(test())<span class="comment">//1</span></span><br><span class="line">fmt.Println(test())<span class="comment">//1</span></span><br><span class="line">fmt.Println(test())<span class="comment">//1</span></span><br><span class="line">f := biBao()</span><br><span class="line">fmt.Println(f())<span class="comment">//1</span></span><br><span class="line">fmt.Println(f())<span class="comment">//4</span></span><br><span class="line">fmt.Println(f())<span class="comment">//9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;函数是Golang的一等公民，golang中大量使用函数式编程，所以理解函数十分有必要。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>&#39;归并排序搭建并行管道&#39;</title>
    <link href="http://yoursite.com/2018/06/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%90%AD%E5%BB%BA%E5%B9%B6%E8%A1%8C%E7%AE%A1%E9%81%93/"/>
    <id>http://yoursite.com/2018/06/27/归并排序搭建并行管道/</id>
    <published>2018-06-27T12:28:04.000Z</published>
    <updated>2018-06-29T12:36:52.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个项目我使用go来完成，在归并排序结果时多个节点之间连线，用Java等面向对象语言来实现就是将节点抽象成对象，通过方法进行互联。与他们相比go实现起来更为自然，节点之间的关系更像是多个goroutine通过管道连接起来的结构，使用go来写代码更为简洁，开发更快。</p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="go的channel"><a href="#go的channel" class="headerlink" title="go的channel"></a>go的channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printhello</span><span class="params">(i <span class="keyword">int</span>, ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">ch &lt;- fmt.Sprintf(<span class="string">"hello world from gorutine %d\n"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">500</span>;i++&#123;</span><br><span class="line"><span class="keyword">go</span> printhello(i, ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg := &lt;- ch</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用管道可以在两个goroutine之间传递信息，这是实现本项目的基础。</p><h3 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h3><p>go自带的排序算法，底层实现是快速排序，我们就使用这个方式。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">43</span>, <span class="number">9</span>, <span class="number">34</span>&#125;</span><br><span class="line">sort.Ints(a)</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a&#123;</span><br><span class="line">fmt.Printf(<span class="string">"第%d个是%d\n"</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是易于实现的，实现归并排序的基础是每一个被归并节点都要是已经排序好了的，我们从个节点的head开始迭代比较，每次可以获得一个当前最小的值pop出来，无限次递归，最终我们获得pop出来的数据就是排序好了的数据，这就是归并排序的思路。</p><h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><p>我们的并行管道可能会处理一个非常大的数据流的排序，这个数据的大小很有可能超出内存的容量，那么我们肯定不能使用sort方法直接把整个数据排序，我们实现的方式是将整个数据流切成k快，每一块都能被内存加载，当然我们可以将每一块都sort排序，然后内存切换加载每一块数据流，归并排序出一个结果，结果自然就是排序好的数据流了。<br>外部排序切分的每一块都组成一个节点：<img src="http://p94ypeu3q.bkt.clouddn.com/外部排序.png" alt="外部排序"><br>将k个节点分别排序后归并排序将数据存放到一个堆数据中：<img src="http://p94ypeu3q.bkt.clouddn.com/节点归并.png" alt="节点归并"><br>外部排序的结构：<img src="http://p94ypeu3q.bkt.clouddn.com/pipeline.png" alt="pipeline">这里每个节点都是多进多出的，无进多出的是source节点，多进无出的是sink节点。<br>节点之间的通信：<img src="http://p94ypeu3q.bkt.clouddn.com/节点之间的通信.png" alt="节点之间的通信">多个节点之间的通信在面向对象中节点抽象成对象，对象之间的影响就是方法的调用，使用go则不需要，每个网络的节点就是一个goroutine，goroutine之间的信息传输使用channel通信。</p><p>整个外部排序项目的结构：<img src="http://p94ypeu3q.bkt.clouddn.com/并行排序项目结构.png" alt="并行排序项目结构"></p><h2 id="实现节点"><a href="#实现节点" class="headerlink" title="实现节点"></a>实现节点</h2><h3 id="基础节点"><a href="#基础节点" class="headerlink" title="基础节点"></a>基础节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 将Array中的数据都存放到channel中,箭头告诉使用此函数只能读取到chan值，只出不进,使用他的人只能从这个管道里拿东西</span><br><span class="line">func ArraySource(arr ...int)  &lt;-  chan int &#123;</span><br><span class="line">out:=make(chan int)</span><br><span class="line">// 因为我们的channel是在goroutine之间传输的通道，所以我们不能自己将自己的arr输送到自己的channel</span><br><span class="line">go func() &#123;</span><br><span class="line">for _,v := range arr&#123;</span><br><span class="line">out &lt;- v</span><br><span class="line">&#125;</span><br><span class="line">// 数据传输完毕，并行计算pipeline中最好是使用close结束表明数据传输已经完成了</span><br><span class="line">close(out)</span><br><span class="line">&#125;()</span><br><span class="line">return out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个源节点，此节点的作用就是将读取到的值存放到一个管道中返回，调用这个节点就可以一直取到值直到管道传递完成close。因为我们节点间数据交换是goroutine和goroutine的交互，所以这里我们读到源数据后选择在goroutine中func处理数据。这里我们开启一个goroutine就将管道return回去了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 数据排序</span><br><span class="line">func IntMemorySort(in &lt;- chan int) &lt;- chan int  &#123;</span><br><span class="line">out := make(chan int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">// 将数据加载到内存</span><br><span class="line">arr := []int&#123;&#125;</span><br><span class="line">for v:= range in  &#123;</span><br><span class="line">arr = append(arr,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 快速排序</span><br><span class="line">sort.Ints(arr)</span><br><span class="line"></span><br><span class="line">// 排序后加载到管道中</span><br><span class="line">for _,v := range arr &#123;</span><br><span class="line">out &lt;- v</span><br><span class="line">&#125;</span><br><span class="line">close(out)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">return out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用排序管道进行排序</span><br><span class="line">func main() &#123;</span><br><span class="line">p := pipeline.IntMemorySort(pipeline.ArraySource(3,6,8,2,5))</span><br><span class="line"></span><br><span class="line">for v := range p&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里IntMemorySort的goroutine一直在从管道中读数据，排序，main中遍历的p管道一直在读，如果上面的goroutine排序时卡顿，那么p管道的读取也会等待上一层goroutine排序完成继续读取值。在golang中我们不需要使用lock机制控制等待，等待的内容是Go语言底层做的。</p><h3 id="归并节点"><a href="#归并节点" class="headerlink" title="归并节点"></a>归并节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序</span><br><span class="line">func Merge(in1, in2 &lt;- chan int) &lt;- chan int &#123;</span><br><span class="line">out := make(chan int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">v1, ok1 := &lt;- in1</span><br><span class="line">v2, ok2 := &lt;- in2</span><br><span class="line">// in1，in2中有一个还有值循环就要做下去</span><br><span class="line">for ok1 || ok2&#123;</span><br><span class="line">// in2的管道已经空了或者in1的头小于in2的头就将in1的头加入到队列管道中</span><br><span class="line">&#125;</span><br><span class="line">if !ok2 ||(ok1 &amp;&amp; v1&lt;=v2)&#123;</span><br><span class="line">out &lt;- v1</span><br><span class="line">// 取下一个管道内的值，迭代的效果</span><br><span class="line">v1,ok1 = &lt;- in1</span><br><span class="line">&#125;else &#123;</span><br><span class="line">out &lt;- v2</span><br><span class="line">v2, ok2 = &lt;- in2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(out)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">return out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并参数是多个channel(我们这里是两个)，归并排序之前的两个管道的数据一定是已经排序好了的，有goroutine我们实现起来非常的简单，因为我们什么都没做，他已经是排序好的两个管道值才会被归并。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这个项目我使用go来完成，在归并排序结果时多个节点之间连线，用Java等面向对象语言来实现就是将节点抽象成对象，通过方法进行互联。与他们相比
      
    
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Java数据库操作</title>
    <link href="http://yoursite.com/2018/06/22/JDBC/"/>
    <id>http://yoursite.com/2018/06/22/JDBC/</id>
    <published>2018-06-22T10:46:33.000Z</published>
    <updated>2018-06-23T06:47:49.223Z</updated>
    
    <content type="html"><![CDATA[<p>JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统（DBMS），通用的SQL数据库存取和操作的公共接口。忽略底层的东西，用相同的API操作，更加规范化，JDBC的数据库操作方式还是原生数据库，不是ORM。<br><img src="http://p94ypeu3q.bkt.clouddn.com/JDBC.png" alt="JDBC"></p><p>JDBC访问数据库的流程<br><img src="http://p94ypeu3q.bkt.clouddn.com/流程.bmp" alt="流程"></p><h3 id="导入数据库jar包"><a href="#导入数据库jar包" class="headerlink" title="导入数据库jar包"></a>导入数据库jar包</h3><p>要使用JDBC连接数据库，那么首先需要一个连接数据库的驱动。相关的驱动可以在相应的数据库提供商的官网下载jar包，导入使用。</p><h3 id="获取数据库的连接"><a href="#获取数据库的连接" class="headerlink" title="获取数据库的连接"></a>获取数据库的连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 注册驱动</span><br><span class="line">Class c = Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">System.out.println(c);// class com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">// 获取连接</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/0508db&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;root&quot;;</span><br><span class="line"></span><br><span class="line">// 驱动加载到内存后，由DriverManager管理, 获取JDBC链接</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">System.out.println(conn); // com.mysql.jdbc.JDBC4Connection@42110406</span><br></pre></td></tr></table></figure><h3 id="Statement操作数据库"><a href="#Statement操作数据库" class="headerlink" title="Statement操作数据库"></a>Statement操作数据库</h3><h4 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Statement s = conn.createStatement();</span><br><span class="line">String sql = &quot;select * from dept&quot;;</span><br><span class="line">ResultSet res = s.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">while (res.next())&#123;</span><br><span class="line">int id = res.getInt(&quot;did&quot;);</span><br><span class="line">String name = res.getString(&quot;dname&quot;);</span><br><span class="line">System.out.println(id + &quot;\t&quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h4 id="增加，修改，-删除数据"><a href="#增加，修改，-删除数据" class="headerlink" title="增加，修改， 删除数据"></a>增加，修改， 删除数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;INSERT INTO dept VALUES(7,&apos;ff&apos;)&quot;;</span><br><span class="line">// String sql = &quot;update dept set dname = &apos;测试部门&apos; where did = 7&quot;;</span><br><span class="line">// String sql = &quot;delete from dept where did = 7&quot;;</span><br><span class="line"></span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">int len = st.executeUpdate(sql);</span><br><span class="line">if(len&gt;0)&#123;</span><br><span class="line">System.out.println(&quot;添加成功&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;添加失败&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改数据都是一类操作语句，修改一下sql语句即可。</p><h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><p>Statement存在三个问题：</p><ol><li>sql语句的拼接过于繁琐，比如查询语句的过滤条件是手动输入的，sql语句就要写成这样：<code>INSERT INTO users VALUES(NULL,&#39;&quot;+ username +&quot;&#39;,&#39;&quot; +password + &quot;&#39;,&#39;&quot; +email+&quot;&#39;)</code>,各种引号的嵌套，不利于查看。</li><li>不能防止sql注入的问题；</li><li>无法处理Blob等二进制类型的数据；</li></ol><p>所以一般我们开发会使用PreparedStatement类进行数据库相关的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// (1)获取连接</span><br><span class="line">Connection conn = JDBCTools.getConnection();</span><br><span class="line"></span><br><span class="line">//(2)编写特殊的SQL</span><br><span class="line">String sql = &quot;INSERT INTO users VALUES(NULL,?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">//(3)获取PreparedStatement</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql);//对带？的sql进行预编译，有三个？，代表有三个值需要传入</span><br><span class="line"></span><br><span class="line">//(4)设置?对应的值</span><br><span class="line">pst.setString(1, username);</span><br><span class="line">pst.setString(2, password);</span><br><span class="line">pst.setString(3, email);</span><br><span class="line"></span><br><span class="line">//(5)执行sql</span><br><span class="line">int len = pst.executeUpdate();//此处不需要再传入sql了，sql里面有三个预编译的？</span><br><span class="line">System.out.println(len&gt;0?&quot;成功&quot;:&quot;失败&quot;);</span><br></pre></td></tr></table></figure></p><p>读取数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//(1)获取连接</span><br><span class="line">Connection conn = JDBCTools.getConnection();</span><br><span class="line"></span><br><span class="line">//(2)编写SQL</span><br><span class="line">String sql = &quot;SELECT id,username,`password`,email FROM users WHERE username= ? AND `password` = ?&quot;;</span><br><span class="line"></span><br><span class="line">//(3)创建PreparedStatement</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">//(4)设置？的值</span><br><span class="line">pst.setString(1, username);</span><br><span class="line">pst.setString(2, password);</span><br><span class="line"></span><br><span class="line">//(5)执行SQL</span><br><span class="line">ResultSet rs = pst.executeQuery();//不能再传Sql，不然？又回去了</span><br><span class="line">while(rs.next())&#123;</span><br><span class="line">int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">String u = rs.getString(&quot;username&quot;);</span><br><span class="line">String p = rs.getString(&quot;password&quot;);</span><br><span class="line">String e = rs.getString(&quot;email&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(id+&quot;\t&quot; + u + &quot;\t&quot; + p + &quot;\t&quot; + e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//(5)释放资源</span><br><span class="line">JDBCTools.freeQuietly(rs, pst, conn);</span><br></pre></td></tr></table></figure></p><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">User user = new User(0,&quot;jeff&quot;,&quot;123&quot;,&quot;jeff@123.com&quot;);//可以从键盘输入，也可以从web页面...</span><br><span class="line"></span><br><span class="line">//对象存储到数据库中：O-&gt;R</span><br><span class="line"></span><br><span class="line">//1、获取连接</span><br><span class="line">Connection conn = JDBCTools.getConnection();</span><br><span class="line"></span><br><span class="line">//2、编写sql</span><br><span class="line">String sql = &quot;INSERT INTO users VALUES(NULL,?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">//3、获取PreparedStatement</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">//4、设置？</span><br><span class="line">pst.setString(1, user.getUsername());</span><br><span class="line">pst.setString(2, user.getPassword());</span><br><span class="line">pst.setString(3, user.getEmail());</span><br><span class="line"></span><br><span class="line">//5、执行</span><br><span class="line">int len = pst.executeUpdate();</span><br><span class="line">System.out.println(len&gt;0?&quot;成功&quot;:&quot;失败&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//关系数据库中的数据--&gt;对象   R-&gt;O</span><br><span class="line"></span><br><span class="line">//1、获取连接</span><br><span class="line">Connection conn = JDBCTools.getConnection();</span><br><span class="line"></span><br><span class="line">//2、编写sql</span><br><span class="line">String sql = &quot;SELECT id,username,`password`,email FROM users&quot;;</span><br><span class="line"></span><br><span class="line">//3、获取PreparedStatement</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">//4、设置？，不需要，因为没有？</span><br><span class="line"></span><br><span class="line">//5、执行</span><br><span class="line">ResultSet rs = pst.executeQuery();</span><br><span class="line">ArrayList&lt;User&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">while(rs.next())&#123;</span><br><span class="line">//读取一行</span><br><span class="line">int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">String username = rs.getString(&quot;username&quot;);</span><br><span class="line">String password = rs.getString(&quot;password&quot;);</span><br><span class="line">String email = rs.getString(&quot;email&quot;);</span><br><span class="line"></span><br><span class="line">//封装为一个对象</span><br><span class="line">User u = new User(id,username,password,email);</span><br><span class="line"></span><br><span class="line">//添加到集合</span><br><span class="line">list.add(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//6、遍历集合</span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="插入数据获取数据的属性"><a href="#插入数据获取数据的属性" class="headerlink" title="插入数据获取数据的属性"></a>插入数据获取数据的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// (1)获取连接</span><br><span class="line">Connection conn = JDBCTools.getConnection();</span><br><span class="line"></span><br><span class="line">//(2)编写特殊的SQL</span><br><span class="line">String sql = &quot;INSERT INTO users VALUES(NULL,?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">//(3)获取PreparedStatement</span><br><span class="line">//如果需要执行完添加的sql后，想要返回自增长的键值，那么需要制定Statement.RETURN_GENERATED_KEYS </span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS );//对带？的sql进行预编译，有三个？，代表有三个值需要传入</span><br><span class="line"></span><br><span class="line">//(4)设置?对应的值</span><br><span class="line">pst.setString(1, username);</span><br><span class="line">pst.setString(2, password);</span><br><span class="line">pst.setString(3, email);</span><br><span class="line"></span><br><span class="line">//(5)执行sql</span><br><span class="line">int len = pst.executeUpdate();//不能再传Sql，不然？又回去了</span><br><span class="line">System.out.println(len&gt;0?&quot;成功&quot;:&quot;失败&quot;);</span><br><span class="line"></span><br><span class="line">//获取自增长的键值</span><br><span class="line">ResultSet rs = pst.getGeneratedKeys();</span><br><span class="line">if(rs.next())&#123;</span><br><span class="line">System.out.println(&quot;用户编号是：&quot; + rs.getInt(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//1、模拟批量插入10000个用户信息</span><br><span class="line">//1、获取连接</span><br><span class="line">Connection conn = JDBCTools.getConnection();</span><br><span class="line"></span><br><span class="line">//(2)编写特殊的SQL</span><br><span class="line">String sql = &quot;INSERT INTO users VALUES(NULL,?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">//(3)获取PreparedStatement</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql);//对带？的sql进行预编译，有三个？，代表有三个值需要传入</span><br><span class="line"></span><br><span class="line">//(4)设置？的值，并且执行</span><br><span class="line">for(int i=1;i&lt;=10000; i++)&#123;</span><br><span class="line">String username = &quot;测试用户名&quot;+i;</span><br><span class="line">pst.setString(1, username);</span><br><span class="line">pst.setString(2, &quot;123456&quot;);</span><br><span class="line">pst.setString(3, username +&quot;@123.com&quot;);</span><br><span class="line"></span><br><span class="line">//先添加到批处理中，先攒着</span><br><span class="line">pst.addBatch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最后执行批处理</span><br><span class="line">pst.executeBatch();</span><br><span class="line"></span><br><span class="line">//(6)释放资源</span><br><span class="line">JDBCTools.freeQuietly(pst, conn);//因为PreparedStatement是Statement的子接口，多态参数</span><br><span class="line"></span><br><span class="line">long end = System.currentTimeMillis();</span><br></pre></td></tr></table></figure><h3 id="支持事物"><a href="#支持事物" class="headerlink" title="支持事物"></a>支持事物</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//1、获取连接</span><br><span class="line">Connection conn = JDBCTools.getConnection();</span><br><span class="line"></span><br><span class="line">//设置连接为手动提交模式</span><br><span class="line">conn.setAutoCommit(false);</span><br><span class="line"></span><br><span class="line">//2、编写特殊的sql</span><br><span class="line">String sql = &quot;UPDATE users SET PASSWORD = ? WHERE username = ?&quot;;</span><br><span class="line"></span><br><span class="line">//3、创建PreparedStatement</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">//第一个</span><br><span class="line">pst.setString(1, &quot;123&quot;);</span><br><span class="line">pst.setString(2, &quot;chai&quot;);</span><br><span class="line"></span><br><span class="line">boolean flag = true;//假设成功</span><br><span class="line"></span><br><span class="line">int len = pst.executeUpdate();</span><br><span class="line">System.out.println(len&gt;0?&quot;成功&quot;:&quot;失败&quot;);</span><br><span class="line">flag  =  flag &amp; (len&gt;0);</span><br><span class="line"></span><br><span class="line">//第二个</span><br><span class="line">pst.setString(1, &quot;123&quot;);</span><br><span class="line">pst.setString(2, &quot;lin&quot;);//故意制造错误</span><br><span class="line"></span><br><span class="line">len = pst.executeUpdate();</span><br><span class="line">System.out.println(len&gt;0?&quot;成功&quot;:&quot;失败&quot;);</span><br><span class="line"></span><br><span class="line">flag  =  flag &amp; (len&gt;0);</span><br><span class="line"></span><br><span class="line">if(flag)&#123;</span><br><span class="line">conn.commit();//提交事务</span><br><span class="line">&#125;else&#123;</span><br><span class="line">conn.rollback();//回滚</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//还原自动提交模式</span><br><span class="line">conn.setAutoCommit(true);</span><br></pre></td></tr></table></figure><h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD，而不包含任何业务相关的信息。作用：为了实现功能的模块化，更有利于代码的维护和升级。</p><p>我们自己也可以实现一个DAO，DAO的本质与我们上面操作PreparedStatement进行增删改查类似，只是将操作的细节封装成方法，预编译？作为参数传入方法，所以实质就是将增删改查封装成API提供给我们操作。</p><p>抽取BaseDAO的时候，查询的BaeDAO对于查询数据返回值的类型是不确定的，所以怎么将查询结果封装成对象返回显示，需要使用到反射读取子类传给父类时的泛型实参，从而生成实例对象并且读取显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">private Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">public BaseDAO()&#123;</span><br><span class="line">Class&lt;? extends BaseDAO&gt; c = this.getClass();</span><br><span class="line">Type t = c.getGenericSuperclass();</span><br><span class="line">ParameterizedType p = (ParameterizedType) t;</span><br><span class="line">Type[] arr = p.getActualTypeArguments();</span><br><span class="line">type= (Class) arr[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通用的查询多个对象的方法</span><br><span class="line">public List&lt;T&gt; getList(String sql, Object... args)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">//1、获取连接</span><br><span class="line">Connection conn = JDBCTools.getConnection();</span><br><span class="line"></span><br><span class="line">//3、创建PreparedStatement</span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">//4、设置？</span><br><span class="line">for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">pst.setObject(i+1, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ResultSet rs = pst.executeQuery();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ResultSetMetaData metaData = rs.getMetaData();//结果集的元数据</span><br><span class="line">/*</span><br><span class="line"> * #结果集的元数据，结果有3列，列名称分别是id,title,author</span><br><span class="line">SELECT id,title,author FROM books WHERE id &lt;5;;</span><br><span class="line"></span><br><span class="line">SELECT id, title,author,price,sales,stock,img_path AS imgPath FROM books</span><br><span class="line">当属性名（类）与字段名（表）不一致时，可以通过取别名，告知结果集我类的属性名是什么</span><br><span class="line"> */</span><br><span class="line">//一共有几列</span><br><span class="line">int count = metaData.getColumnCount(); </span><br><span class="line"></span><br><span class="line">ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">while(rs.next())&#123;//很多行，很多个对象</span><br><span class="line">//一行，代表一个对象</span><br><span class="line">//循环一次，代表一行</span><br><span class="line">T t  = type.newInstance();</span><br><span class="line"></span><br><span class="line">//每一个对象又有很多列，即很多个属性需要设置</span><br><span class="line">for(int i=0; i&lt;count; i++)&#123;//n个属性</span><br><span class="line">//获取第几列的名称</span><br><span class="line">//String columnLabel = metaData.getColumnName(i+1);//只能得到列名</span><br><span class="line">//getColumnLabel如果没有别名就获取列名称，如果有别名就获取别名</span><br><span class="line">String columnLabel = metaData.getColumnLabel(i+1);//可以得到列的别名</span><br><span class="line"></span><br><span class="line">//根据列名称，获取值</span><br><span class="line">Object value = rs.getObject(columnLabel);</span><br><span class="line"></span><br><span class="line">//设置对象的属性值</span><br><span class="line">//(1)获取属性对象Field</span><br><span class="line">//Field f = type.getDeclaredField(属性名);</span><br><span class="line">Field f = type.getDeclaredField(columnLabel);</span><br><span class="line">//(2)调用Field对象的setAccessible(true)</span><br><span class="line">f.setAccessible(true);</span><br><span class="line">//(3)调用Field对象的set方法，设置属性值</span><br><span class="line">//f.set(t, 属性值);</span><br><span class="line">f.set(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.add(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JDBCTools.freeQuietly(rs, pst, conn);</span><br><span class="line"></span><br><span class="line">return list;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意事项：</p><ol><li>因为传递的参数个数是不确定个数，类型也是不确定类型，所以接收的形参是Object… args；</li><li>getMetaData获取query的结果集，元数据就是表中列的名称或者别名，存入到Object需要与类型的属性名一致；</li><li>元数据getColumnCount获取到查询的数据的条数；</li><li>生成一个当前对象type的实例，然后生成查询到行数个对象进行赋值操作；</li><li>getColumnLabel获取元数据的别名，因为通用性不确定当前列的的数据类型，所以使用getObject。<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3>数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。</li></ol><p>数据库连接池技术的优点：</p><ol><li>资源重用：由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</li><li>更快的系统反应速度：数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间。</li><li>新的资源分配手段：对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源。</li><li>统一的连接管理，避免数据库连接泄露：在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露。</li></ol><p>数据连接池的种类有很多，</p><ol><li>DBCP 是Apache提供的数据库连接池，速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持；</li><li>C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以；</li><li>Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点；</li><li>BoneCP 是一个开源组织提供的数据库连接池，速度快；</li><li>Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不知道是否有BoneCP快。</li></ol><p>Druid是现在普遍使用的数据库连接池，它的有点比较多，所以我一般都会使用它。<br>Druid的连接池使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//1、创建连接池</span><br><span class="line">DruidDataSource ds = new DruidDataSource();</span><br><span class="line"></span><br><span class="line">//2、基本参数</span><br><span class="line">ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">ds.setUrl(&quot;jdbc:mysql://localhost:3306/bookstore&quot;);//bookstore库名，SQL中是表名称</span><br><span class="line">ds.setUsername(&quot;root&quot;);</span><br><span class="line">ds.setPassword(&quot;root&quot;);</span><br><span class="line"></span><br><span class="line">ds.setInitialSize(10);</span><br><span class="line">ds.setMaxActive(20);</span><br><span class="line">ds.setMinIdle(5);</span><br><span class="line">ds.setMaxWait(5000);</span><br><span class="line"></span><br><span class="line">//4、获取连接</span><br><span class="line">for(int i=1; i&lt;=30; i++)&#123;</span><br><span class="line">Connection conn = ds.getConnection();</span><br><span class="line">System.out.println(&quot;第&quot; + i + &quot;个连接：&quot; +  conn);</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure></p><p>将信息写入配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties pro = new Properties();</span><br><span class="line">pro.load(TestDruid2.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));</span><br><span class="line">DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"></span><br><span class="line">for (int i = 1; i &lt;= 30; i++) &#123;</span><br><span class="line">Connection conn = ds.getConnection();</span><br><span class="line">System.out.println(&quot;第&quot; + i + &quot;个连接：&quot; + conn);</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>附c3p0的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ComboPooledDataSource ds = new ComboPooledDataSource();</span><br><span class="line"></span><br><span class="line">ds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">ds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/bookstore&quot;);</span><br><span class="line">ds.setUser(&quot;root&quot;);</span><br><span class="line">ds.setPassword(&quot;123456&quot;);</span><br><span class="line"></span><br><span class="line">ds.setInitialPoolSize(10);</span><br><span class="line">ds.setMinPoolSize(5);</span><br><span class="line">ds.setMaxPoolSize(20);</span><br></pre></td></tr></table></figure></p><h3 id="Apache-DBUtils"><a href="#Apache-DBUtils" class="headerlink" title="Apache-DBUtils"></a>Apache-DBUtils</h3><p>Commons-DBUtils是Apache组织提供的一个开源JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用DBUtils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p><p>DbUtils：提供如关闭连接、释放资源、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void close(…) throws java.sql.SQLException：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</span><br><span class="line">public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</span><br><span class="line">public static void commitAndClose(Connection conn)throws SQLException 用来提交连接的事务，然后关闭连接</span><br><span class="line">public static void commitAndCloseQuietly(Connection conn)： 用来提交连接的事务，然后关闭连接，并且在关闭连接时不抛出SQL异常。</span><br><span class="line">public static void rollback(Connection conn)throws SQLException允许conn为null，因为方法内部做了判断</span><br><span class="line">public static void rollbackAndClose(Connection conn)throws SQLException</span><br><span class="line">rollbackAndCloseQuietly(Connection)</span><br><span class="line">public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</span><br></pre></td></tr></table></figure></p><p>QueryRunner：实现更新（增、删、改、批处理）封装了SQL的执行，是线程安全的。<br>QueryRunner的优点：<br>（1）可以实现增、删、改、查、批处理；<br>（2）考虑了事务处理需要共用Connection；<br>（3）该类最主要的就是简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</p><p>不考虑事务而且QueryRunner对象创建时指定数据源，这样在QueryRunner的所有增删改查方法中都会从数据源中自己获取连接。如果有事务，必须传递Connection对象，因为同一个事务的多条语句必须在一个Connection连接中完成。<br>查询所有，不需要传参<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;SELECT id,title,author,price,sales,stock,img_path AS imgPath FROM books&quot;;</span><br><span class="line">List&lt;Book&gt; list = qr.query(JDBCTools.getConnection(), sql, new BeanListHandler&lt;Book&gt;(Book.class));</span><br></pre></td></tr></table></figure></p><p>需要传递参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;SELECT id,title,author,price,sales,stock,img_path AS imgPath FROM books where id = ?&quot;;</span><br><span class="line">Book book = qr.query(JDBCTools.getConnection(), sql, new BeanHandler&lt;Book&gt;(Book.class),1);</span><br></pre></td></tr></table></figure></p><p>查询单值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;SELECT COUNT(*) FROM books&quot;;</span><br><span class="line">Long count = qr.query(JDBCTools.getConnection(), sql, new ScalarHandler&lt;Long&gt;());</span><br></pre></td></tr></table></figure></p><p>查询分组（Map）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;SELECT did,AVG(salary),MAX(salary) FROM t_employee WHERE did =? GROUP BY did&quot;;</span><br><span class="line">Map&lt;String, Object&gt; map = qr.query(JDBCTools.getConnection(), sql, new MapHandler(), 1);</span><br></pre></td></tr></table></figure></p><p>嵌套的查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;SELECT did,AVG(salary),MAX(salary) FROM t_employee GROUP BY did&quot;;</span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; query = qr.query(JDBCTools.getConnection(), sql, new MapListHandler());</span><br></pre></td></tr></table></figure></p><p>更新，修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;UPDATE users SET `password` = ? WHERE username = ?&quot;;</span><br><span class="line">int len = qr.update(JDBCTools.getConnection(), sql, &quot;123456&quot;, &quot;jeff&quot;);</span><br></pre></td></tr></table></figure></p><p>删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;DELETE FROM users WHERE username = ?&quot;;</span><br><span class="line">int len = qr.update(JDBCTools.getConnection(), sql, &quot;jeff&quot;);</span><br></pre></td></tr></table></figure></p><p>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;INSERT INTO users VALUES(NULL,?,?,?)&quot;;</span><br><span class="line">int len = qr.update(JDBCTools.getConnection(), sql, &quot;jeff&quot;,&quot;123&quot;,&quot;jeff@123.com&quot;);</span><br></pre></td></tr></table></figure></p><p>增加并获取主键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;INSERT INTO users VALUES(NULL,?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">//因为JDBC底层，preparedStatement执行完了后，调用getGeneratedKeys()返回的是ResultSet结果</span><br><span class="line">//所以这里仍然要指定这个结果集如何处理：ResultSetHandler</span><br><span class="line">//这个自增长的键值是一个整数值，用ScalarHandler处理</span><br><span class="line">Long id = qr.insert(JDBCTools.getConnection(), sql, new ScalarHandler&lt;Long&gt;(), &quot;jeff&quot;,&quot;123&quot;,&quot;jeff@123.com&quot;);</span><br></pre></td></tr></table></figure></p><p>Apache提供了很多Java类供Java程序员使用，合理的查看文档可以做到事半功倍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统（DBMS），通用的SQL数据库存取和操作的公共接口。忽略底层的东西，用相同的API操作，更加规范化，JDBC的数据库操作方式还是原生数据库，不是ORM。&lt;br&gt;&lt;img src=
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一梦十年</title>
    <link href="http://yoursite.com/2018/06/17/180617%E6%89%8B%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/17/180617手记/</id>
    <published>2018-06-17T04:20:45.000Z</published>
    <updated>2018-06-24T11:46:37.391Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;随笔&gt;<br>&lt;自己写来玩的，留给自己日后翻阅，多年后看来可能又别有一番风味，我的成长记忆没有什么图片，都只有一些奇奇怪怪的文字，我些东西的文风怪怪的，思路跳跃也是极大，别人阅读可能会引起不适，在此道歉，语文没学好不怨老师，这里向老师道歉，最后极度不推荐偶然来访的朋友阅读Life分类的文章。&gt;<br>昨天看世界杯的时候，晃眼看成了2008年奥运会，乍以为是电视转播出了问题，定睛一看原来已是2018。嘲笑过一梦三四年的标题党，原来只是不自知罢了。</p><p>说到2008，又会想到那个夏天，大雪，地震，台风，奥运会的一年，也是我青春里最美好的年岁，那几年学的是九年义务教育，课余读的是水浒西游，都是些国内国外的名著，读书也算刻苦，有过梦想，还觉得自己会成为什么了不起的人物。总的来说，照着发展下去，也许不是什么了不起的人但是也绝不会如我现在这般困窘。年少的梦与想啊，被时间沧桑。</p><p>别的不说，九年的义务教育我完成的还是极好的。呵，全无用处。读高中时，接触到互联网，玩着大三亿，看的是神墓，星辰变，辰东，唐三与番茄之流。流行快餐文化是灵魂的海洛因。这也是我绝不会使用抖音，快手等APP的原因，辣鸡微信公众号的断章取义毒害的是中华民族的青年们。不幸的是我get到了当时盛行的“读书无用”理论，很多时候人都只能听到自己想要听到的东西，对于独立意识模糊，自主意识不健全的青少年来说，我的思想已经中毒了。直至此刻，娱乐至上已经全民化，辣鸡影视作品在侵蚀我们的下一代，那些年我读过的辣鸡文学，这几年被升级成了各种电视剧，电影。我看到的是腐蚀了我的民族。</p><p>“为中华崛起而编程”我不是随便说说，我知道我一个写web的菜鸡我没资格上升到中华民族的高度，我是青年一代，但是我代表不了民族希望，代表希望的是那些现在看爱情公寓，三生三世的00后，彼时我也将它们视为神作，此时只有鄙夷和不屑。他们能扛得住人口老龄化的中国吗，掏空了六个钱包，它们是不是如同香港和日本的青年亦或是更差？</p><p>四年lol，一朝入社会。方鸿渐留洋三年，花的是老丈人的钱，拿回来是应付的一纸文凭，浪费着大好的时光，却无半点才学。我同他别无两样，有的是一文不值的傲，能与苏文纨，赵辛楣交好，自觉高人一等的错觉，说来实在羞耻。于我而言，刘是同赵辛楣相似的人，在妥协于生活之前，把我拖出来，我现在即使过的不如16年轻松，但是至少不是little hunger，我自觉算得上是great hunger。</p><p>编程给我带来的绝对不是coding，加班，我觉得这段生活经历它拯救了我的灵魂，至少我觉得向我这样受过教育的青年都只想着安逸，不学习，不思考，不进取，给我们背负重担的那些人总有一天会被我这根稻草压垮。我们社会的重担是压在少数人的身上的，敢于承担，富有拼搏的人在为我们扛起整个国家，有政客，有科研人员，有商人，各个角落。与他们一样，也有坐吃山空，游山玩水，好逸恶劳，逃税漏税，但更多的是吃吃喝喝，网络毒舌，娱乐至死的家长里短。于我个人，我知道我读个书，对社会影响力为0，我不是明星，我没有粉丝，我没有流量，我不会说好听的话，so bad，我做这些只是让我和家人能过的好一些，从我辞职到现在快一年了，家人的鼓励与陪伴是我最大的动力。我曾觉得自己冷血无情，可能只是那时年少吧。父母给了我很多，我放弃自己的同时也在放弃他们。</p><p>我总是后知后觉，该学习的时候，我在读网络文学，该恋爱的年纪我在lol，该工作的年纪我开始想学习了，我想下一步该结婚的年纪我应当事业刚起步。但是那又怎样呢，我至少还没放弃，有时候我看到那些三四十岁被生活摧残的老哥踏上IT不归路，想一想如果我今日不上车，他会不会就是我的明天。我今年26岁，梦醒了，我开始考虑自己的人生，生活不止眼前的苟且，还有很多的苟且在后面接踵而至，但是为了生活，为了父母，为了以后可能遇到的人，为了自己现阶段，写Java，写python，写golang，写web。我可能活不了很久，但是人生苦短，何妨一试。至少我现在听音乐+coding的时候，我觉得自己是神。哪怕我在写hello world。如果没有爱人和婚姻，我怕是要写一辈子代码了。提前送自己一首凉凉。</p><p>“勇敢，自信，责任，担当，不做绝大多数，为中华崛起而编程!”<br>2018.06.17 北京市丰台区六里桥东随笔</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;lt;随笔&amp;gt;&lt;br&gt;&amp;lt;自己写来玩的，留给自己日后翻阅，多年后看来可能又别有一番风味，我的成长记忆没有什么图片，都只有一些奇奇怪怪的文字，我些东西的文风怪怪的，思路跳跃也是极大，别人阅读可能会引起不适，在此道歉，语文没学好不怨老师，这里向老师道歉，最后极度不推荐
      
    
    </summary>
    
      <category term="Life" scheme="http://yoursite.com/categories/Life/"/>
    
    
      <category term="Life" scheme="http://yoursite.com/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>泛型</title>
    <link href="http://yoursite.com/2018/06/14/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/06/14/泛型/</id>
    <published>2018-06-14T11:05:17.000Z</published>
    <updated>2018-06-26T02:21:35.542Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p>集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把存储元素类型设计为Object，JDK1.5之后使用泛型来解决。存放元素时除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection<e>，List<e>，ArrayList<e>   这个<e>就是类型参数，即泛型。在声明阶段定义一个标签，当此标签被传入泛型实参后，容器里存放怎样的数据就定格了。</e></e></e></e></p><p>从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List<string>，这表明该List只能保存字符串类型的对象。</string></p><h3 id="为什么使用泛型"><a href="#为什么使用泛型" class="headerlink" title="为什么使用泛型"></a>为什么使用泛型</h3><p>使用泛型优于Object是因为在Object读取类型对象的时候需要进行类型强转，这个过程可能会发生类型转换异常。但是使用泛型不需要进行类型转换，减少了类型异常的风险。同时Object可以接受Java的任意对象，这使得集合中的元素具有不同类型的风险，但是泛型只有指定的元素可以存放至集合，集合元素类型更安全。</p><p>简单的来说，泛型就是为了解决声明阶段不能确定元素类型，但在使用阶段可以确定类型的情况。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 未使用泛型的集合，管理混乱</span></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="string">"jeff"</span>);</span><br><span class="line">        list.add(<span class="number">3.14</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码未使用泛型，集合里存入数据具有不确定性，什么类型都可以存，这使得数据读取变得麻烦.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 未使用泛型的集合，管理混乱</span></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="string">"jeff"</span>);</span><br><span class="line">        list.add(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a =(<span class="keyword">int</span>)list.get(<span class="number">0</span>);<span class="comment">// 强转时注意不要转错了，这也是缺点之一，转型错误编译时也不会报错</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        String b =(String) list.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="keyword">double</span> c = (<span class="keyword">double</span>) list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也许强制类型转换可以解决这个问题，但是迭代遍历可没有这么方便了。而且这样操作实在麻烦。此时没有标明泛型，则编译的时候按照泛型擦除的状态进行操作，类似于Object类型存储。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        // 使用泛型后</span><br><span class="line">        ArrayList&lt;Integer&gt; list= new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(2);</span><br><span class="line">//        list.add(&quot;string&quot;);//不同的类型在编译阶段就会报错</span><br><span class="line">//        list.add(3.14);</span><br></pre></td></tr></table></figure></p><p>注意：（1）泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object；<br>      （2）泛型实参不能指定为基本数据类型。</p><h3 id="泛型分类"><a href="#泛型分类" class="headerlink" title="泛型分类"></a>泛型分类</h3><h4 id="泛型类-泛型接口"><a href="#泛型类-泛型接口" class="headerlink" title="泛型类/泛型接口"></a>泛型类/泛型接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】  class/interface 类名/接口名&lt;泛型形参列表&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><p>泛型类上定义的泛型形参在类中可以当作数据类型使用。可以使用在:</p><ol><li>属性；</li><li>方法；</li><li>方法的返回值类型；</li></ol><p>自定义一个泛型类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> T score;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, T score)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(T score)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"姓名："</span> + name + <span class="string">", 成绩："</span> + score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStudentScore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Student&lt;Integer&gt; s1 = <span class="keyword">new</span> Student&lt;Integer&gt;(<span class="string">"张三"</span>,<span class="number">89</span>);</span><br><span class="line">Integer score = s1.getScore();</span><br><span class="line"></span><br><span class="line">Student&lt;Integer&gt; s2 = <span class="keyword">new</span> Student&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//s2.setScore("优秀");</span></span><br><span class="line">s2.setScore(<span class="number">99</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>泛型上限<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> T parnter;<span class="comment">//伴侣</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span>&lt;<span class="title">Woman</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span>&lt;<span class="title">Man</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意： (1)不可将类定义泛型的类型作为类的静态成员的数据类型。<br>       (2)泛型类和泛型接口上的泛型形参可以指定上限<code>T extends xx</code>,一旦泛型形参指定上限xx，泛型实参就不能超过它，只能指定为它或它的子类类型。</p><p>泛型类的泛型继承<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">//1)没有类型  擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;<span class="comment">//等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2)具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>,<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类保留父类的泛型</span></span><br><span class="line"><span class="comment">//1)全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2)部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>,<span class="title">T2</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">//1)没有类型  擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;<span class="comment">//等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2)具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>,<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类保留父类的泛型</span></span><br><span class="line"><span class="comment">//1)全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>,<span class="title">A</span>,<span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2)部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>,<span class="title">A</span>,<span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>,<span class="title">T2</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型类时未指定泛型的具体类型：类似于Object，不等同于Object的泛型擦除，默认按照Object处理但编译不会类型检查,明确指定Object，编译会按Object类型检查.</p><p>给泛型类传递实参可以在泛型类实例化时，也可以在继承了泛型类的子类中传递，或者子类继续基础泛型形参类型，在它生成对象时传递实参。</p><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>（1）当某一个方法中它的形参类型等类型不确定时，和其他方法无关，那么这样的情况下，可以为这一个方法单独设计泛型形参。<br>（2）当某些静态方法需要泛型形参时，也要单独设计，因为它不能用类上的泛型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 &lt;泛型形参列表&gt; 返回值类型  方法名（【形参列表】）抛出的异常列表</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyArrays</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">String str = MyArrays.toString(arr);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArrays</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">toString</span><span class="params">(T[] arr)</span></span>&#123;</span><br><span class="line">String str = <span class="string">"["</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (T t : arr) &#123;</span><br><span class="line">str += t;</span><br><span class="line"><span class="keyword">if</span>(i!=arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">str += <span class="string">","</span>;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">str += <span class="string">"]"</span>;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：调用此方法时，泛型形参的类型和方法的形参的值都由实参决定，并且泛型方法声明泛型时也可以指定上限。</p><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>注意：通配符？一般出现在方法的形参类型上，不能在类/接口上出现，表示可以接收任意，解决了泛型不支持继承的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        ArrayList list = new ArrayList();</span><br><span class="line">        list.add(1);</span><br><span class="line">        list.add(&apos;1&apos;);</span><br><span class="line">        list.add(&quot;厉害了&quot;);</span><br><span class="line">        new Main().test1(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test1(ArrayList&lt;?&gt; list)&#123;</span><br><span class="line">/*list.add(&quot;hello&quot;);</span><br><span class="line">list.add(1);*/</span><br><span class="line"></span><br><span class="line">        for (Object object : list) &#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>此时通配符泛型作为方法的形参，可以接收任意的通配符形参，但是上面这段代码只可以读取，不可以添加，而且也没有起到泛型应该履行的职责，所以不建议这样使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void test2(ArrayList&lt;Object&gt; list)&#123;&#125;</span><br></pre></td></tr></table></figure><p>明确指明泛型类型又没有使用到通配符。如果此时形参集合未指明泛型，即擦除泛型，那么还是按照Object来定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;?&gt; list = new ArrayList();</span><br><span class="line">list = new ArrayList&lt;String&gt;();</span><br><span class="line">list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">list = new ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure></p><p>通配符泛型的正确使用方式。</p><p>extends是上限，super是下限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void putAll(Map&lt;? extends K,? extends V&gt; m)</span><br></pre></td></tr></table></figure></p><p>泛型通配符的使得子类的类型不得大于超过K的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        //K：Fu,V：Zi,Zi继承Fu，Fu继承YEYE</span><br><span class="line">        HashMap&lt;Fu,Zi&gt; map = new HashMap&lt;&gt;();// 对于map而言他的KV的上限就是FU与Zi</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Zi,SunZi&gt; map2 = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.putAll(map2);// map2的KV均小于map所以可以进行操作</span><br><span class="line"></span><br><span class="line">        HashMap&lt;YeYe,SunZi&gt; map3 = new HashMap&lt;YeYe,SunZi&gt;();</span><br><span class="line"></span><br><span class="line">//map.putAll(map3);//map3的K并不小于等于Fu所以不能直接操作</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将T... elements多个元素add到c中，所以T的类型要小于等于c</span><br><span class="line">public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Fu&gt; list = new ArrayList&lt;Fu&gt;();</span><br><span class="line"></span><br><span class="line">Collections.addAll(list, new Zi(),new Zi());//T解读为Zi</span><br><span class="line"></span><br><span class="line">ArrayList&lt;SunZi&gt; list2 = new ArrayList&lt;SunZi&gt;();</span><br><span class="line"></span><br><span class="line">//Collections.addAll(list2, new Zi(),new Zi());// 同理这样也是会报错的，</span><br></pre></td></tr></table></figure><p>使用泛型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TestExer1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">HashMap&lt;String, ArrayList&lt;String&gt;&gt; map = new HashMap&lt;String,ArrayList&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; bj = new ArrayList&lt;String&gt;();</span><br><span class="line">bj.add(&quot;北京市&quot;);</span><br><span class="line">map.put(&quot;北京市&quot;, bj);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; hn = new ArrayList&lt;String&gt;();</span><br><span class="line">hn.add(&quot;海口市&quot;);</span><br><span class="line">hn.add(&quot;三亚市&quot;);</span><br><span class="line">map.put(&quot;海南省&quot;, hn);</span><br><span class="line"></span><br><span class="line">Set&lt;Entry&lt;String, ArrayList&lt;String&gt;&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">for (Entry&lt;String, ArrayList&lt;String&gt;&gt; entry : entrySet) &#123;</span><br><span class="line">System.out.println(entry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用泛型时的注意事项"><a href="#使用泛型时的注意事项" class="headerlink" title="使用泛型时的注意事项"></a>使用泛型时的注意事项</h3><h4 id="泛型没有多态"><a href="#泛型没有多态" class="headerlink" title="泛型没有多态"></a>泛型没有多态</h4><p>如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G<b>并不是G<a>的子类型！比如：String是Object的子类，但是List<string>并不是List<object>的子类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Fu&gt; list = new ArrayList&lt;Zi&gt;();//泛型没有多态,所以这样是会报错的</span><br></pre></td></tr></table></figure></object></string></a></b></p><p>要实现这样类似多态要使用通配符泛型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? extends Fu&gt; list = new ArrayList&lt;Zi&gt;();//使用通配符可以实现</span><br></pre></td></tr></table></figure></p><h4 id="没有泛型数组"><a href="#没有泛型数组" class="headerlink" title="没有泛型数组"></a>没有泛型数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tiger&lt;String&gt;[] as = new Tiger&lt;String&gt;[];//是错误的，没有泛型数组</span><br></pre></td></tr></table></figure><h4 id="不能在try-catch中使用泛型定义"><a href="#不能在try-catch中使用泛型定义" class="headerlink" title="不能在try-catch中使用泛型定义"></a>不能在try-catch中使用泛型定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 错误，不可以再此处使用泛型</span><br><span class="line">try&#123;</span><br><span class="line">&#125;catch(T t)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是泛型&quot;&gt;&lt;a href=&quot;#什么是泛型&quot; class=&quot;headerlink&quot; title=&quot;什么是泛型&quot;&gt;&lt;/a&gt;什么是泛型&lt;/h3&gt;&lt;p&gt;集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把存储元素类型
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>lambda</title>
    <link href="http://yoursite.com/2018/06/12/lambda/"/>
    <id>http://yoursite.com/2018/06/12/lambda/</id>
    <published>2018-06-12T12:56:50.000Z</published>
    <updated>2018-06-25T10:53:06.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。<br>很长一段时间java被吐槽是冗余和缺乏函数式编程能力的语言，随着函数式编程的流行java8也引入了这种编程风格。在此之前我们都在写匿名内部类干这些事，但是并不出色。在JS，python等语言中，lambda使用十分广泛，Java吸取其他语言的优点，增加了这个新特性，非常好用。</p><p>匿名内部类实现将一段代码作为数据传递使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"nothing"</span>);<span class="comment">// nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，匿名内部类的作用就是用来当作数据使用的代码块，他的缺点就是，代码过于冗长，实现一个简单的功能也要写上很多代码，代码也没有复用性使得代码冗长，不好阅读。</p><p>使用lambda<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Runnable r = () -&gt; System.out.println(<span class="string">"anything"</span>);</span><br><span class="line">        r.run();<span class="comment">// anything</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"everything"</span>)).start();<span class="comment">//everything</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出lambda函数式更加的简便，lambda表达式关注参数和方法体，而没有方法名，这也很符合匿名函数这个名字。</p><h3 id="lambda函数调用方式"><a href="#lambda函数调用方式" class="headerlink" title="lambda函数调用方式"></a>lambda函数调用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//无参无返回值</span><br><span class="line">Runnable r = () -&gt; System.out.println(&quot;anything&quot;);</span><br></pre></td></tr></table></figure><p>注意：()不能省略，如果{}中只有一个语句，那么{}可以省略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 有参无返回值</span><br><span class="line">//list.forEach((String element) -&gt; &#123;System.out.println(element);&#125;);// 完全形态</span><br><span class="line"></span><br><span class="line">//list.forEach((String element) -&gt; System.out.println(element));// 方法体只有一个语句</span><br><span class="line"></span><br><span class="line">//list.forEach((element) -&gt; System.out.println(element));// 形参只有一个，且数据类型明确，可以省去数据类型</span><br><span class="line"></span><br><span class="line">list.forEach(element -&gt; System.out.println(element));// 括号都可以不要</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();</span><br><span class="line">        arr.add(1);</span><br><span class="line">        arr.add(5);</span><br><span class="line">        arr.add(3);</span><br><span class="line">        arr.forEach(t -&gt; System.out.println(t));</span><br></pre></td></tr></table></figure></p><p>注意：如果{}中只有一个语句，那么{;}可以省略;如果形参的类型是明确的，那么数据类型可以省略;如果形参的类型省略了，而且形参的个数只有一个，那么()可以省略.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 无参有返回值</span><br><span class="line">//Supplier&lt;String&gt; s = () -&gt; &#123;return new String();&#125;;</span><br><span class="line"></span><br><span class="line">Supplier&lt;String&gt; s = () -&gt; new String();</span><br></pre></td></tr></table></figure></p><p>注意：()不可以省略，如果{}中只有一个语句，那么{return ;}可以省略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 有参有返回值</span><br><span class="line">class lambda &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Student&gt; arr = new ArrayList&lt;&gt;();</span><br><span class="line">        arr.add(new Student(1));</span><br><span class="line">        arr.add(new Student(5));</span><br><span class="line">        arr.add(new Student(3));</span><br><span class="line"></span><br><span class="line">        Collections.sort(arr,(t1, t2) -&gt; t1.id-t2.id);</span><br><span class="line"></span><br><span class="line">        arr.forEach(a -&gt; System.out.println(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">    int id;</span><br><span class="line"></span><br><span class="line">    Student(int id)&#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student id = &quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：如果{}中只有一个语句，那么{return ;}可以省略；如果形参的类型是明确的，那么数据类型可以省略；如果形参的类型省略了，而且形参的个数只有一个，那么()可以省略。</p><h2 id="四大核心函数式接口"><a href="#四大核心函数式接口" class="headerlink" title="四大核心函数式接口"></a>四大核心函数式接口</h2><p>lambda表达式应用于这些函数式接口。这几个函数式接口都定义在java.util.function下。本质上本质上它们都是一个接口，但是它是一种特殊的接口：SAM类型的接口（Single Abstract Method）。特点是：函数式接口中有且只能有一个抽象方法，当然可以有静态方法和默认方法，还可以有Object中的方法。只能是符合函数式接口的变量，形参才能赋值为一个Lambda表达式。所以建议在声明一个接口时，如果明确要表示这个接口是一个函数式接口，那么最好在接口声明的上方加上注解：@FunctionalInterface。</p><h3 id="消费型接口：Consumer"><a href="#消费型接口：Consumer" class="headerlink" title="消费型接口：Consumer"></a>消费型接口：Consumer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解说明是一个函数接口，声明一个方法，方法的参数时T类型。<br>基本特征：有参无返回值，相当于消费了，所以称作消费型接口。</p><h3 id="供给型接口：Supplier"><a href="#供给型接口：Supplier" class="headerlink" title="供给型接口：Supplier"></a>供给型接口：Supplier</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：不需要参数就可以得到某类型参数，无中生有供给型函数式接口。</p><h3 id="函数型接口：Function"><a href="#函数型接口：Function" class="headerlink" title="函数型接口：Function"></a>函数型接口：Function</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：Function需要两个参数(可不同类型)，返回值为一个。Function衍生出一些特别的子类BiFunction，DoubleFunction等。</p><h3 id="断定型接口：Predicate"><a href="#断定型接口：Predicate" class="headerlink" title="断定型接口：Predicate"></a>断定型接口：Predicate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Predicate&lt;T&gt; &#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>断定型的特点是对于传入的对象返回一个boolean类型的结果，也衍生出DoublePredicate，IntPredicate等接口。</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>特点：实现抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！<br>使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）类名::实例方法名</span><br><span class="line">（2）对象::实例方法名</span><br><span class="line">（3）类名::静态方法名</span><br></pre></td></tr></table></figure></p><p>三种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Comparator&lt;String&gt; c = new Comparator&lt;String&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(String o1, String o2) &#123;</span><br><span class="line">                return o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Comparator&lt;String&gt; s = (t1, t2) -&gt; t1.compareTo(t2);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;String&gt; s1 = String :: compareTo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法引用虽然使用起来非常简便，但是条件却是非常的苛刻。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;,&quot;world&quot;);</span><br><span class="line"></span><br><span class="line">//forEach形参的类型是java.util.function.Consumer&lt;T&gt;接口</span><br><span class="line">//抽象方法：有参无返回值void accept(T t)</span><br><span class="line">//(1)Lambda是通过调用现成System.out对象的println()方法完成，而且也是有参无返回值</span><br><span class="line">//(2)而且accept的形参，正好是println()的实参</span><br><span class="line">list.forEach(t -&gt; System.out.println(t));</span><br><span class="line">list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void test4()&#123;</span><br><span class="line">//方法体的实现得到两个小数当中的最大值</span><br><span class="line">BinaryOperator&lt;Double&gt; bo = (a,b) -&gt; Math.max(a,b);</span><br><span class="line"></span><br><span class="line"> // apply(T t1, T t2)两个形参，正好是给max的两个实参</span><br><span class="line"> // 返回值类型   apply(T t1, T t2)的返回值是T，这里是Double</span><br><span class="line"> // 而我们max的返回值类型也是a,b类型，Double</span><br><span class="line">BinaryOperator&lt;Double&gt; bo2 = Math::max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>构造器引用的Lambda体是通过创建一个对象完成的。<br>使用方式<br><code>类名::new</code><br>示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConstrunctorReference</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//函数型：Function&lt;T,R&gt; : R apply(T t)</span></span><br><span class="line">Function&lt;Integer,String[]&gt; f = len -&gt; <span class="keyword">new</span> String[len];</span><br><span class="line">Function&lt;Integer,String[]&gt; f2 = String[]::<span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//函数型：BiFunction&lt;T,U,R&gt; : R apply(T t,U u)</span></span><br><span class="line">BiFunction&lt;String,Integer,Person&gt; f = (name,id) -&gt; <span class="keyword">new</span> Person(name,id);</span><br><span class="line">BiFunction&lt;String,Integer,Person&gt; f2 = Person::<span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//函数型：Function&lt;T,R&gt; : R apply(T t)</span></span><br><span class="line">Function&lt;String,Person&gt; f = name -&gt; <span class="keyword">new</span> Person(name);</span><br><span class="line">Function&lt;String,Person&gt; f2 = Person::<span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//供给型：Supplier&lt;T&gt; : T get()，无参有返回值</span></span><br><span class="line">Supplier&lt;String&gt; s = () -&gt; <span class="keyword">new</span> String();</span><br><span class="line">Supplier&lt;String&gt; s1 = String::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">Supplier&lt;Person&gt; p = () -&gt; <span class="keyword">new</span> Person();</span><br><span class="line">Supplier&lt;Person&gt; p2 = Person::<span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>一般会与lambda语句一同使用，用于解决Java常见的空指针异常，Optional本质是一个存放对象的容器，解决空指针异常的本质就是不用我们显式的判断数据是否为null了，但是空值判断还是要以其他方法进行(Optional的方法)。</p><h4 id="创建Optional的三种方式"><a href="#创建Optional的三种方式" class="headerlink" title="创建Optional的三种方式"></a>创建Optional的三种方式</h4><ul><li>（1）Optional.empty()：空的容器，里面相当于是封装的是null；</li><li>（2）Optional.of(非空对象)；</li><li>（3）Optional.ofNullable(可以是null可以不是null)。<h4 id="Optional方法"><a href="#Optional方法" class="headerlink" title="Optional方法"></a>Optional方法</h4><ol><li>获取数据：get()：从容器中取出对象，但是要求这个容器中对象必须非空；orElseGet(Supplier s)：从容器中取出对象，如果这个容器中的对象是非空，那么就取出这个对象给调用者，如果这个容器的对象是空的，那么就由Supplier这个供给型接口的实现方法来提供一个对象给调用者。这两种方式得到的对象一定不是空的，而且也没有显式进行空值判断。</li><li>判断是否容器中包含对象：isPresent()，判断是否存在，如果存在，对这个对象执行由Comsumer接口指定的操作：ifPresent(Consumer&lt;? super T&gt; consumer)。</li><li>orElse(T t):从容器中取出对象，如果这个容器中的对象是非空，那么就取出这个对象给调用者，如果这个容器的对象是空的，那么就由t对象代替。</li><li>orElseThrow(Supplier s)：从容器中取出对象，如果这个容器中的对象是非空，那么就取出这个对象给调用者，如果这个容器的对象是空的，那么就报由Supplier提供异常信息返回。</li><li>Optional<t> filter(Predicate&lt;? super T&gt; predicate) ：判断当前Optional容器中是否存在对象，并且是否满足Predicate指定的条件判断，如果满足，那么就返回一个合理的Optional<t>对象，如果不存在或不满足条件，就返回一个Empty的Optional。</t></t></li><li><u> Optional<u> map(Function&lt;? super T,? extends U&gt; mapper)，如果当前Optional容器中对象是null，就什么也不干，如果是非空的对Optional容器中对象进行某种操作，按照Function指定的操作进行，返回有Function的操作完的结果返回。<h4 id="使用Optional"><a href="#使用Optional" class="headerlink" title="使用Optional"></a>使用Optional</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOptional</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span></span>&#123;</span><br><span class="line">Optional&lt;List&lt;Integer&gt;&gt; of = Optional.of(Arrays.asList(<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出集合中的最大值</span></span><br><span class="line">Optional&lt;Integer&gt; max = of.flatMap(list -&gt; &#123;Collections.sort(list);  <span class="keyword">return</span> Optional.of(list.get(list.size()-<span class="number">1</span>));&#125;);</span><br><span class="line">System.out.println(max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span></span>&#123;</span><br><span class="line">Optional&lt;List&lt;Integer&gt;&gt; of = Optional.of(Arrays.asList(<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出集合中的最大值</span></span><br><span class="line">Optional&lt;Integer&gt; max = of.map(list -&gt; Collections.max(list));</span><br><span class="line">System.out.println(max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span></span>&#123;</span><br><span class="line">Student stu = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">78</span>);</span><br><span class="line">Optional&lt;Student&gt; of = Optional.ofNullable(stu);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出学生对象的姓</span></span><br><span class="line">Optional&lt;String&gt; map = of.map(t -&gt; t.getName().substring(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">Student stu = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">78</span>);</span><br><span class="line">Optional&lt;Student&gt; of = Optional.ofNullable(stu);</span><br><span class="line"><span class="comment">//Optional&lt;Student&gt; of = Optional.ofNullable(null);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对of中的对象，加10分，如果of中的对象不为空的话</span></span><br><span class="line"><span class="comment">//参数：Function&lt;T,R&gt;：R apply(T t)</span></span><br><span class="line">Optional&lt;Student&gt; map = of.map(t -&gt; &#123;t.setScore(t.getScore()+<span class="number">10</span>);  <span class="keyword">return</span> t;&#125;);</span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">Student stu = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">78</span>);</span><br><span class="line"><span class="comment">//Optional&lt;Student&gt; of = Optional.ofNullable(stu);</span></span><br><span class="line">Optional&lt;Student&gt; of = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断of中包装的学生，成绩是否是&gt;=60分，如果是，返回该学生对象，如果不是，返回空</span></span><br><span class="line"><span class="comment">//Predicate&lt;T&gt;：boolean test(T t)</span></span><br><span class="line">Optional&lt;Student&gt; result = of.filter(t -&gt; t.getScore()&gt;=<span class="number">60</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//Optional&lt;String&gt; of = Optional.ofNullable("张三");</span></span><br><span class="line">Optional&lt;String&gt; of = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//形参是Supplier&lt;T&gt;: T get()</span></span><br><span class="line">String name = of.orElseThrow(() -&gt; <span class="keyword">new</span> RuntimeException(<span class="string">"用户名不存在"</span>));</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//Optional&lt;String&gt; of = Optional.ofNullable("张三");</span></span><br><span class="line">Optional&lt;String&gt; of = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">String name = of.orElse(<span class="string">"无名"</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">Optional&lt;String&gt; of = Optional.ofNullable(<span class="string">"张三"</span>);</span><br><span class="line"><span class="comment">//如果是空的，就什么也不做，如果不是空的，截取出它的姓，并打印</span></span><br><span class="line"><span class="comment">//形参类型是：Consumer&lt;T&gt;：void accept(T t)</span></span><br><span class="line">of.ifPresent(name -&gt; System.out.println(name.substring(<span class="number">0</span>,<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">Optional&lt;String&gt; of = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为of容器中的对象可能是null，可能不是null</span></span><br><span class="line"><span class="comment">//那么可以判断</span></span><br><span class="line">System.out.println(of.isPresent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">Optional&lt;String&gt; of = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//String string = of.get();//从容器中取出元素</span></span><br><span class="line"><span class="comment">//System.out.println(string);//No value present</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//orElseGet(Supplier s)</span></span><br><span class="line"><span class="comment">//Supplier&lt;T&gt;：T get()</span></span><br><span class="line"><span class="comment">//String s2 = of.orElseGet(() -&gt; new String());</span></span><br><span class="line">String s2 = of.orElseGet(String::<span class="keyword">new</span>);</span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line">String address = <span class="string">"beijing"</span>;</span><br><span class="line"><span class="keyword">if</span>(s2.equals(address))&#123;</span><br><span class="line">System.out.println(<span class="string">"地址是北京"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">String address = <span class="string">"beijing"</span>;</span><br><span class="line">Optional&lt;String&gt; of = Optional.of(address);</span><br><span class="line"></span><br><span class="line">String string = of.get();<span class="comment">//从容器中取出元素</span></span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Optional&lt;Object&gt; empty = Optional.empty();</span><br><span class="line">System.out.println(empty);</span><br><span class="line"></span><br><span class="line">String address = <span class="string">"beijing"</span>;</span><br><span class="line">Optional&lt;String&gt; of = Optional.of(address);</span><br><span class="line">System.out.println(of);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student stu = null;</span></span><br><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">Optional&lt;Student&gt; of2 = Optional.ofNullable(stu);</span><br><span class="line">System.out.println(of2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", score="</span> + score + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></u></u></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h2&gt;&lt;p&gt;Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Map</title>
    <link href="http://yoursite.com/2018/06/12/Map/"/>
    <id>http://yoursite.com/2018/06/12/Map/</id>
    <published>2018-06-12T12:08:59.000Z</published>
    <updated>2018-06-21T15:00:56.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map与Collection并列存在。用于保存具有映射关系的数据:Key-Value。Map中的key和value都可以是任何引用类型的数据，Map中的key不允许重复，key和value之间存在单向一对一关系，即通过指定的key总能找到唯一的、确定的value。Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。允许使用null键和null值，与HashSet一样，不保证映射的顺序。</p><h4 id="Map常用方法"><a href="#Map常用方法" class="headerlink" title="Map常用方法"></a>Map常用方法</h4><ol><li>添加：put(Object key,Object value)：添加一对k-v，putAll(Map m)：把m的Map的映射关系都添加到当前map中。</li><li>获取有效映射关系的对数：size()。</li><li>可以根据key获取value：Object get(Object key)。</li><li>删除：remove(Object key)，clear()。</li><li>是否包含：boolean containsKey(Object key)，boolean containsValue(Object value)。</li><li>是否为空：isEmpty()。</li></ol><h4 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;map的所有key:&quot;);</span><br><span class="line">Set keys = map.keySet();//HashSet</span><br><span class="line">for(Object key : keys)&#123;</span><br><span class="line">    System.out.println(key+&quot;-&gt;&quot;+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;map的所有的value：&quot;);</span><br><span class="line">Collection values = map.values();</span><br><span class="line">Iterator iter = values.iterator();</span><br><span class="line">while(iter.hasNext())&#123;</span><br><span class="line">    System.out.println(iter.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;map所有的映射关系：&quot;);</span><br><span class="line">//映射关系的类型是Map.Entry类型，它是Map接口的内部接口</span><br><span class="line">Set mappings = map.entrySet();</span><br><span class="line">for(Object mapping : mappings)&#123;</span><br><span class="line">    //System.out.println(mapping);</span><br><span class="line">    Map.Entry entry = (Map.Entry)mapping;</span><br><span class="line">    System.out.println(&quot;key是：&quot;+ entry.getKey()+ &quot;，value是：&quot;+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>Map的遍历，不能支持foreach；</li><li>可以单独遍历所有key，根据key获取对应value；</li><li>可以单独遍历value；</li><li>成对遍历：遍历的是映射关系Map.Entry，Map.Entry是Map接口的内部接口。每一种Map内部有自己的Map.Entry的实现类。<br>在Map中存储数据，实际上是将Key，value的数据存储在Map.Entry接口的实例中，再在Map集合中插入Map.Entry的实例化对象。<br><img src="http://p94ypeu3q.bkt.clouddn.com/entry.png" alt="entry"></li></ol><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap判断key与value是否相等的操作与HashSet的方式一致（hashcode与equals）。</p><h4 id="1-8之前的HashMap"><a href="#1-8之前的HashMap" class="headerlink" title="1.8之前的HashMap"></a>1.8之前的HashMap</h4><p>HashMap的内部存储结构其实是数组和链表的结合。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。<br>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p><p>HashMap什么时候进行扩容呢？<br>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)<code>*</code>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16<code>*</code>0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p><h4 id="1-8之后的HashMap"><a href="#1-8之后的HashMap" class="headerlink" title="1.8之后的HashMap"></a>1.8之后的HashMap</h4><p>HashMap的内部存储结构其实是数组和链表/树的结合。当实例化一个HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last,或树的叶子结点。（七上八下）</p><p>HashMap什么时候进行扩容和树形化呢？<br>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)<code>*</code>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16<code>*</code>0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树在转为链表。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>是HashMap的子类，维护了添加的顺序。效率更低，在添加，删除时，要多费心来维护前后的关系。</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap存储 Key-Value 对时，需要根据 key进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。</p><p>TreeMap 的 Key 的排序分为两种：<br>自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException；<br>定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。<br>TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。若使用自定义类作为TreeMap的key，所属类需要重写equals()和hashCode()方法，且equals()方法返回true时，compareTo()方法应返回0。</p><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable与HashMap基本上实现都一样，只是Hashtable是个比较老的 Map 实现类（JDK1.0），它是线程安全，HashMap线程不安全。与HashMap不同的是Hashtable 不允许使用 null 作为 key 和 value。</p><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>Properties 类是 Hashtable 的子类，该对象用于处理属性文件，由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型，存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法。</p><p>注意： 不管哪种Map，添加到map中后，这个key就不用修改了，特别是这个属性值涉及到hashCode和equals或comparexx的计算或比较的属性。一旦修改了key，和原来的key就不一样，那么就找不到原来的数据了。所以实际开发中，比较多见把String或Integer这样的不可变的类型作为key值。</p><h3 id="Map集合框架"><a href="#Map集合框架" class="headerlink" title="Map集合框架"></a>Map集合框架</h3><p><img src="http://p94ypeu3q.bkt.clouddn.com/TIM截图20180614184646.png" alt="TIM截图20180614184646"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h3&gt;&lt;p&gt;Map与Collection并列存在。用于保存具有映射关系的数据:Key-Value。Map中的key和value都可以是任何引用类
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Collection</title>
    <link href="http://yoursite.com/2018/06/11/Collection/"/>
    <id>http://yoursite.com/2018/06/11/Collection/</id>
    <published>2018-06-11T15:57:15.000Z</published>
    <updated>2018-06-21T12:57:08.434Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在说集合之前，要先提一下数组这个数据结构。数组本身是一个线性的数据结构，从物理结构看是一个顺序存储结构。每次申请一段连续的空间，一旦申请到，内存就固定了。所有数据存储在这个连续的空间中，数组中的每一个元素都是一个具体的数据（或对象），所有数据都紧密排布，不能有间隔。数组可以通过下标快速的查找元素，但是当数组做插入和删除操作操作时，效率则会极其的低下，而且也不能直接访问到当前数组中有效元素的个数。介于数组的缺点，为满足数据更多种的逻辑关系，而设计的一系列的不同于数组的可变的聚合的抽象数据类型，被称作集合。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>盛放数据的逻辑概念；</li><li>实现集合的底层物理结构是数组和链表。底层的逻辑结构有在物理结构的基础上又封装了一层，对于使用者来说，不用关心内部的物理结构，通过方法直接来使用它的功能；</li><li>具备功能：添加，删除，查找获取，和直接获取有效元素的个数；</li><li>Java集合分为两类，Collection和Map（可理解为list和dict，但是种类复杂得多）；</li><li>只能存放对象；</li><li>容量自动调节。​<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="Collection简介"><a href="#Collection简介" class="headerlink" title="Collection简介"></a>Collection简介</h4>Collection层次结构中的根接口。Collection表示一组对象，这些对象也称为collection的元素。一些collection允许有重复的元素，而另一些则不允许。一些collection是有序的，而另一些则是无序的。JDK不提供此接口的任何直接实现：它提供更具体的子接口（如Set和List）实现。此接口通常用来传递collection，并在需要最大普遍性的地方操作这些collection。<br>Collection(java.util)继承了Iterable(java.lang)，所以集合都是可以迭代的,Iterable(java.lang)是集合类的最上层接口。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; </span><br><span class="line"></span><br><span class="line">default void forEach(Consumer&lt;? super T&gt; action) &#123;// Iterable方法，1.8后增加，用于lambda遍历</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    for (T t : this) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Collection方法"><a href="#Collection方法" class="headerlink" title="Collection方法"></a>Collection方法</h4><p>Collection里规定了很多方法：</p><p>添加:<br>add(Object obj),添加单个对象，addAll(Collection coll)：添加一组对象。</p><p>删除：<br>remove(Object o)，删除单个对象，removeAll(Collection c)，删除两个集合的交集部分，clear()：清空。</p><p>查找：<br>contains(Object o)，是否包含某个对象，containsAll(Collection c)，是否包含某个集合。</p><p>isEmpty()是否空集。</p><p>size()获取有效元素的个数。</p><p>Object[] toArray()返回所有对象。</p><p>retainAll(Collection c)保留当前集合与c交集的部分。</p><p>Iterator iterator()获取当前集合的迭代器对象，迭代器对象可用来遍历当前集合。</p><h4 id="Collection操作"><a href="#Collection操作" class="headerlink" title="Collection操作"></a>Collection操作</h4><p>操作Collection：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// c可以进行上述的方法操作</span><br><span class="line">Collection c = new ArrayList();</span><br></pre></td></tr></table></figure></p><h4 id="Collection特点"><a href="#Collection特点" class="headerlink" title="Collection特点"></a>Collection特点</h4><ol><li>Collection本身不可以直接而实例化对象，操作Collection就是操作的Collection的子类(可隔代)实例化对象操作。</li><li>Collection是一个上层概念，但是Collection还有上层，Collection的上层是Iterable，Collection继承了它。</li><li>Collection包含了集合的基本操作方法，但是大多数方法都未实现，只是定义了接口，需要不同的子接口根据需求自行实现。</li></ol><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List是Collection的子接口之一，它实现了很多方法，除了父接口继承的以外又增加了一些。List的特点是单值，有序，可重复。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt;</span><br></pre></td></tr></table></figure></p><h4 id="List方法"><a href="#List方法" class="headerlink" title="List方法"></a>List方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get， set， lastIndexOf， listIterator， subList等</span><br></pre></td></tr></table></figure><h4 id="List特点"><a href="#List特点" class="headerlink" title="List特点"></a>List特点</h4><ol><li>List是Collection的子接口，同时它也是一个上层接口，它不直接实现对象，使用List类型的集合需要使用实现了它的子类的实例；</li><li>List相较于Collection也增建了一些接口，但是都是抽象接口，它本身并未实现；</li><li>所有的List共有特点单值，有序，可重复；</li><li>它实现一个ListIterator迭代器，这个迭代器相较于Iterator又增加了一些实用的方法。</li></ol><h3 id="ArrayList和Vector-动态数组"><a href="#ArrayList和Vector-动态数组" class="headerlink" title="ArrayList和Vector(动态数组)"></a>ArrayList和Vector(动态数组)</h3><h4 id="共同父类AbstractCollection"><a href="#共同父类AbstractCollection" class="headerlink" title="共同父类AbstractCollection"></a>共同父类AbstractCollection</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt;// 具体实现了indexOf和lastIndexOf，clear，addAll，</span><br></pre></td></tr></table></figure><p>AbstractList具体实现了indexOf和lastIndexOf，clear，addAll，removeRange等，定义（private class Itr implements Iterator<e>）内部类具体实现迭代的细节（内部类方式实现迭代）。</e></p><h4 id="两者异同比较"><a href="#两者异同比较" class="headerlink" title="两者异同比较"></a>两者异同比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 发行时间不同</span><br><span class="line"> * @since   1.2</span><br><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line"></span><br><span class="line"> * @since   JDK1.0</span><br><span class="line">public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 底层实现物理结构都是数组</span><br><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line">protected Object[] elementData;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 创建与扩容机制不同</span><br><span class="line">    private static final int DEFAULT_CAPACITY = 10;// 默认创建长度是10，但是初始化数组为空时集合长度0，直到加入数据时长度变为10</span><br><span class="line"></span><br><span class="line">    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;    </span><br><span class="line">    public ArrayList() &#123;</span><br><span class="line">        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">    private void grow(int minCapacity) &#123;</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 扩容1.5倍</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        // minCapacity is usually close to size, so this is a win:</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Vector() &#123;</span><br><span class="line">        this(10);//初始是10字节</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void grow(int minCapacity) &#123;</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);// 扩容一倍或capacityIncrement多字节</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>异同总结：</p><ol><li>共同父类AbstractCollection，内部很多方法都基本一致；</li><li>两者底层实现都是数组的操作；</li><li>版本不同ArrayList(1.2)比Vector(1.0)新；</li><li>Vector线程安全，效率略低，ArrayList线程不安全，效率高</li><li>扩容机制不同通过无参构造创建Vector时，默认的数组的长度为10，当容量不够，扩容要么按照指定的capacityIncrement进行扩容，要么扩大为原来的2倍；通过无参构造创建ArrayList对象时，默认是初始化为一个长度为0空数组常量。如果一开始是初始化为空数组时，当添加第一个元素时，扩容为长度为10的数组。当容量再不够时，扩容为原来的1.5倍，尽量减少浪费。</li></ol><p>注意：ArrayList在JDK1.7及以前一开始就会扩容长度10的数组。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>LinkedList也是List的实现类，他的逻辑结构类似于双端连接的链表。</p><h4 id="LinkedList特点"><a href="#LinkedList特点" class="headerlink" title="LinkedList特点"></a>LinkedList特点</h4><ol><li>动态数组需要开辟连续的空间，而双向链表不需要，是通过结点(Node)的互相“引用，连接”的方法把集合的元素串起来；</li><li>LinkedList遍历查找的效率低，因为动态数组位置连续的，还可以根据索引index直接定位位置，而LinkedList只能从head或last两头开始遍历查找；</li><li>LinkedList在频繁的插入、指定对象删除一个对象时，效率反而高，因为不涉及移动大量的元素，只需要修改前后元素的next,pre即可。</li></ol><p>注意：实现List接口的还有一种集合，Stack，栈结构特点先入后出，平时使用并不多。</p><h3 id="List新增方法"><a href="#List新增方法" class="headerlink" title="List新增方法"></a>List新增方法</h3><ol><li>add，add(index, obj)：指定位置添加，addAll(index, Collection c)：指定位置插入集合c；</li><li>get(index)获取指定位置的元素；</li><li>indexOf(obj)：返回第一个找到的对象的索引，没有就返回-1，int lastIndexOf(Object o) ：返回最后一个找到的对象的索引，没有返回-1；</li><li>set(index,value)，设定指定位置对象；</li><li>subList(int fromIndex, int toIndex)，截取当前列表的一部分；</li><li>ListIterator  listIterator()，ListIterator继承了Iterator。<h4 id="ListIterator方法"><a href="#ListIterator方法" class="headerlink" title="ListIterator方法"></a>ListIterator方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* （1）hasPrevious()：是否有前一个元素</span><br><span class="line">* （2）previous() ：取出前一个元素</span><br><span class="line">* （3）add(Object)：说明可以在遍历的同时添加元素</span><br><span class="line">* （4）set(Object)：说明可以在遍历的同时替换元素</span><br><span class="line">* （5）nextIndex()：下一个元素的索引</span><br><span class="line">* （6）previousIndex()：前一个元素的索引</span><br></pre></td></tr></table></figure></li></ol><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set接口是Collection的子接口，set接口没有提供额外的方法，Set不保证添加顺序，数据不可重复。Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals 方法。因此存放到Set集合中的元素一定要注意equals方法的重写。Set的常用实现类有：HashSet、TreeSet、LinkedHashSet。</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>HashSet：依据元素的hashCode()和equals()方法，来确定它的存储的顺序和保证不可重复，认为两个对象equals相等，即是重复元素，不能保证元素的排列顺序，非线程安全，元素可以为null。底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍。</p><p>工作方式：当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据hashCode值，通过某种散列函数决定该对象在HashSe 中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）。如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败，如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链接。<br>TreeSet：依据元素的“大小”顺序来确定他的存储顺序和保证不可重复，认为两个对象“大小”相等，即是重复的元素，元素的“大小”顺序依赖于Comparable或Comparator的接口的实现方法。</p><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>LinkedHashSet：LinkedHashSet是HashSet的子类，既延续了父类的特征，又扩展了一些特性，元素是有序的，比HashSet多维护了添加时前后元素的关系，效率低。</p><h3 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h3><p>集合遍历有三种方式：集合调用方法返回数组，然后通过for循环遍历数组；直接使用foreach遍历集合；通过迭代器遍历集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">Collection big = new ArrayList();</span><br><span class="line">big.add(&quot;老大&quot;);</span><br><span class="line">big.add(&quot;老二&quot;);</span><br><span class="line">big.add(&quot;jefflike&quot;);</span><br><span class="line"></span><br><span class="line">// 方式一：for循环</span><br><span class="line">Object[] array = big.toArray();</span><br><span class="line">for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">System.out.println(array[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式二：foreach</span><br><span class="line">       for (Object object : big) &#123;</span><br><span class="line">           System.out.println(object);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       // 方式三：Iterator迭代</span><br><span class="line">       Iterator iterator = big.iterator();//直接就返回一个迭代器对象</span><br><span class="line">       while(iterator.hasNext())&#123;</span><br><span class="line">           Object next = iterator.next();</span><br><span class="line">           if(&quot;老大&quot;.equals(next))&#123;</span><br><span class="line">               iterator.remove();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       for (Object object : big) &#123;</span><br><span class="line">           System.out.println(object);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三种遍历集合方式的比较：</p><ol><li>foreach和Iterator没有下标信息；</li><li>foreach不能修改元素；</li><li>for下标遍历应用不广泛，效率不如foreach高；</li><li>Iterator可以在遍历过程中进行删除，修改等操作；</li><li>迭代器是一个独立的对象，他有自己的方法与属性，它以内部类方式实现。</li></ol><p>集合的继承关系：<br><img src="http://p94ypeu3q.bkt.clouddn.com/TIM截图20180612200737.png" alt="TIM截图20180612200737"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在说集合之前，要先提一下数组这个数据结构。数组本身是一个线性的数据结构，从物理结构看是一个顺序存储结构。每次申请一段连续的空间，一旦申请到，
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>String StringBuffer和StringBiuld</title>
    <link href="http://yoursite.com/2018/06/11/StringAndStringBufferAndStringBiuld/"/>
    <id>http://yoursite.com/2018/06/11/StringAndStringBufferAndStringBiuld/</id>
    <published>2018-06-11T12:55:26.000Z</published>
    <updated>2018-06-11T15:30:43.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>通过前面查看String的源码，对String也有一定的了解了，String是编程语言里时常会使用到的数据类型，虽然Java里的String不是基本数据类型，但是他的重要性绝对不亚于基本数据类型的。关于String类型的问题，最大的一点就是String本身是一个不可变的数据类型，在完成大量的字符串拼接的情况下，非常的低效，所以后来就衍生出了可变字符序列。</p><h3 id="可变字符序列是怎样实现的"><a href="#可变字符序列是怎样实现的" class="headerlink" title="可变字符序列是怎样实现的"></a>可变字符序列是怎样实现的</h3><p>对于可变字符序列，他的底层还是字符数组，只是通过控制创建字符数组的长度，来减少新数组创建的次数，从而使得字符序列修改增删变得非常的便捷快速。</p><h3 id="代码细节-以StringBuffer为例"><a href="#代码细节-以StringBuffer为例" class="headerlink" title="代码细节(以StringBuffer为例)"></a>代码细节(以StringBuffer为例)</h3><p>底层实现依然是字符数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient char[] toStringCache;</span><br></pre></td></tr></table></figure></p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public StringBuffer() &#123;</span><br><span class="line">    super(16);// 初始化底层的字符数组的长度就是16</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public StringBuffer(int capacity) &#123;</span><br><span class="line">    super(capacity);// 可以指明初始化时的字符数组的长度</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public StringBuffer(String str) &#123;</span><br><span class="line">    super(str.length() + 16);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public StringBuffer(CharSequence seq) &#123;</span><br><span class="line">    this(seq.length() + 16);</span><br><span class="line">    append(seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后两个构造器，初始化的字符数组的长度，比传入的字符大16，就是为了方便字符数组的扩容而准备充足的空间。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized int length() &#123;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符数组的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized int capacity() &#123;</span><br><span class="line">    return value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前容器的容量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized char charAt(int index) &#123;</span><br><span class="line">    if ((index &lt; 0) || (index &gt;= count))</span><br><span class="line">        throw new StringIndexOutOfBoundsException(index);</span><br><span class="line">    return value[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引为index的字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void setCharAt(int index, char ch) &#123;</span><br><span class="line">    if ((index &lt; 0) || (index &gt;= count))</span><br><span class="line">        throw new StringIndexOutOfBoundsException(index);</span><br><span class="line">    toStringCache = null;</span><br><span class="line">    value[index] = ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改索引为index的字符。</p><p>reverse方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public AbstractStringBuilder reverse() &#123;</span><br><span class="line">    boolean hasSurrogates = false;</span><br><span class="line">    int n = count - 1;</span><br><span class="line">    for (int j = (n-1) &gt;&gt; 1; j &gt;= 0; j--) &#123;</span><br><span class="line">        int k = n - j;</span><br><span class="line">        char cj = value[j];</span><br><span class="line">        char ck = value[k];</span><br><span class="line">        value[j] = ck;</span><br><span class="line">        value[k] = cj;</span><br><span class="line">        if (Character.isSurrogate(cj) ||</span><br><span class="line">            Character.isSurrogate(ck)) &#123;</span><br><span class="line">            hasSurrogates = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hasSurrogates) &#123;</span><br><span class="line">        reverseAllValidSurrogatePairs();</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重载了很多序列增删改查的方法，具体实现都是继承的父类相应的方法。</p><p>父类的序列扩容策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private int newCapacity(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int newCapacity = (value.length &lt;&lt; 1) + 2;// 扩容为两倍+2</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0) &#123;</span><br><span class="line">        newCapacity = minCapacity;// 还不够就增加至当前的长度</span><br><span class="line">    &#125;</span><br><span class="line">    return (newCapacity &lt;= 0 || MAX_ARRAY_SIZE - newCapacity &lt; 0)</span><br><span class="line">        ? hugeCapacity(minCapacity)</span><br><span class="line">        : newCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">    if (Integer.MAX_VALUE - minCapacity &lt; 0) &#123; // overflow</span><br><span class="line">        throw new OutOfMemoryError();//字符长度超出容量的最大值了</span><br><span class="line">    &#125;</span><br><span class="line">    return (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? minCapacity : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最近看到有面试题将String，StringBuffer和StringBuilder拿来作比较，所以就看了一下这三种类型，并且将他们做一个比较。</p><ol><li>首先String是不可变的字符序列(不能原地修改)，StringBuffer和StringBuilder是可变字符序列(可以原地修改)；</li><li>String底层数组不可扩容，StringBuffer和StringBuilder底层数组可扩容，默认的长度是16字节，扩容时先扩大两倍+2，如果还不够则将字符数组的最小长度作为数组长度；</li><li>String可以直接创建常量值，而StringBuffer和StringBuilder只能用new的方式创建新对象；</li><li>StringBuffer和StringBuilder支持链式调用，例如append方法的返回值就是this，String是不可以链式调用的。</li></ol><p>StringBuffer和StringBuilder的区别是：<br>StringBuffer：线程安全，效率较慢；StringBuilder： 线程不安全，效率较高。这里效率指的是修改字符串的效率，当然效率快慢是这两者之间的比较，StringBuffer还是比String快的多的。<br>比较一下效率：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTime</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">testStringBuilder();</span><br><span class="line"><span class="comment">//testStringBuffer();</span></span><br><span class="line"><span class="comment">//testString();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line">s += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"String拼接+用时："</span>+(end-start));<span class="comment">//445</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> memory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class="line">        System.out.println(<span class="string">"String拼接+memory: "</span> + memory);<span class="comment">// 53169472</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStringBuilder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">StringBuilder s = <span class="keyword">new</span> StringBuilder(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line">s.append(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"StringBuilder拼接+用时："</span>+(end-start));<span class="comment">//10</span></span><br><span class="line"><span class="keyword">long</span> memory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class="line">        System.out.println(<span class="string">"StringBuilder拼接+memory: "</span> + memory);<span class="comment">//1950488</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStringBuffer</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line">s.append(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"StringBuffer拼接+用时："</span>+(end-start));<span class="comment">//12</span></span><br><span class="line"><span class="keyword">long</span> memory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class="line">        System.out.println(<span class="string">"StringBuffer拼接+memory: "</span> + memory);<span class="comment">//1950488</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;通过前面查看String的源码，对String也有一定的了解了，String是编程语言里时常会使用到的数据类型，虽然Java里的String
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
