<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql数据库的事务隔离级别]]></title>
    <url>%2F2018%2F08%2F05%2Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[本篇就是简单说说Java的四个事务管理级别。 查询当前的数据库的事务隔离级别1select @@global.tx_isolation,@@tx_isolation; 1234567mysql&gt; select @@global.tx_isolation,@@tx_isolation;+-----------------------+-----------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+-----------------+| REPEATABLE-READ | REPEATABLE-READ |+-----------------------+-----------------+1 row in set, 2 warnings (0.00 sec) 可以看出mysql的默认事务隔离级别是可重复读。 修改当前数据库的事务隔离级别为了测试不同的事务隔离级别所以首先第一步我们要知道如何修改当前的事务隔离级别。这里我们只修改当前会话的事务隔离级别即可：1set session transaction isolation level read uncommitted; session指的就是当前会话，read uncommitted就是读未提交的事务隔离级别，事务隔离级别的最低等级。12345678910mysql&gt; set session transaction isolation level read uncommitted;Query OK, 0 rows affected (0.00 sec)mysql&gt; select @@global.tx_isolation,@@tx_isolation;+-----------------------+------------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+------------------+| REPEATABLE-READ | READ-UNCOMMITTED |+-----------------------+------------------+1 row in set, 2 warnings (0.00 sec) 读未提交&amp;可重复读我开启两个会话窗口，一个事务隔离级别调整为读未提交，一个事务仍旧是可重复读。并且开启两个窗口的事务：1SET autocommit = 0; 下面我的叙述分为左会话(read uncommitted),右会话(repeatable read)，我在左会话查询整表时，在右会话中也可以查询到整表信息(此时没有表锁);当然读取行也是可以的当修改某一行的时候：此时左会话修改了第一行，但是事务未提交，那么右会话想修改这一行是不可能修改的，事务默认锁住了这一行，直至左会话提交事务。此时由于右会话是可重复读，已经解决了脏读问题，所以右会话查询结果是修改前的数据，还不是左会话未提交的数据。12345678-- 右会话mysql&gt; select * from biao where id = 1;+----+---------+--------+---------+| id | sick_id | doc_id | describ |+----+---------+--------+---------+| 1 | 1001 | 100001 | 腹痛 |+----+---------+--------+---------+1 row in set (0.00 sec) 接着我们将左会话提交，在右会话中查询，得到的结果：为什么我左会话已经提交了，但是右会话查询到的还是之前的数据呢，简单地说就是因为右会话的事务隔离级别是可重复读，那么右会话在左会话commit之前实际上是查询了一次的，查询后并未提交事务，因为当前事务隔离级别是可重复读，所以在上一次查询事务还未结束的情况下，是不可以出现不可重复读的问题，所以独到的仍然是修改前的值。此时我们将右会话commit就可以得到当前修改后的数据了。1234567891011-- 右会话mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from biao where id = 1;+----+---------+--------+-----------+| id | sick_id | doc_id | describ |+----+---------+--------+-----------+| 1 | 1001 | 100001 | 没毛病 |+----+---------+--------+-----------+1 row in set (0.00 sec) 为了查看读未提交的特性，我们修改右会话的数据，然后对左会话进行测试，基本上一致，除了一点，当我们修改右会话数据的时候，左会话修改同样因为锁而阻塞，查询数据时会出现脏读现象：脏读即读取到对方事务还未提交的数据，这个事务可能回滚数据，所以读到的数据没有有效性，就是一段脏数据。解决脏读的方法就是事务隔离级别改为读已提交。 读已提交首先，我们将左会话的事务隔离级别改为读已提交：12345678910mysql&gt; set session transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec)mysql&gt; select @@global.tx_isolation,@@tx_isolation;+-----------------------+----------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+----------------+| REPEATABLE-READ | READ-COMMITTED |+-----------------------+----------------+1 row in set, 2 warnings (0.00 sec) 读已提交的事务隔离级别可以解决脏读问题，但是却存在着不可重复读的问题：可以看出，在我的左会话的两次查询一次事务中，我查到了两组不同的数据，并且第一次查询的数据不可再现(右会话已经提交修改数据)，这并不是我们希望看到的，对于首次查询的结果不可再现的情况，我们称为不可重复读，解决这种问题，需要我们的事务隔离级别为可重复读。 可重复读我们在读未提交里其实已经可以看到读已提交的效果了，在一次事务会话里，即使数据库中的数据已经改变了，我们依然可以读到之前的数据以保持在一次回话中数据不会发生不可重复读的情况，直到此次事务结束，我们才可以获得当前数据库中真实的值，防止一次回话中的多个线程修改同一条数据，每次查到的结果都不一样，让人不知所措。那么我们知道可重复读并不是事务隔离级别的最高级，最高级是串行化用来解决幻读问题。实现以下幻读的效果，首先将两边的回话都改为可重复读的隔离级别：12345678910mysql&gt; set session transaction isolation level repeatable read;Query OK, 0 rows affected (0.00 sec)mysql&gt; select @@global.tx_isolation,@@tx_isolation;+-----------------------+-----------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+-----------------+| REPEATABLE-READ | REPEATABLE-READ |+-----------------------+-----------------+1 row in set, 2 warnings (0.00 sec) 串行化解决幻读问题。 for update不论哪种隔离级别，查询因为并不会修改数据，所以都不会阻塞，但是我们如果希望某一段之内我操作不论增删改查都不允许第三方操作，那么我们就需要使用for update强行加锁。此时先抢占到锁的就会执行此行，其他的sql会被阻塞住。直到抢占方commit后，执行结束，其他sql立刻去操作，抢占加锁。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM之SpringMVC]]></title>
    <url>%2F2018%2F07%2F25%2FSSM%E4%B9%8BSpringMVC%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM系列之Spring]]></title>
    <url>%2F2018%2F07%2F24%2FSSM%E7%B3%BB%E5%88%97%E4%B9%8BSpring%2F</url>
    <content type="text"><![CDATA[Spring概述Spring的优点： 非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API，也就是说Spring是一个轻量级的框架，松耦合； 依赖注入：DI——Dependency Injection，反转控制(IOC)最经典的实现； 面向切面编程：Aspect Oriented Programming——AOP，IoC与AOP是Spring的核心； 容器：Spring是一个容器，因为它包含并且管理应用对象的生命周期，统一管理JavaBean的生成与销毁的过程，就是Bean的工厂，用的时候可以直接拿到Bean对象； 组件化：Spring实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象。真正的实现了只要配置注解就实现功能的操作，大大加速开发效率； 从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从spring中受益。简单来说，spring就是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架。 注：关于耦合的问题，我这里简单的说一下，耦合指的是我们的业务逻辑代码与框架之间的联系，Spring的低耦合就是我们的代码可以像可插拔似的，与框架之间的联系不会太紧密，当业务发生改变时我们也不必大量的重写我们的代码（只改变相关业务的部分），关于系统耦合的问题，有机会可以写一篇相关的博客。 Spring框架是一个分层架构，由7个定义良好的模块组成。Spring模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式。组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。 我们这里只说一说Spring的核心实现部分IoC与AOP。 IoC概念IoC的设计目的就是为了解耦，控制反转与我们平时获取对象的方式不同，在JavaSE中我们想要获取一个类的对象，一般会直接new一个对象，而在Spring中对象统一管理在IoC容器，通过DI使用对象。控制反转的方式将我们硬编码方式的创建对象的方式改为框架统一管理对象，这就是解耦。 简单的来说：控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法。 IoC在Spring中的实现IOC思想必须基于IoC容器来完成， 而IOC容器在最底层实质上就是一个对象工厂。 在通过IOC容器读取Bean的实例之前，需要先将IOC容器本身实例化。 Spring提供了IOC容器的两种实现方式：①BeanFactory：IOC容器的基本实现，是Spring内部的基础设施，是面向Spring本身的，不是提供给开发人员使用的。②ApplicationContext：BeanFactory的子接口，提供了更多高级特性。面向Spring的使用者，几乎所有场合都使用ApplicationContext而不是底层的BeanFactory。 从IoC容器中获取对象的方式：1234567891011public static void main(String[] args) &#123; //1. 创建Spring IOC 容器对象 ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //2. 从IOC容器对象中获取Person对象 Person person = ctx.getBean(&quot;person&quot;, Person.class); //3. 使用对象 person.sayHello();&#125; 到这里就存在着一些疑问了，我们在配置文件中提供的Bean对象是怎么一步步的到最后被使用的。那么我们就来说说这个完成调用的整个过程。(一) 读取配置文件，找到所有被IoC容器管理的类；(二) 通过反射机制与工厂模式创建Bean对象；(三) Spring IOC容器对bean的生命周期进行管理(构造器，设置属性，初始化方法，调用对象，销毁对象)； 源码分析Spring中的工厂类的实现与继承关系： Spring中Bean对象的创建是典型的工厂模式，这一系列的Bean工厂，也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在Spring中有许多的IOC容器的实现供用户选择和使用。IoC实现：我们的关注点放在第一个BeanFactory中定义了IOC容器的基本功能规范(得到Bean对象的多个重载方法):12345678910111213141516171819202122232425262728293031public interface BeanFactory &#123; // 对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，如果需要得到工厂本身，需要转义 String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;; // 通过字符串得到一个Object类型的Bean对象 Object getBean(String var1) throws BeansException; // 重载方法通过Bean对象名与Bean对象类型获得IoC容器中的Bean对象 &lt;T&gt; T getBean(String var1, Class&lt;T&gt; var2) throws BeansException; // 重载方法通过Bean对象类型获得IoC容器中的Bean对象，当前此方法返回的对象类型不再是Object &lt;T&gt; T getBean(Class&lt;T&gt; var1) throws BeansException; // 重载方法通过Bean对象名与多参数Object列表IoC容器中的Object类型Bean对象 Object getBean(String var1, Object... var2) throws BeansException; // 是否有某个Bean对象 boolean containsBean(String var1); // 是否只在服务器启动时创建一个实例，并且整个项目都只有一个对象 boolean isSingleton(String var1) throws NoSuchBeanDefinitionException; // 是否创建多个实例 boolean isPrototype(String var1) throws NoSuchBeanDefinitionException; // 某个Bean对象是否是某个类型 boolean isTypeMatch(String var1, Class&lt;?&gt; var2) throws NoSuchBeanDefinitionException; // 获取Bean对象的类型 Class&lt;?&gt; getType(String var1) throws NoSuchBeanDefinitionException; // 根据别名检索出原名 String[] getAliases(String var1);&#125; BeanFactory只对IOC容器的基本行为作了定义，根本不关心你的bean是如何定义怎样加载的。正如我们只关心工厂生产什么产品，而不关注它怎么生产的一样。 我们关注的第二个是DefaultListableBeanFactory实现类，该类实现了其上所有的接口方法。代码很多，主要功能是为了区分在Spring内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。ListableBeanFactory接口表示这些Bean是可列表的，而HierarchicalBeanFactory表示的是这些Bean是有继承关系的，也就是每个Bean有可能有父Bean。AutowireCapableBeanFactory接口定义 Bean 的自动装配规则。这四个接口共同定义了Bean的集合、Bean之间的关系、以及Bean行为。 Spring关注工厂怎么生产产品的步骤的实现类有很多，最常使用的就是ApplicationContext，它是Spring提供的一个高级的IoC容器创建对象，它除了能够提供IoC容器的基本功能外，还为用户提供了一些附加服务，这些服务是ApplicationContext接口通过继承获得的。 AOP参考 《spring技术内慕》 https://www.cnblogs.com/ITtangtang/p/3978349.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件的上传与下载]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[文件的上传从本质上来说就是将本地的文件通过I/O流将本地文件复制到服务器的某个文件夹下，下载是一个与它相反的操作，将读取服务器的文件，copy到本地文件存储。所以说上传下载，首先就离不开文件读写与复制。 复制文件Java没有内置的方法可以实现copy，copy操作需要一边读文件一边写到文件中。123456789101112131415161718192021222324252627282930313233343536package com.jeff_code;import java.io.*;public class Main &#123; public static void main(String[] args) throws Exception &#123; File f1 = new File("File/1.avi"); File f2 = new File("File/2.avi"); if(!f2.exists())&#123; f2.createNewFile(); &#125; new FileCopy().copy(f1, f2); &#125;&#125;class FileCopy&#123; void copy(File a, File b) throws Exception &#123; FileInputStream fis = new FileInputStream(a); BufferedInputStream bis = new BufferedInputStream(fis); FileOutputStream fos = new FileOutputStream(b); BufferedOutputStream bos = new BufferedOutputStream(fos); byte[] buffer = new byte[1024]; int len = bis.read(buffer); while (len != -1)&#123; bos.write(buffer, 0, len);// 每次读取数组的实际长度，最后一次长度可不一定是1024，如果只是buffer就会读到多余的字符 len = bis.read(buffer); &#125; bis.close(); bos.close(); fis.close(); fos.close(); &#125;&#125; 这段代码是原地复制，即在当前计算机复制到当前计算机，上传下载的基本原理与其类似，实际中并不实用，操作系统一般都有复制剪切等功能的系统调用，不需要我们实现。 JavaWEB中的上传下载在不使用Spring框架提供的上传下载的情况下，我们实现上传下载还是非常麻烦的一件事，我们一般也不会写这样的上传下载的代码，但是框架实现上传下载的方式与它还是比较相似的。 下载jsp页面123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;download&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 满汉全席-还不是因为你长得不好看：&lt;a href=&quot;download?musicName=还不是因为你长得不好看.mp3&quot;&gt;点击下载&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 下载代码(省略servlet配置)123456789101112131415161718192021222324252627282930313233343536373839404142public class download extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 1. 获取文件的名 String musicName = req.getParameter("musicName"); // 每一个WEB容器共享同一个ServletContext对象 ServletContext application = getServletContext(); // 2. 获取当前文件存储的实际位置 String realPath = application.getRealPath("/WEB-INF/music/"+musicName); // 3. 将文件的后缀名/文件类型传给浏览器 String mimeType = application.getMimeType(musicName);//根据路径的后缀名匹配文件的真实类型 resp.setContentType(mimeType); // 4. 解决乱码问题 String header = req.getHeader("User-Agent"); if(header.contains("Firefox")) &#123; // 火狐单独的解决乱码方式 musicName = "=?utf-8?B?"+new BASE64Encoder() .encode(musicName.getBytes("utf-8"))+"?="; &#125;else &#123; musicName = URLEncoder.encode(musicName, "UTF-8"); &#125; // Content-Disposition字段，激活文件下载对话框，它的文件名框自动填充了头中指定的文件名 resp.setHeader("Content-Disposition", "attachment;filename="+musicName); FileInputStream fis = new FileInputStream(realPath); // 通过reponse对象的输出流将文件写给浏览器 ServletOutputStream sos = resp.getOutputStream(); int len; byte[] bs = new byte[1024]; while((len=fis.read(bs))!=-1) &#123; sos.write(bs, 0, len); &#125; //文件传输完毕 sos.close(); fis.close(); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 所以下载的主要操作就是将文件文件流写到浏览器，浏览器完成下载（copy的操作）。 上传1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.jeff_code;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadBase;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.util.List;import java.util.UUID;/** * 上传需要导入使用第三方工具进行解析： IOUtils.jar： 用来处理流的 ， FileUpload.jar: 解析处理后流中的多部件内容 */public class upload extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、创建解析工厂对象 DiskFileItemFactory factory = new DiskFileItemFactory(); //2、通过解析工厂 创建Request解析器对象 ServletFileUpload fileUpload = new ServletFileUpload(factory); //3、通过解析器对象处理请求对象中的流数据 try &#123; //FileItem: 文件上传时，一个fileitem代表一个表单项数据 List&lt;FileItem&gt; list = fileUpload.parseRequest(req); //4、遍历多部件 for (FileItem fileItem : list) &#123; //4.1 判断正在遍历的fileitem是文本表单项还是文件表单项 if(fileItem.isFormField()) &#123;//isFormField 判断是不是一个文本表单项，如果是返回true String fieldName = fileItem.getFieldName(); String value = fileItem.getString("UTF-8"); &#125;else &#123; //文件表单项 //先判断上传的文件的大小，如果长度为0，不用保存 if(fileItem.getSize()&gt;0) &#123; String fieldName = fileItem.getFieldName(); // 文件表单项不会读取value值的String value = fileItem.getString("UTF-8"); //将用户上传的文件保存到服务器内部 String fileName = fileItem.getName();//上传的文件名 //在服务器内部创建一个文件夹用来保存上传的文件 ServletContext application = getServletContext(); //获取upload文件夹的真实路径 String realPath = application.getRealPath("/upload"); //如果文件夹不存在则创建 File uploadFile = new File(realPath); if(!uploadFile.exists()) &#123; uploadFile.mkdirs(); &#125; //保存图片时，需要保证图片名唯一 否则后上传的会覆盖之前的 fileName = System.currentTimeMillis()+"_"+UUID.randomUUID().toString().replace("-", "")+"_"+fileName; //文件夹已存在，将图片可以写入文件夹中 File saveFile = new File(uploadFile, fileName);//将要保存的图片名和保存文件的路径创建一个新的文件 fileItem.write(saveFile);//将用户上传的图片内容通过刘写入到saveFile中 &#125; &#125; &#125; resp.getWriter().write("上传成功"); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 当然这是我们自己实现的上传功能，当然实际生产我们而不可能使用这种方式，Spring为我们提供了上与下载功能，这使得我们开发精力更多的放在业务上，而不是繁杂的代码上。 Spring的上传下载功能配置文件需要进行参数配置12345678910&lt;!-- 配置上传 组件 注意: id必须指定成 multipartResolver--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 指定成与 上传表单所在的页面的编码一致 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;&gt;&lt;/property&gt; &lt;!-- 设置最大的上传文件大小 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 下载123456789101112131415161718192021222324252627@RequestMapping(&quot;/download&quot;)public ResponseEntity&lt;byte[]&gt; download(HttpSession session ) throws Exception&#123; byte[] images = null ; //将要下载的图片进行读取，存储到字节数据中 ServletContext sc = session.getServletContext(); //获取要下载的文件的输入流 InputStream in = sc.getResourceAsStream(&quot;download&quot;+File.separator+&quot;xg.jpg&quot;); // in.available()流中读取到的最大长度 images = new byte[in.available()]; //将字节读取到数组中 in.read(images); //构造ResponseEntity HttpHeaders headers = new HttpHeaders(); //设置响应头信息 告诉浏览器数据格式，以及如何进行处理. headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=xg.jpg&quot;); HttpStatus statusCode = HttpStatus.OK; // 200 ResponseEntity&lt;byte []&gt; re= new ResponseEntity&lt;byte[]&gt;(images, headers, statusCode); return re ; &#125; 上传配置上传信息：12345678910&lt;!-- 配置上传 组件 注意: id必须指定成 multipartResolver--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 指定成与 上传表单所在的页面的编码一致 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;&gt;&lt;/property&gt; &lt;!-- 设置最大的上传文件大小 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 上传：123456789101112131415161718@RequestMapping(&quot;/upload&quot;)public String testFileUpload(@RequestParam(&quot;uploadFile&quot;)MultipartFile uploadFile, @RequestParam(&quot;desc&quot;)String desc,HttpSession session ) throws Exception&#123; System.out.println(&quot;desc:&quot; +desc ); //将上传过来的文件 保存到 upload文件夹下。 ServletContext sc = session.getServletContext(); //获取上传文件的名字 String fileName = uploadFile.getOriginalFilename(); //获取upload文件夹的真实路径 String realPath = sc.getRealPath(&quot;upload&quot;); //通过File描述目标文件 File targetFile = new File(realPath+File.separator + fileName ); uploadFile.transferTo(targetFile); return &quot;success&quot;;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[有关于代理模式我之前的简单设计模式中也有提到过，当时说得是静态代理模式，动态代理与之实现的情景比较相似，可以继承实现接口、类的方式更为通用。代理设计模式的原理：使用一个代理对象将目标对象包装起来，然后用该代理对象”取代”原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 coding关于动态代理，大的方面可以分为两部分：代理对象与原始对象。我们一JDK的动态代理为基础来讲解，JDK动态代理需要目标对象有接口类需要实现。 原始对象123456789101112package com.jeff_code;public interface ArithmeticCal &#123; public int add(int i, int j); public int sub(int i, int j); public int mul(int i, int j); public int div(int i, int j);&#125; 具体实现：12345678910111213141516171819202122232425package com.jeff_code.ArithmeticCalImpl;import com.jeff_code.ArithmeticCal;public class ArithmeticCalImpl implements ArithmeticCal &#123; @Override public int add(int i, int j) &#123; return i + j; &#125; @Override public int sub(int i, int j) &#123; return i - j; &#125; @Override public int mul(int i, int j) &#123; return i * j; &#125; @Override public int div(int i, int j) &#123; return i / j; &#125;&#125; 要给原始对象扩展功能，关闭修改。使用动态代理再合适不过，这里就简单添加一个打印日志的功能。 代理对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.jeff_code.DynamicProxy;import com.jeff_code.ArithmeticCal;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;/** * 这个类不是代理对象，代理对象在这个类中获取到，Proxy.newProxyInstance */public class DynamicProxy &#123; // 这是原始对象，作为代理对象的成员变量 private ArithmeticCal target ; public DynamicProxy(ArithmeticCal target)&#123; this.target = target; &#125; // 获取代理对象的方法 public Object getProxy()&#123; Object proxy = null; ClassLoader loader = target.getClass().getClassLoader(); Class[] interfaces = target.getClass().getInterfaces(); proxy = Proxy.newProxyInstance(loader, interfaces,new InvocationHandler() &#123; /** * Object proxy : 代理对象. * * Method method : 正在被调用的方法 * * Object [] args: 方法的参数 * */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //获取方法的名字 String methodName = method.getName(); //日志 System.out.println("Proxy==&gt;The method " + methodName + " begin with : " + Arrays.asList(args)); // 执行 真正的目标方法: + - * / Object result = method.invoke(target, args); //日志 System.out.println("Proxy==&gt;The method " + methodName +" ends with : " + result ); return result ; &#125; &#125;); return proxy; &#125;&#125; Proxy类是所有动态代理类的父类，主要就是生成代理类或者直接生成代理对象。返回代理类的Class对象：1public static Class&lt;?&gt; getProxyClass(ClassLoader loader,Class&lt;?&gt;... interfaces) 返回代理类实例对象：1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 我们这里就直接使用Proxy类生成一个代理类实例对象。newProxyInstance中的三个参数分别是原始对象的类加载器，原始对象类的继承接口们以及InvocationHandler的匿名内部类。匿名内部类中执行代理对象操作原始对象的方法，并且此方法除了代理对象的方法还增加额外的日志功能。这个过程就是动态的生成加载出一个代理类对象(要使用到类加载器加载出这个类，这个代理类要和原始类有一样的接口，这样调用这个代理类就和使用原始类感觉上没差了)。 那么我们的动态代理类中进行了哪些操作呢？我们使用伪代码来展示一下细节部分。123456789101112131415161718192021222324class $Proxy0000 extends Proxy implements ArithmeticCalculator&#123; protected $Proxy0000(InvocationHandler h) &#123; super(h); &#125; @Override public int add(int i, int j) &#123; //return super.h.invoke(this,&quot;add&quot;,[i,j]); return 0; &#125; @Override public int sub(int i, int j) &#123;return 0;&#125; @Override public int mul(int i, int j) &#123;return 0;&#125; @Override public int div(int i, int j) &#123;return 0;&#125; &#125; 这个代理类就是实现我我们生成动态代理对象的类，这个类继承了代理类的父类Proxy然后实现了原始类的所有的方法。1private Proxy() &#123;&#125; Proxy中的无参构造器是私有的，所以子类是不可以直接调用他的无参构造的，所以我们需要给子类增加一个构造器，调用父类的有参构造器。1234protected Proxy(InvocationHandler h) &#123; Objects.requireNonNull(h); this.h = h;&#125; 父类的有参构造器都需要一个参数就是InvocationHandler对象，所以我们的子类调用父类的有参构造器也需要相应的传入需要的参数。1return super.h.invoke(this,&quot;add&quot;,[i,j]); 此时我们super.h的参数就是我们传入的匿名内部类的InvocationHandler(子类的有参构造器传入的，父类的成员变量在父类构造器中被赋值，所以这三个h都是用同一个InvocationHandler对象，即我们传入的InvocationHandler对象)，我们的实现类中(伪代码)，每一个父类的接口都实现了并且执行了invoke方法。1234567891011121314151617181920212223// 使用getClass实现 Class proxyClass = Proxy.getProxyClass(loader, interfaces); //获取到代理类中的构造器 Constructor con = proxyClass.getDeclaredConstructor(InvocationHandler.class); proxy = con.newInstance(new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //获取方法的名字 String methodName = method.getName(); //日志 System.out.println(&quot;Proxy2==&gt;The method &quot; + methodName + &quot; begin with : &quot; + Arrays.asList(args)); // 执行 真正的目标方法: + - * / Object result = method.invoke(target, args); //日志 System.out.println(&quot;Proxy2==&gt;The method &quot; + methodName +&quot; ends with : &quot; + result ); return result ; &#125; &#125;); 我们使用反编译工具将动态生成的代理的对象的.class代码转换成.java代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.sun.proxy;import com.jeff_code.ArithmeticCal;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements ArithmeticCal &#123; private static Method m1; private static Method m2; private static Method m5; private static Method m3; private static Method m4; private static Method m6; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int mul(int var1, int var2) throws &#123; try &#123; return (Integer)super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;); &#125; catch (RuntimeException | Error var4) &#123; throw var4; &#125; catch (Throwable var5) &#123; throw new UndeclaredThrowableException(var5); &#125; &#125; public final int add(int var1, int var2) throws &#123; try &#123; return (Integer)super.h.invoke(this, m3, new Object[]&#123;var1, var2&#125;); &#125; catch (RuntimeException | Error var4) &#123; throw var4; &#125; catch (Throwable var5) &#123; throw new UndeclaredThrowableException(var5); &#125; &#125; public final int sub(int var1, int var2) throws &#123; try &#123; return (Integer)super.h.invoke(this, m4, new Object[]&#123;var1, var2&#125;); &#125; catch (RuntimeException | Error var4) &#123; throw var4; &#125; catch (Throwable var5) &#123; throw new UndeclaredThrowableException(var5); &#125; &#125; public final int div(int var1, int var2) throws &#123; try &#123; return (Integer)super.h.invoke(this, m6, new Object[]&#123;var1, var2&#125;); &#125; catch (RuntimeException | Error var4) &#123; throw var4; &#125; catch (Throwable var5) &#123; throw new UndeclaredThrowableException(var5); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;)); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;); m5 = Class.forName(&quot;com.jeff_code.ArithmeticCal&quot;).getMethod(&quot;mul&quot;, Integer.TYPE, Integer.TYPE); m3 = Class.forName(&quot;com.jeff_code.ArithmeticCal&quot;).getMethod(&quot;add&quot;, Integer.TYPE, Integer.TYPE); m4 = Class.forName(&quot;com.jeff_code.ArithmeticCal&quot;).getMethod(&quot;sub&quot;, Integer.TYPE, Integer.TYPE); m6 = Class.forName(&quot;com.jeff_code.ArithmeticCal&quot;).getMethod(&quot;div&quot;, Integer.TYPE, Integer.TYPE); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 与我们伪代码实现的方式思路是一致的，这段代码是我们实现这个过程的细节，我们实际生成动态代理对象的时候使用的就是Proxy的getProxyClass()或者newProxyInstance()即可，底层由Proxy父类实现。 上述过程是基于接口的JDK动态代理。 Spring的AOP编程Spring的AOP编程就是基于动态代理实现的。简单来说动态代理分为两类，基于接口或者基于继承，当代理的原始对象实现了接口的时候，AOP会根据实际情况实现基于接口的动态代理，当原始对象没有实现接口的时候，相应的Spring的AOP会实现一个而基于继承的动态代理类。 AOP的简介 AOP(Aspect-Oriented Programming，面向切面编程)：是一种新的方法论，是对传统 OOP(Object-Oriented Programming，面向对象编程)的补充。 AOP编程操作的主要对象是切面(aspect)，而切面模块化横切关注点。 在应用AOP编程时，仍然需要定义公共功能，但可以明确的定义这个功能应用在哪里，以什么方式应用，并且不必修改受影响的类。这样一来横切关注点就被模块化到特殊的类里——这样的类我们通常称之为“切面”。 每个事物逻辑位于一个位置，代码不分散，便于维护和升级同时业务模块更简洁，只包含核心业务代码。 关于Spring的AOP编程，有时间再细谈，其主要的实现就是基于动态代理实现的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018夏季减肥大会伊始]]></title>
    <url>%2F2018%2F07%2F12%2F2018%E5%A4%8F%E5%AD%A3%E5%87%8F%E8%82%A5%E5%A4%A7%E4%BC%9A%E4%BC%8A%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[记录一下今年锻炼的战绩，过年前是119*500g。年后去了趟上海涨了20500g。后来起起伏伏，最近要开始抽时间控制一下了，正所谓七月不减肥，八月徒伤悲。7.12减脂大会正式开幕。记不得过了几天了，今天是180804体重掉下130`500g 了,现在是129.6*`500g，加油，8月你是最胖的。20180903今天2分钟32秒50个，再接再厉。 20180902今天4分钟37秒63个，再接再厉。 20180831今天4分钟56秒60个，再接再厉。 20180829今天5分钟14秒60个，再接再厉。 20180828今天4分钟36秒51个，再接再厉。 20180827今天6分钟11秒51个，再接再厉。 20180826今天八分钟60个，再接再厉。 20180825过了一段时间，之间做一些有氧的肌肉锻炼，现在勉强做一些俯卧撑。今天在7分钟做了50个俯卧撑，刚开始只能做四五个，后面会继续锻炼，争取完成100天，每天100个俯卧撑。 day16,17 skip 0height： 132.2*500g学习第一。。。推推轮子，跳绳暂时停一下 day16,17 skip 0学习第一。。。推推轮子，跳绳暂时停一下 day15 skip 0height： 132.4*500g忙休一天 day15 skip 2250次height： 131.4*500g day14 skip 2250次height： 132.5*500g day13 skip 0height： 134.1*500g下雨，休息。 day12 skip 0height： 135.9*500g下雨，休息。 day11 skip 2234次height： 133.5*500g推推轮子，一周赶超lb，fighting，吃了很多，返璞归真。 day10 skip n次，n&gt;2000height： 134.2*500g推推轮子，一周赶超lb，fighting，吃了很多，返璞归真。 day09 zeroheight： 133.7*500g推推轮子吧，突如其来的大雨。 day08 skip 2156次height： 131.9*500g推推轮子，一周赶超lb，fighting。 day07 skip 2222次height： 133.0*500g推推轮子，一周赶超lb，fighting。 day06 zeroheight： 135.9*500g下大雨，继续鸽咯。 day05 zeroheight： 136.1*500g下大雨，继续鸽咯。 day04 zeroheight： 134.6*500g继续放鸽子，好久不运动现在已经推不动轮子了。 day03 skip 2254次height： 133.8*500g day02 zero第二天就放鸽子了。。。不太妙啊。 day01 skip 2101次init体重：133.8*500g]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP(含EL表达式)]]></title>
    <url>%2F2018%2F07%2F03%2FJSP%2F</url>
    <content type="text"><![CDATA[什么是JSPJSP全称Java Server Pages，指运行在java服务器中的页面，也就是在我们JavaWeb中的动态页面，JSP本质就是一个Servlet。 JSP文件的组成JSP的主要构成有HTML网页代码、Java代码片段、JSP标签几部分组成，后缀是.jsp。 Tips：用户访问jsp页面时，服务器会将jsp页面翻译为Servlet.java 存到工作空间的tomcat的work文件夹内，再将其编译为class文件，处理用户请求时，其实是服务器调用了翻译后的servlet的生命周期方法处理的请求（_jspService方法）。翻译后的类又继承了HttpServlet[HttpJspBase extends HttpServlet]（HttpJspBase的三大周期函数的封装为_jspInit，_jspDestroy和_jspService），所有访问.jsp文件的请求都被服务器处理了，配置文件在tomcat配置文件的web.xml里。 服务器将jsp翻译成servlet的规则： html内容[标签+html注释]:原封不动作为out.writer()的字符串参数写入到响应体中; jsp脚本片段[java代码，相当于在service方法内写java代码]:原封不动按顺序拷贝到翻译后的service方法中; jsp表达式[变量 ， 相当于将变量的值交给out.print()使用]:作为out.print()的参数将变量的值写入到响应体中。Why JSPhtml写的页面没法动态显示，也不能写入逻辑代码，控制循环语句等，非常的死板，一些功能也不好实现。servlet倒是可以写逻辑代码，也能在response中返回HTML页面，但是对于复杂页面，写起来就非常的复杂，所以服务器会将一种特定语法的文件转译成Java的servlet，这种文件语法更简单，它本质就是servlet，这种特定语法的文件就是jsp文件和语法。1234567891011121314151617response.setContentType(&quot;text/html;charset=UTF-8&quot;);//1、获取用户提交的username参数String username = request.getParameter(&quot;username&quot;);//2、处理业务逻辑//3、给用户响应一个动态页面，在页面中显示用户名PrintWriter writer = response.getWriter();writer.write(&quot;&lt;h1 style=&apos;color:red;&apos;&gt;&quot;);if(username!=null) &#123; writer.write(&quot;您的用户名是：&quot;); writer.write(username);&#125;else &#123; writer.write(&quot;游客您好，您还没有登录&quot;);&#125;writer.write(&quot;&lt;/h1&gt;&quot;); 此为servlet动态生成一个HTML文件的操作(静态页面没有变量无法动态修改username的值动态显示)，只是返回一个H1标签就可以看出其繁琐程度。JSP就是特定语法结构的servlet，用页面开发servlet(服务器自行转换为Java代码)，所以浏览器本身是不可以直接打开JSP文件的。 JSP的优势与HTML相比：JSP相比HTML页面来说，最直观的功能就是可以在页面中使用变量，这些变量一般是从域对象中获取。有了变量我们的页面就可以动态的显示信息。与Servlet相比：相比于一般的Servlet，JSP更加善于处理显示页面，而Servlet跟擅长处理业务逻辑，两种技术各有专长，所以一般我们会将Servlet和JSP结合使用，Servlet负责业务，JSP负责显示。 如何使用JSP123456789101112 &lt;%-- 这是一个HTML标签 --%&gt;&lt;h3&gt;我的第一个动态页面&lt;/h3&gt; &lt;%--这是一个jsp脚本片段(Java代码)--%&gt;&lt;% //java注释 int a = 1; System.out.println(&quot;.........&quot;);%&gt;&lt;%--这是一个jsp表达式--%&gt;&lt;%=a %&gt;&lt;%=new Date() %&gt; tomcat服务器将这段jsp代码转化成Java的servlet： JSP的指令pagepage指令的作用是控制页面的设置。12345678910111213&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;!-- page指令 language 页面支持的语言类型 只有一个值java(此前设计时认为可能会扩展到多门语言，但是此时只有一种语言) contentType 相当于response.setContenType(); pageEncoding jsp页面被jsp引擎翻译为Servlet时使用的编码，默认使用ISO8859-1，国际化以后都使用utf-8 import 导包 &lt;%--基本上使用不到的属性 --%&gt; errorPage 指定错误页面，当前页面发生错误后会跳转到错误页面 isErrorPage 设置当前页面是否为错误页面，默认false不是 isELIgnored 是否忽略EL表达式，默认false不忽略 --&gt; includeinclude指令是静态包含指令，可以将其他页面静态导入到当前页面中，静态导入的意思就是原封不动将目标页面的代码拷贝到当前页面中，在早期版本修改被导入的页面服务器不会捕捉，tomcat7以后会自动修改。&lt;%@ include file=&quot;/helloworld.jsp&quot; %&gt;file指向的绝对路径由服务器解析，静态导入的文件是不会被服务器编译成class文件的，相当于编译的时候将include文件直接覆盖原文件的include语句然后tomcat服务器只编译这一个文件即可。 taglibtaglib指令是标签库引入指令。 JSP动作标签为了简化开发，jsp将某些功能java代码封装成了类似标签的样式，其实本质仍然是java代码，JSP动作标签与HTML标签不同，HTML标签由浏览器来解析，而JSP动作标签需要服务器（Tomcat）来运行。转发动作标签：&lt;jsp:forward &gt;&lt;/jsp:forward&gt;;page转发路径：&lt;jsp:forward page=&quot;/helloworld.jsp&quot;&gt;&lt;/jsp:forward&gt; --%&gt;动态包含标签：可以将目标页面动态包含到当前页面中,目标文件和当前文件都会被编译，效率低一般不会使用。&lt;jsp:include page=&quot;/helloworld.jsp&quot;&gt;&lt;/jsp:include&gt; JSP九大内置对象因为jsp页面在翻译后，jsp脚本片段和表达式会被翻译到service方法内（最终调用生命周期方法service），所以在表达式和脚本片段中可以直接使用翻译后的service方法中声明的9个变量。因为这九个变量是声明在service方法里的，所以我们可以在jsp的表达式和脚本片段中使用这9大内置对象。 pageContext类型是PageContext，代表了jsp页面的上下文对象（jsp当前页的共享信息，共享对象），作用是在当前页面的范围内共享数据，每个页面由自己唯一的一个页面上下文对象，jsp页面特有，它可以获取jsp的其他8个隐含对象。 request类型是HttpServletRequest，代表了请求对象/请求域，作用是获取请求报文数据，转发，在一次请求中共享数据(域对象： 转发 )。 session类型是HttpSession，代表了一次会话，浏览器打开第一次访问服务器开始到浏览器关闭的一次过程就是一次会话，作用： 在一次会话的过程中共享数据(域对象)。 application类型是ServletContext，作用是在整个项目范围内共享数据，一个项目对应唯一的一个全局上下文对象，存在于服务器关闭或重启前。 这四个内置对象也是jsp的四大域对象。 response类型是HttpServletResponse，代表了响应对象，作用是设置响应体、响应头、重定向。 out类型是JspWriter，代表了响应体的输出流，作用是向响应体中写数据，service中将jsp翻译成servlet就是使用的这个对象。 config类型是ServletConfig，代表了翻译后的servlet的配置文件对象。 page类型是Object，代表了翻译后的servlet的实例， 使用Object类型接收。 exception只有当jsp页面为错误页面时才有exception对象，将page设置为isErrorPage=”true” ， 错误页面中可以获取其他页面的错误信息，类型是Throwable最大的异常错误类，代表了上个页面发生的错误异常，作用是获取上个页面的错误异常信息，根据错误给用户提示。 除了四个域对象使用的比较多，其他的域对象基本上很少使用，exception在当前的生产已经不适用了。关于为什么一些技术不使用，过时了还是要看，因为在一些老的项目里时常会遇到一些奇特的代码，而当时的技术局限，很可能使用的就是我们现在所谓的过时的技术，过时的代码，所以还是需要有印象，在遇到的时候能解决问题。 JSP四大域对象Java域对象底层就是Map，域对象都有的方法： 向域中存储数据的方法： void setAttribute(String key ,Object value); 从域中获取数据的方法：Object getAttribute(String key); 移除域中指定属性的方法：void removeAttribute(String key);四大域对象作用是能够在web项目的不同资源中共享数据，使用时，必须先存储再获取。Expression Language表达式EL表达式是JSP内置的表达式语言（不可以在HTML和servlet中使用），用以访问页面的上下文以及不同作用域中的对象 ，取得对象属性的值，或执行简单的运算或判断操作。EL在得到某个数据时，会自动进行数据类型的转换。EL表达式用于代替JSP表达式(&lt;%= %&gt;)在页面中做输出操作。EL表达式仅仅用来读取数据，而不能对数据进行修改，当读取的数据是null的时候EL表达式会自动忽略，即不输出。语法格式1$&#123;&#125; EL基本使用全域查询1$&#123;key &#125; 默认全域查询key对应的值，从最小域到最大域遍历查询，找到则返回停止遍历。123456789101112131415161718// 实现思路Object val = null;val = pageContext.getAttribute(&quot;key&quot;);if(val==null)&#123; //page域中没有获取到 val = request.getAttribute(&quot;key&quot;);&#125;if(val==null)&#123; //request域中没有获取到 val = session.getAttribute(&quot;key&quot;);&#125;if(val==null)&#123; //session域中没有获取到 val = application.getAttribute(&quot;key&quot;);&#125;if(val==null)&#123; val=&quot;&quot;;&#125; 指定域获取属性pageScope,requestScope,sessionScope,applicationScope;域对象的类型是Map。1$&#123;指定域Scope.key &#125; 域中的对象的属性1$&#123;user.属性名&#125; EL会自动调用user对象的get属性名方法(“get” + 属性名首字母大写)，不论这个对象里有没有这个属性名，只要能找到”get” + 属性名首字母大写属性方法即可，此属性方法必须有返回值，与其他的get方法一致。 域中的list指定下标的元素1$&#123;list[index]&#125; 域中的map指定键对应的值123456$&#123;map.key &#125;// map中有特殊键时，键有特殊符号，key为t2-1时，会被EL表达式认为是map.t2-1,即(map.t2)-1，得到答案是-1，不是它对应的值$&#123;map[&apos;key&apos;]&#125; // 例如：$&#123;map[&apos;t2-1&apos;]&#125; EL的十一个内置对象 四个域对象：pageScope、requestScope、sessionScope、applicationScope； pageContext：用来获取jsp的其他8个隐含对象，等于EL一个内置对象就包含了jsp的九个内置对象； param：获取请求中的参数，类型是Map，${param.name}； paramValues:获取请求参数的多个值，类型是：Map，${paramValues.key[index] }； header：请求头数据，类型是：Map，${header.name }或${header[&#39;User-Agent&#39;] }； headerValues：一个请求头的键对应多个值，类型是：Map,基本上用不上； initParam：翻译后的Servlet配置的初始化参数，类型是：Map&lt;String,String&gt;，基本上用不上； cookie：获取浏览器请求报文中的Cookie，类型是：Map，使用内置对象获取当前项目的地址：1$&#123;pageContext.request.scheme &#125;://$&#123;pageContext.request.serverName &#125;:$&#123;pageContext.request.serverPort &#125;$&#123;pageContext.request.contextPath &#125;/ EL支持运算符EL表达式支持一般的运算符，且+不表示拼接，也可以使用三元表达式等运算符。比较特殊的是empty运算符，empty判断集合或字符串是否为空，如果集合字符串==null或者长度为0，那么empty认为是空，即数组、集合、字符串等可以直接判断长度的为空直接会被省略，但是自定义的类没有给定length，size等判断长度的方法，则不会被当作是空。 JSP Standard Tag LibraryEL表达式配合JSTL的流程控制就是取代原生JSP的，原生JSP的if，for写起来非常繁琐，而且无法调试，页面一庞大就很难找到页面的bug，用起来非常的不人性化，所以使用JSTL替代JSP脚本片段，就是将JSP的脚本片段进行封装，得以使用jsp标签形式使用Java代码，将代码量大大减少，层级结构更清晰，所以调试起来就更简单了。 常用的JSTL标签库使用前先导入jar包，然后在项目的头部导入，使用taglib指令，uri属性是指向引入标签库的唯一标志，prefix属性是标签库在页面中使用时的前缀，例如：&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;。 核心标签库core1234567 &lt;% request.setAttribute(&quot;address&quot;, &quot;家里&quot;); request.setAttribute(&quot;code&quot;,&quot;&lt;script&gt;alert(&apos;hehe&apos;)&lt;/script&gt;&quot;); %&gt;&lt;c:out value=&quot;$&#123;address &#125;&quot; default=&quot;未知&quot;&gt;&lt;/c:out&gt;&lt;%-- $&#123;code &#125; --%&gt;&lt;c:out value=&quot;$&#123;code &#125;&quot; escapeXml=&quot;true&quot;&gt;&lt;/c:out&gt; &lt;c:out &gt;&lt;/c:out&gt;是标签输出，value是输出的值，可以使用EL表达式，default可以设置默认值，可以防止XSS攻击（不转换XML格式）。 1234&lt;c:set scope=&quot;page&quot; var=&quot;uname&quot; value=&quot;laowang1&quot;&gt;&lt;/c:set&gt;&lt;c:set scope=&quot;request&quot; var=&quot;uname&quot; value=&quot;laowang2&quot;&gt;&lt;/c:set&gt;&lt;c:set scope=&quot;session&quot; var=&quot;uname&quot; value=&quot;laowang3&quot;&gt;&lt;/c:set&gt;&lt;c:set scope=&quot;application&quot; var=&quot;uname&quot; value=&quot;laowang4&quot;&gt;&lt;/c:set&gt; &lt;c:set &gt;&lt;/c:set&gt;向域中设置值，scope设置到哪个域中，默认设置到page域，var设置的属性名，value设置的属性值。1&lt;c:remove scope=&quot;session&quot; var=&quot;uname&quot;/&gt; &lt;c:remove /&gt;移除域中的值，scope指出移除哪个值，var指定移除的属性名，默认移除所有域中var对应的属性。 123&lt;c:if test=&quot;$&#123;param.age&gt;=18 &#125;&quot;&gt; &lt;h2&gt;你成年了....&lt;/h2&gt;&lt;/c:if&gt; &lt;c:if “&gt;&lt;/c:if&gt;语句就是if条件判断语句，只有if没有else部分，当条件比较多的时候也不使用它，因为多个if分支执行的时候都会被判断一遍(没有else)，效率低。 123456789101112131415161718192021&lt;c:choose&gt; &lt;c:when test=&quot;$&#123;param.score&gt;=90 &#125;&quot;&gt; &lt;h3&gt;恭喜你，prefect...&lt;/h3&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;param.score&gt;=80 &#125;&quot;&gt; &lt;h3&gt;恭喜你，考的不错...&lt;/h3&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;param.score&gt;=60 &#125;&quot;&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;param.score&gt;=70 &#125;&quot;&gt; &lt;h3&gt;恭喜你，比60高了...&lt;/h3&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;h3&gt;恭喜你，及格万岁...&lt;/h3&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;h3&gt;恭喜你，wandan了...&lt;/h3&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; c:choose:创建一个if-else语句结构，c:when相当于if或else if，test属性为语句执行的条件，c:otherwise相当于else。 choose中可以有多个when子语句，语句之间有互斥关系； 一般最多有一个otherwise(不是绝对的)； choose中只能有when和otherwise子语句(这是绝对的)，在choose中子语句内嵌套if-else结构 ，必须将when和otherwise写在choose标签内； 条件之间有包含关系，条件范围小写在上面(switch case一致)； 1234// 遍历数组 &lt;c:forEach begin=&quot;1&quot; end=&quot;5&quot; var=&quot;index&quot; step=&quot;2&quot;&gt; &lt;a href=&quot;PageServlet?pageNumber=$&#123;index &#125;&quot;&gt;$&#123;index &#125;&lt;/a&gt; &lt;/c:forEach&gt; &lt;c:forEach &gt;&lt;/c:forEach&gt;遍历，begin起始，end结束，var自动会将正在遍历的索引值存到pageContext域中，var的值就是属性名，step步进。1234// 遍历List集合 &lt;c:forEach items=&quot;$&#123;list &#125;&quot; var=&quot;item&quot;&gt; &lt;h4&gt;呵呵-- $&#123;pageScope.item &#125;&lt;/h4&gt; &lt;/c:forEach&gt; items属性是要遍历的集合，一般通过EL表达式取出设置给标签使用，标签会自动根据集合元素的个数进行遍历。var属性是标签自动会将每次遍历到的元素存到pageContext域中，var的值就是属性名，标签执行完毕后自动会将域中存的遍历数据移除。12345// 遍历map集合 &lt;c:forEach items=&quot;$&#123;requestScope.map &#125;&quot; var=&quot;item&quot; varStatus=&quot;vs&quot;&gt; $&#123;item &#125;--&gt; $&#123;item.key &#125;--&gt;$&#123;item.value &#125;&lt;br/&gt; 遍历状态： $&#123;vs.current &#125;--&gt;$&#123;vs.index &#125;--&gt;$&#123;vs.count &#125;--&gt;$&#123;vs.first &#125;--&gt;$&#123;vs.last &#125;&lt;br/&gt; &lt;/c:forEach&gt; ${item }取出kv值，${item.key }只取key，${item.value }只取value。varStatus指定变量名，将遍历状态的对象存到pageContext域中，开始时都会创建一个状态对象，每次遍历都会更新状态值，即当前遍历元素的索引，当前已经遍历了几个元素，当前正在遍历的元素，当前遍历的是不是第一个，是不是最后一个。 1&lt;c:redirect url=&quot;/jstl01.jsp&quot;&gt;&lt;/c:redirect&gt; &lt;c:redirect &gt;&lt;/c:redirect&gt;重定向，绝对路径由服务器解析。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet与HttpServlet]]></title>
    <url>%2F2018%2F07%2F02%2Fservlet%2F</url>
    <content type="text"><![CDATA[Servlet是一门开发动态web资源的技术。Sun公司在其API中提供了一个Servlet接口，我们写一个实现此接口的类，在类中完成与Dao层交互数据并渲染在页面后返回，将这个类部署到web服务器上，那么当请求访问这个资源时这个类只是处理返回页面的逻辑，隐藏了与dao层交互的相关信息，我们称这个类叫做Servlet。12345678910111213141516// Servlet接口源码package javax.servlet;import java.io.IOException;public interface Servlet &#123; void init(ServletConfig var1) throws ServletException; ServletConfig getServletConfig(); void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; String getServletInfo(); void destroy();&#125; 这个接口的实现方法只有五个，但是囊括了初始化，配置信息，服务运行，销毁等整个过程的核心方法。init():第一次访问创建对象后立即调用完成初始化操作,根据初始化的执行顺序，他可以用来获取数据库连接参数、设置共享数据等，它如何获取到参数和设置共享数据的呢，主要与他的形参ServletConfig有关，这个config里面可以getServletName获取servlet的名称，getServletContext获取全局唯一的共享对象ServletContext，getInitParameter获取到web.xml的配置文件中的配置的参数；getServletConfig获取servletConfig对象，这也是一个接口，一会说，他能获取到servletContext对象；service处理业务逻辑的方法；getServletInfo获取servlet信息的方法；destroy是servlet销毁方法。123456789public interface ServletConfig &#123; String getServletName(); ServletContext getServletContext(); String getInitParameter(String var1); Enumeration&lt;String&gt; getInitParameterNames();&#125; getServletName获取servlet别名；getServletContext获取servlet的共享对象servletContext；getInitParameter获取到配置中的配置信息；getInitParameterNames是一个类似迭代器的接口，用于获取所有的配置文件中的参数名；123456public interface Enumeration&lt;E&gt; &#123; boolean hasMoreElements(); E nextElement();&#125; 12345678public void init(ServletConfig servletConfig) throws ServletException &#123; Enumeration&lt;String&gt; initParameterNames = servletConfig.getInitParameterNames(); while (initParameterNames.hasMoreElements())&#123; // 迭代获取项目的配置参数 System.out.println(&quot;配置参数&quot; + initParameterNames.nextElement()); &#125;&#125; 运行流程 写一个demo我们将项目部署在tomcat的web容器里，首先我们需要在项目中导入tomcat的环境。 然后我们要配置web.xml123456789101112131415161718 &lt;!-- 配置Servlet --&gt; &lt;!--1、Servlet的全类名 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.jeff_code.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt;&lt;!--2、配置Servlet的访问路径：给Servlet映射一个虚拟的url访问地址 浏览器不能运行java程序 静态页面不能动态的处理请求 - 映射地址必须以/开头， 后面跟任意的字符串 - 相当于将Servlet映射的访问路径是：http://localhost:8080/项目名/abc 将Servlet映射到了根目录下，可以在项目路径下直接访问，访问时代码由服务器管理执行 --&gt; &lt;!-- 3、在两个Servlet的配置标签中加入一个Servlet-name值，用来将url地址和servlet全类名关联 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/abc&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; /abc是一个虚拟的路径，路径的虚拟地址是在web发布文件夹下的。当用户在浏览器输入http://localhost:8080/abc时，当前TomCat发布的web文件夹下并没有一个真实存在的abc文件，此时会去web.xml配置文件下找，匹配到一个url-pattern，对应的全类名指定一个Java类com.jeff_code.ServletDemo1，Java会查找有没有这样一个Servlet类实例对象已经生成，如果没有则会调用构造函数和init()方法生成实例对象，根据实例对象调用service方法，然后一直执行service中的逻辑返回给浏览器一个页面（跳转或者转发）。123456789101112131415161718192021222324252627282930313233343536373839package com.jeff_code;import javax.servlet.*;import java.io.IOException;import java.io.PrintWriter;// 这个实现了Servlet的类就叫做Servletpublic class ServletDemo1 implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //1、获取用户的请求信息 System.out.println("接受到了浏览器的请求。。。。。。"); //2、调用其他类处理请求[处理业务逻辑] System.out.println("正在处理请求，调用dao，并渲染出一个html页面"); //3、根据处理结果给用户响应[页面显示响应的内容] PrintWriter writer = servletResponse.getWriter(); writer.write("hello jeff"); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; 生命周期Servlet对象是Servlet容器创建的，生命周期方法都是由容器调用的，在很多情景下我们都会自己手动创建类对象或者调用方法，但是在框架中很多情况下都是通过反射的机制生成对象或者是调用方法。 Servlet对象的创建：默认情况下，Servlet容器第一次收到HTTP请求时创建对应Servlet对象，并且对象是默认是单例的，只创建一次。 Servlet对象初始化：Servlet容器创建Servlet对象之后，会调用init(ServletConfig config)方法，对其进行初始化。在javax.servlet.Servlet接口中，public void init(ServletConfig config)方法要求容器将ServletConfig的实例对象传入，这也是我们获取ServletConfig的实例对象的根本方法。 处理请求：在javax.servlet.Servlet接口中，定义了service(ServletRequest req, ServletResponse res)方法处理HTTP请求，同时要求容器将ServletRequest对象和ServletResponse对象传入。 Servlet对象销毁：服务器重启或服务器停止执行时会销毁Servlet对象，而销毁之前为了执行一些诸如释放缓存、关闭连接、保存数据等操作，所以设计了public void destroy()方法。 最后要说一点关于生命周期方法，这些生命周期方法都是由web容器来调用的，框架或者容器将很多对象及使用销毁等操作都做了通用的操作，那么编码人员就可以将更多的精力放在编码上，这种实现与Spring的控制反转思想是一样的。 ServletConfig作用：每个Servlet都有自己唯一的一个配置对象，服务器在启动时，当用户第一次访问Servlet，服务器调用init方法，服务器会创建此对象将对象传入到init中。获取servlet的别名：config.getServletName();。获取Servlet在配置文件中配置的初始化参数(配置在web.xml配置文件中):1234567891011121314151617181920&lt;servlet&gt; &lt;servlet-name&gt;AServlet1&lt;/servlet-name&gt; &lt;servlet-class&gt;com.jeff.servlet.AServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://localhost:3306/databasename&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;user&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;AServlet1&lt;/servlet-name&gt; &lt;url-pattern&gt;/AServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;context-param&gt; &lt;param-name&gt;hehe&lt;/param-name&gt; &lt;param-value&gt;haha&lt;/param-value&gt;&lt;/context-param&gt; 可以在Servlet的init()中获取到配置中的参数以及全局共享的ServletContext对象。1234567@Overridepublic void init(ServletConfig servletConfig) throws ServletException &#123; String user = servletConfig.getInitParameter(&quot;user&quot;); ServletContext application = servletConfig.getServletContext(); System.out.println(user); System.out.println(application);&#125; Web应用程序中的所有Servlet都共享同一个ServletContext对象，所以ServletContext对象也被称为 application 对象（Web应用程序对象）。 HttpServletHttpServlet继承了GenericServlet，GenericServlet继承了Servlet。调用继承了HttpServlet的类，会根据请求的类型执行doGet或者doPost下的方法，但是doGet绝不是生命周期函数。虽然doGet和doPost不是生命周期方法，但是由于HttpServlet中service方法的层层调用，最终请求肯定会交给doget或doPost处理。 HttpServletDemo123456789101112131415161718192021222324package com.jeff_code;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class HttpServletDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setHeader("Content-Type", "text/html;charset=UTF-8"); //System.out.println("接受到请求了..............."); //1、向响应体中写数据[页面片段或字符串或完整html页面] PrintWriter writer = resp.getWriter(); writer.write("&lt;a href='#'&gt;点我&lt;/a&gt;"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; web.xml123456789&lt;servlet&gt; &lt;servlet-name&gt;HttpServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;com.jeff_code.HttpServletDemo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HttpServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/HttpServletDemo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在我们的代码里并没有生命周期函数，那么HttpServlet是如何执行到service业务代码的呢，准确的说它有没有执行到service方法里呢，答案肯定是要在service中执行业务代码的，HttpServlet也是Servlet的子类，web服务肯定不会单独为一个类型的操作设置不同的运行流程的，所以他们底层一定是同一套生命周期即同一套执行流程。所以不多说，我们直接上源码。1234// 继承GenericServletpublic abstract class HttpServlet extends GenericServlet &#123;// 后面定义很多常量与静态成员变量，用到单独拿出来说&#125; 1234567891011// 这个doGet是判断请求是否是会发生4XX错误，不是我们要用到的，后面一些doXX都会进行这个判断 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String protocol = req.getProtocol(); String msg = lStrings.getString(&quot;http.method_get_not_supported&quot;); if (protocol.endsWith(&quot;1.1&quot;)) &#123; resp.sendError(405, msg); &#125; else &#123; resp.sendError(400, msg); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod(); long lastModified; if (method.equals(&quot;GET&quot;)) &#123; lastModified = this.getLastModified(req); if (lastModified == -1L) &#123; this.doGet(req, resp); &#125; else &#123; long ifModifiedSince; try &#123; ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;); &#125; catch (IllegalArgumentException var9) &#123; ifModifiedSince = -1L; &#125; if (ifModifiedSince &lt; lastModified / 1000L * 1000L) &#123; this.maybeSetLastModified(resp, lastModified); this.doGet(req, resp); &#125; else &#123; resp.setStatus(304); &#125; &#125; &#125; else if (method.equals(&quot;HEAD&quot;)) &#123; lastModified = this.getLastModified(req); this.maybeSetLastModified(resp, lastModified); this.doHead(req, resp); &#125; else if (method.equals(&quot;POST&quot;)) &#123; this.doPost(req, resp); &#125; else if (method.equals(&quot;PUT&quot;)) &#123; this.doPut(req, resp); &#125; else if (method.equals(&quot;DELETE&quot;)) &#123; this.doDelete(req, resp); &#125; else if (method.equals(&quot;OPTIONS&quot;)) &#123; this.doOptions(req, resp); &#125; else if (method.equals(&quot;TRACE&quot;)) &#123; this.doTrace(req, resp); &#125; else &#123; String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[]&#123;method&#125;; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(501, errMsg); &#125;&#125; HttpServlet重写了父类的service的方法，执行时会先执行到子类的service，可以根据请求的方式调用相应的方法，最后会调用HttpServlet的doGet方法，所以底层执行的还是service生命函数。而且值得一提的是会先执行底下的这段service。123456789101112public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request; HttpServletResponse response; try &#123; request = (HttpServletRequest)req; response = (HttpServletResponse)res; &#125; catch (ClassCastException var6) &#123; throw new ServletException(&quot;non-HTTP request or response&quot;); &#125; this.service(request, response);&#125; 生命周期中的service参数是ServletRequest.class与ServletResponse.class类型，但是doXX方法的参数是HttpServletRequest.class与HttpServletResponse.class类型，所以在这段方法里进行了类型的转换，最后调用重载的方法完成doXX的调用。 ServletRequest与HttpServletRequest123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public interface ServletRequest &#123;// 获取域中存的数据 Object getAttribute(String var1);// 获取所有域中存的参数名 Enumeration&lt;String&gt; getAttributeNames();// 获取或修改编码值 String getCharacterEncoding(); void setCharacterEncoding(String var1) throws UnsupportedEncodingException;// 获取修改请求头里的一些信息 int getContentLength(); String getContentType(); ServletInputStream getInputStream() throws IOException;// 获取请求参数 String getParameter(String var1); Enumeration&lt;String&gt; getParameterNames(); String[] getParameterValues(String var1); Map&lt;String, String[]&gt; getParameterMap();// 获取http或者https，主机名，ip等参数的方法 String getProtocol(); String getScheme(); String getServerName(); int getServerPort(); BufferedReader getReader() throws IOException; String getRemoteAddr(); String getRemoteHost();// 往域里存删键值 void setAttribute(String var1, Object var2); void removeAttribute(String var1); Locale getLocale(); Enumeration&lt;Locale&gt; getLocales(); boolean isSecure(); RequestDispatcher getRequestDispatcher(String var1); /** @deprecated */ String getRealPath(String var1); int getRemotePort(); String getLocalName(); String getLocalAddr(); int getLocalPort(); ServletContext getServletContext(); AsyncContext startAsync(); AsyncContext startAsync(ServletRequest var1, ServletResponse var2); boolean isAsyncStarted(); boolean isAsyncSupported(); AsyncContext getAsyncContext(); DispatcherType getDispatcherType();&#125; ServletRequest中的方法都是对基本请求的一些参数获取与操作，12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public interface HttpServletRequest extends ServletRequest &#123; String BASIC_AUTH = &quot;BASIC&quot;; String FORM_AUTH = &quot;FORM&quot;; String CLIENT_CERT_AUTH = &quot;CLIENT_CERT&quot;; String DIGEST_AUTH = &quot;DIGEST&quot;; String getAuthType(); Cookie[] getCookies(); long getDateHeader(String var1); String getHeader(String var1); Enumeration&lt;String&gt; getHeaders(String var1); Enumeration&lt;String&gt; getHeaderNames(); int getIntHeader(String var1); String getMethod(); String getPathInfo(); String getPathTranslated(); String getContextPath(); String getQueryString(); String getRemoteUser(); boolean isUserInRole(String var1); Principal getUserPrincipal(); String getRequestedSessionId(); String getRequestURI(); StringBuffer getRequestURL(); String getServletPath(); HttpSession getSession(boolean var1); HttpSession getSession(); boolean isRequestedSessionIdValid(); boolean isRequestedSessionIdFromCookie(); boolean isRequestedSessionIdFromURL(); /** @deprecated */ boolean isRequestedSessionIdFromUrl(); boolean authenticate(HttpServletResponse var1) throws IOException, ServletException; void login(String var1, String var2) throws ServletException; void logout() throws ServletException; Collection&lt;Part&gt; getParts() throws IOException, IllegalStateException, ServletException; Part getPart(String var1) throws IOException, IllegalStateException, ServletException;&#125; HttpServletRequest提供了更多的方法，增加的都是Http相关的方法，Sun只是提供了ServletRequest作为接口，规范相关的实现，而ServletRequest除了http还可以扩展他用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang的function]]></title>
    <url>%2F2018%2F06%2F28%2Fgolang%E7%9A%84function%2F</url>
    <content type="text"><![CDATA[函数是Golang的一等公民，golang中大量使用函数式编程，所以理解函数十分有必要。 定义1234func 函数名(形参) 返回值类型 &#123; 函数体 return 返回值&#125; 值得注意的是go的函数允许多个返回值，并且在很多情况我们都会返回两个以上的返回值，前面多个是函数功能应该返回的返回值，最后一个返回值则是error的返回值。 golang的函数func与其他语言的function略有不同，需要讨论一下的就是声明时的函数返回值类型。123func test1() &#123; fmt.Printf("hello jefflike")&#125; 这是一个无参无返回值的function，此时我们可以省略返回值类型。123456func test2() int &#123; return 1&#125; a:=test2() fmt.Println(a) 当函数有返回值时，声明是必须标明返回值的类型。多个返回值的时候也可以这样写返回值，但是需要使用()将返回值放进去。123456func test3(a,b,c int) (int,int,int) &#123; return a,b,c&#125; a,b,c := test3(1,2,3) fmt.Printf(&quot;a=%d, b=%d, c=%d\n&quot;, a, b, c) 对于多个返回值，golang有一种推荐写法。123456789func test4() (a int,b int,c int) &#123; a = 1 b = 2 c = 3 return&#125; a,b,c := test4() fmt.Printf(&quot;a=%d, b=%d, c=%d\n&quot;, a, b, c) 一般多个返回值时，golang推荐写法是上述的写法。在有返回值的function里必须要返回return。 函数类型也叫做函数指针.123456// 类型别名 // 类型别名的关键字就是一个type type bigint int64 var a bigint fmt.Printf(&quot;a type is %T\n&quot;, a) // a type is main.bigint 12345678910111213141516171819202122func add(a, b int) int &#123; return a+b&#125;func min(a, b int) int &#123; return a-b&#125;func main() &#123; // 用别名定义一个匿名的函数，myFunc此时是一个函数类型，代表一个传入两个int参数，返回一个int值的函数类型的统称 type myFunc func(int, int) int // 定义一个与此函数相同的形参与返回值的函数名 var myFunc1 myFunc myFunc1 = add va := myFunc1(3 ,5) fmt.Println(va)//8 myFunc1 = min va = myFunc1(3 ,5) fmt.Println(va)//-2&#125; 用一个type别名代表一个函数，然后可以像python这样动态语言一样将自定义类型的函数名附上相同的形参与返回值的函数名，加上()就可以直接调用，这两个函数名都具有一样的操作效果。即声明所有myFunc类型，都可以变成一个两个形参一个返回值（都是int类型）的函数来使用。myFunc此时是一个函数类型，代表一个传入两个int参数，返回一个int值的函数类型的统称。 函数作为参数作为golang的一等公民，func可以当作实参传递到函数中。123456789101112131415161718192021222324252627func operation(op func(int, int) int,a, b int) int &#123;//打印出op的值p := reflect.ValueOf(op).Pointer() // 此时调用的p的指针内容是： 4761920opName := runtime.FuncForPC(p).Name()//获取到这个指针的ame, 此时调用的p的指针内容是： main.addfmt.Println(&quot;此时调用的p的指针内容是：&quot;, opName)return op(a, b)&#125;func add(m, n int) int &#123;return m + n&#125;func div(a,b int)(q,r int)&#123;return a / b, a % b&#125;func main() &#123;v := operation(add, 5, 6)fmt.Println(v)//使用匿名函数，go的lambda就是比较极简v2 := operation(func(i,j int) int&#123;return i+j&#125;, 6, 7)// 此时调用的p的指针内容是： main.main.func1,因为我是一个匿名函数，所以在这里我们叫做func1fmt.Println(v2)//13&#125; func作为实参传递的基础就是函数指针。 闭包函数12345678910111213141516171819202122232425262728293031package mainimport "fmt"//一般函数func test() int &#123;//函数被调用时a被分配一块内存空间var a int//初始化的a为0值a++//a=1return a*a//函数调用完毕，a被释放,下一次还是0值开始&#125;//闭包函数func biBao() func() int&#123;//闭包函数不关心这些捕获的变量是否超过了作用域，只要闭包还在使用，这些变量就还会存在var a intreturn func() int &#123;a++return a * a&#125;&#125;func main() &#123;fmt.Println(test())//1fmt.Println(test())//1fmt.Println(test())//1f := biBao()fmt.Println(f())//1fmt.Println(f())//4fmt.Println(f())//9&#125;]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['归并排序搭建并行管道']]></title>
    <url>%2F2018%2F06%2F27%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%90%AD%E5%BB%BA%E5%B9%B6%E8%A1%8C%E7%AE%A1%E9%81%93%2F</url>
    <content type="text"><![CDATA[前言这个项目我使用go来完成，在归并排序结果时多个节点之间连线，用Java等面向对象语言来实现就是将节点抽象成对象，通过方法进行互联。与他们相比go实现起来更为自然，节点之间的关系更像是多个goroutine通过管道连接起来的结构，使用go来写代码更为简洁，开发更快。 相关知识go的channel123456789101112131415161718func printhello(i int, ch chan string) &#123; for&#123; ch &lt;- fmt.Sprintf("hello world from gorutine %d\n", i) &#125;&#125;func main()&#123; ch := make(chan string) for i:=0;i&lt;500;i++&#123; go printhello(i, ch) &#125; for &#123; msg := &lt;- ch fmt.Println(msg) &#125;&#125; 使用管道可以在两个goroutine之间传递信息，这是实现本项目的基础。 sort排序go自带的排序算法，底层实现是快速排序，我们就使用这个方式。12345678// 排序一个数组func main() &#123; a := []int&#123;3, 5, 1, 43, 9, 34&#125; sort.Ints(a) for i, v := range a&#123; fmt.Printf("第%d个是%d\n", i, v) &#125;&#125; 归并排序归并排序是易于实现的，实现归并排序的基础是每一个被归并节点都要是已经排序好了的，我们从个节点的head开始迭代比较，每次可以获得一个当前最小的值pop出来，无限次递归，最终我们获得pop出来的数据就是排序好了的数据，这就是归并排序的思路。 外部排序我们的并行管道可能会处理一个非常大的数据流的排序，这个数据的大小很有可能超出内存的容量，那么我们肯定不能使用sort方法直接把整个数据排序，我们实现的方式是将整个数据流切成k快，每一块都能被内存加载，当然我们可以将每一块都sort排序，然后内存切换加载每一块数据流，归并排序出一个结果，结果自然就是排序好的数据流了。外部排序切分的每一块都组成一个节点：将k个节点分别排序后归并排序将数据存放到一个堆数据中：外部排序的结构：这里每个节点都是多进多出的，无进多出的是source节点，多进无出的是sink节点。节点之间的通信：多个节点之间的通信在面向对象中节点抽象成对象，对象之间的影响就是方法的调用，使用go则不需要，每个网络的节点就是一个goroutine，goroutine之间的信息传输使用channel通信。 整个外部排序项目的结构： 实现节点基础节点12345678910111213// 将Array中的数据都存放到channel中,箭头告诉使用此函数只能读取到chan值，只出不进,使用他的人只能从这个管道里拿东西func ArraySource(arr ...int) &lt;- chan int &#123; out:=make(chan int) // 因为我们的channel是在goroutine之间传输的通道，所以我们不能自己将自己的arr输送到自己的channel go func() &#123; for _,v := range arr&#123; out &lt;- v &#125; // 数据传输完毕，并行计算pipeline中最好是使用close结束表明数据传输已经完成了 close(out) &#125;() return out&#125; 这是一个源节点，此节点的作用就是将读取到的值存放到一个管道中返回，调用这个节点就可以一直取到值直到管道传递完成close。因为我们节点间数据交换是goroutine和goroutine的交互，所以这里我们读到源数据后选择在goroutine中func处理数据。这里我们开启一个goroutine就将管道return回去了。 1234567891011121314151617181920212223// 数据排序func IntMemorySort(in &lt;- chan int) &lt;- chan int &#123; out := make(chan int) go func() &#123; // 将数据加载到内存 arr := []int&#123;&#125; for v:= range in &#123; arr = append(arr,v) &#125; // 快速排序 sort.Ints(arr) // 排序后加载到管道中 for _,v := range arr &#123; out &lt;- v &#125; close(out) &#125;() return out&#125; 12345678// 使用排序管道进行排序func main() &#123; p := pipeline.IntMemorySort(pipeline.ArraySource(3,6,8,2,5)) for v := range p&#123; fmt.Println(v) &#125;&#125; 这里IntMemorySort的goroutine一直在从管道中读数据，排序，main中遍历的p管道一直在读，如果上面的goroutine排序时卡顿，那么p管道的读取也会等待上一层goroutine排序完成继续读取值。在golang中我们不需要使用lock机制控制等待，等待的内容是Go语言底层做的。 归并节点12345678910111213141516171819202122232425// 归并排序func Merge(in1, in2 &lt;- chan int) &lt;- chan int &#123; out := make(chan int) go func() &#123; v1, ok1 := &lt;- in1 v2, ok2 := &lt;- in2 // in1，in2中有一个还有值循环就要做下去 for ok1 || ok2&#123; // in2的管道已经空了或者in1的头小于in2的头就将in1的头加入到队列管道中 &#125; if !ok2 ||(ok1 &amp;&amp; v1&lt;=v2)&#123; out &lt;- v1 // 取下一个管道内的值，迭代的效果 v1,ok1 = &lt;- in1 &#125;else &#123; out &lt;- v2 v2, ok2 = &lt;- in2 &#125; &#125; close(out) &#125;() return out&#125; 归并参数是多个channel(我们这里是两个)，归并排序之前的两个管道的数据一定是已经排序好了的，有goroutine我们实现起来非常的简单，因为我们什么都没做，他已经是排序好的两个管道值才会被归并。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数据库操作]]></title>
    <url>%2F2018%2F06%2F22%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统（DBMS），通用的SQL数据库存取和操作的公共接口。忽略底层的东西，用相同的API操作，更加规范化，JDBC的数据库操作方式还是原生数据库，不是ORM。 JDBC访问数据库的流程 导入数据库jar包要使用JDBC连接数据库，那么首先需要一个连接数据库的驱动。相关的驱动可以在相应的数据库提供商的官网下载jar包，导入使用。 获取数据库的连接123456789101112// 注册驱动Class c = Class.forName(&quot;com.mysql.jdbc.Driver&quot;);System.out.println(c);// class com.mysql.jdbc.Driver// 获取连接String url = &quot;jdbc:mysql://localhost:3306/0508db&quot;;String user = &quot;root&quot;;String password = &quot;root&quot;;// 驱动加载到内存后，由DriverManager管理, 获取JDBC链接Connection conn = DriverManager.getConnection(url, user, password);System.out.println(conn); // com.mysql.jdbc.JDBC4Connection@42110406 Statement操作数据库查看数据库123456789101112Statement s = conn.createStatement();String sql = &quot;select * from dept&quot;;ResultSet res = s.executeQuery(sql);while (res.next())&#123; int id = res.getInt(&quot;did&quot;); String name = res.getString(&quot;dname&quot;); System.out.println(id + &quot;\t&quot; + name);&#125;s.close();conn.close(); 增加，修改， 删除数据123456789101112String sql = &quot;INSERT INTO dept VALUES(7,&apos;ff&apos;)&quot;;// String sql = &quot;update dept set dname = &apos;测试部门&apos; where did = 7&quot;;// String sql = &quot;delete from dept where did = 7&quot;;Statement st = conn.createStatement();int len = st.executeUpdate(sql);if(len&gt;0)&#123; System.out.println(&quot;添加成功&quot;);&#125;else&#123; System.out.println(&quot;添加失败&quot;);&#125; 修改数据都是一类操作语句，修改一下sql语句即可。 PreparedStatementStatement存在三个问题： sql语句的拼接过于繁琐，比如查询语句的过滤条件是手动输入的，sql语句就要写成这样：INSERT INTO users VALUES(NULL,&#39;&quot;+ username +&quot;&#39;,&#39;&quot; +password + &quot;&#39;,&#39;&quot; +email+&quot;&#39;),各种引号的嵌套，不利于查看。 不能防止sql注入的问题； 无法处理Blob等二进制类型的数据； 所以一般我们开发会使用PreparedStatement类进行数据库相关的操作。1234567891011121314151617// (1)获取连接Connection conn = JDBCTools.getConnection();//(2)编写特殊的SQLString sql = &quot;INSERT INTO users VALUES(NULL,?,?,?)&quot;;//(3)获取PreparedStatementPreparedStatement pst = conn.prepareStatement(sql);//对带？的sql进行预编译，有三个？，代表有三个值需要传入//(4)设置?对应的值pst.setString(1, username);pst.setString(2, password);pst.setString(3, email);//(5)执行sqlint len = pst.executeUpdate();//此处不需要再传入sql了，sql里面有三个预编译的？System.out.println(len&gt;0?&quot;成功&quot;:&quot;失败&quot;); 读取数据1234567891011121314151617181920212223242526//(1)获取连接 Connection conn = JDBCTools.getConnection(); //(2)编写SQL String sql = &quot;SELECT id,username,`password`,email FROM users WHERE username= ? AND `password` = ?&quot;; //(3)创建PreparedStatement PreparedStatement pst = conn.prepareStatement(sql); //(4)设置？的值 pst.setString(1, username); pst.setString(2, password); //(5)执行SQL ResultSet rs = pst.executeQuery();//不能再传Sql，不然？又回去了 while(rs.next())&#123; int id = rs.getInt(&quot;id&quot;); String u = rs.getString(&quot;username&quot;); String p = rs.getString(&quot;password&quot;); String e = rs.getString(&quot;email&quot;); System.out.println(id+&quot;\t&quot; + u + &quot;\t&quot; + p + &quot;\t&quot; + e); &#125; //(5)释放资源 JDBCTools.freeQuietly(rs, pst, conn); ORM123456789101112131415161718192021User user = new User(0,&quot;jeff&quot;,&quot;123&quot;,&quot;jeff@123.com&quot;);//可以从键盘输入，也可以从web页面...//对象存储到数据库中：O-&gt;R//1、获取连接Connection conn = JDBCTools.getConnection();//2、编写sqlString sql = &quot;INSERT INTO users VALUES(NULL,?,?,?)&quot;;//3、获取PreparedStatementPreparedStatement pst = conn.prepareStatement(sql);//4、设置？pst.setString(1, user.getUsername());pst.setString(2, user.getPassword());pst.setString(3, user.getEmail());//5、执行int len = pst.executeUpdate();System.out.println(len&gt;0?&quot;成功&quot;:&quot;失败&quot;); 1234567891011121314151617181920212223242526272829303132//关系数据库中的数据--&gt;对象 R-&gt;O //1、获取连接 Connection conn = JDBCTools.getConnection(); //2、编写sql String sql = &quot;SELECT id,username,`password`,email FROM users&quot;; //3、获取PreparedStatement PreparedStatement pst = conn.prepareStatement(sql); //4、设置？，不需要，因为没有？ //5、执行 ResultSet rs = pst.executeQuery(); ArrayList&lt;User&gt; list = new ArrayList&lt;&gt;(); while(rs.next())&#123; //读取一行 int id = rs.getInt(&quot;id&quot;); String username = rs.getString(&quot;username&quot;); String password = rs.getString(&quot;password&quot;); String email = rs.getString(&quot;email&quot;); //封装为一个对象 User u = new User(id,username,password,email); //添加到集合 list.add(u); &#125; //6、遍历集合 list.forEach(System.out::println); 插入数据获取数据的属性123456789101112131415161718192021222324// (1)获取连接Connection conn = JDBCTools.getConnection();//(2)编写特殊的SQLString sql = &quot;INSERT INTO users VALUES(NULL,?,?,?)&quot;;//(3)获取PreparedStatement//如果需要执行完添加的sql后，想要返回自增长的键值，那么需要制定Statement.RETURN_GENERATED_KEYS PreparedStatement pst = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS );//对带？的sql进行预编译，有三个？，代表有三个值需要传入//(4)设置?对应的值pst.setString(1, username);pst.setString(2, password);pst.setString(3, email);//(5)执行sqlint len = pst.executeUpdate();//不能再传Sql，不然？又回去了System.out.println(len&gt;0?&quot;成功&quot;:&quot;失败&quot;);//获取自增长的键值ResultSet rs = pst.getGeneratedKeys();if(rs.next())&#123; System.out.println(&quot;用户编号是：&quot; + rs.getInt(1));&#125; 批量查询12345678910111213141516171819202122232425262728//1、模拟批量插入10000个用户信息 //1、获取连接 Connection conn = JDBCTools.getConnection(); //(2)编写特殊的SQL String sql = &quot;INSERT INTO users VALUES(NULL,?,?,?)&quot;; //(3)获取PreparedStatement PreparedStatement pst = conn.prepareStatement(sql);//对带？的sql进行预编译，有三个？，代表有三个值需要传入 //(4)设置？的值，并且执行 for(int i=1;i&lt;=10000; i++)&#123; String username = &quot;测试用户名&quot;+i; pst.setString(1, username); pst.setString(2, &quot;123456&quot;); pst.setString(3, username +&quot;@123.com&quot;); //先添加到批处理中，先攒着 pst.addBatch(); &#125; //最后执行批处理 pst.executeBatch(); //(6)释放资源 JDBCTools.freeQuietly(pst, conn);//因为PreparedStatement是Statement的子接口，多态参数 long end = System.currentTimeMillis(); 支持事物123456789101112131415161718192021222324252627282930313233343536373839//1、获取连接 Connection conn = JDBCTools.getConnection(); //设置连接为手动提交模式 conn.setAutoCommit(false); //2、编写特殊的sql String sql = &quot;UPDATE users SET PASSWORD = ? WHERE username = ?&quot;; //3、创建PreparedStatement PreparedStatement pst = conn.prepareStatement(sql); //第一个 pst.setString(1, &quot;123&quot;); pst.setString(2, &quot;chai&quot;); boolean flag = true;//假设成功 int len = pst.executeUpdate(); System.out.println(len&gt;0?&quot;成功&quot;:&quot;失败&quot;); flag = flag &amp; (len&gt;0); //第二个 pst.setString(1, &quot;123&quot;); pst.setString(2, &quot;lin&quot;);//故意制造错误 len = pst.executeUpdate(); System.out.println(len&gt;0?&quot;成功&quot;:&quot;失败&quot;); flag = flag &amp; (len&gt;0); if(flag)&#123; conn.commit();//提交事务 &#125;else&#123; conn.rollback();//回滚 &#125; //还原自动提交模式 conn.setAutoCommit(true); DAODAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD，而不包含任何业务相关的信息。作用：为了实现功能的模块化，更有利于代码的维护和升级。 我们自己也可以实现一个DAO，DAO的本质与我们上面操作PreparedStatement进行增删改查类似，只是将操作的细节封装成方法，预编译？作为参数传入方法，所以实质就是将增删改查封装成API提供给我们操作。 抽取BaseDAO的时候，查询的BaeDAO对于查询数据返回值的类型是不确定的，所以怎么将查询结果封装成对象返回显示，需要使用到反射读取子类传给父类时的泛型实参，从而生成实例对象并且读取显示。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 private Class&lt;T&gt; type; public BaseDAO()&#123; Class&lt;? extends BaseDAO&gt; c = this.getClass(); Type t = c.getGenericSuperclass(); ParameterizedType p = (ParameterizedType) t; Type[] arr = p.getActualTypeArguments(); type= (Class) arr[0]; &#125; //通用的查询多个对象的方法 public List&lt;T&gt; getList(String sql, Object... args)&#123; try &#123; //1、获取连接 Connection conn = JDBCTools.getConnection(); //3、创建PreparedStatement PreparedStatement pst = conn.prepareStatement(sql); //4、设置？ for (int i = 0; i &lt; args.length; i++) &#123; pst.setObject(i+1, args[i]); &#125; ResultSet rs = pst.executeQuery(); ResultSetMetaData metaData = rs.getMetaData();//结果集的元数据 /* * #结果集的元数据，结果有3列，列名称分别是id,title,author SELECT id,title,author FROM books WHERE id &lt;5;; SELECT id, title,author,price,sales,stock,img_path AS imgPath FROM books 当属性名（类）与字段名（表）不一致时，可以通过取别名，告知结果集我类的属性名是什么 */ //一共有几列 int count = metaData.getColumnCount(); ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); while(rs.next())&#123;//很多行，很多个对象 //一行，代表一个对象 //循环一次，代表一行 T t = type.newInstance(); //每一个对象又有很多列，即很多个属性需要设置 for(int i=0; i&lt;count; i++)&#123;//n个属性 //获取第几列的名称// String columnLabel = metaData.getColumnName(i+1);//只能得到列名 //getColumnLabel如果没有别名就获取列名称，如果有别名就获取别名 String columnLabel = metaData.getColumnLabel(i+1);//可以得到列的别名 //根据列名称，获取值 Object value = rs.getObject(columnLabel); //设置对象的属性值 //(1)获取属性对象Field// Field f = type.getDeclaredField(属性名); Field f = type.getDeclaredField(columnLabel); //(2)调用Field对象的setAccessible(true) f.setAccessible(true); //(3)调用Field对象的set方法，设置属性值// f.set(t, 属性值); f.set(t, value); &#125; list.add(t); &#125; JDBCTools.freeQuietly(rs, pst, conn); return list; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; 注意事项： 因为传递的参数个数是不确定个数，类型也是不确定类型，所以接收的形参是Object… args； getMetaData获取query的结果集，元数据就是表中列的名称或者别名，存入到Object需要与类型的属性名一致； 元数据getColumnCount获取到查询的数据的条数； 生成一个当前对象type的实例，然后生成查询到行数个对象进行赋值操作； getColumnLabel获取元数据的别名，因为通用性不确定当前列的的数据类型，所以使用getObject。数据库连接池数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 数据库连接池技术的优点： 资源重用：由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 更快的系统反应速度：数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间。 新的资源分配手段：对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源。 统一的连接管理，避免数据库连接泄露：在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露。 数据连接池的种类有很多， DBCP 是Apache提供的数据库连接池，速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持； C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以； Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点； BoneCP 是一个开源组织提供的数据库连接池，速度快； Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不知道是否有BoneCP快。 Druid是现在普遍使用的数据库连接池，它的有点比较多，所以我一般都会使用它。Druid的连接池使用方式：123456789101112131415161718192021//1、创建连接池DruidDataSource ds = new DruidDataSource();//2、基本参数ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);ds.setUrl(&quot;jdbc:mysql://localhost:3306/bookstore&quot;);//bookstore库名，SQL中是表名称ds.setUsername(&quot;root&quot;);ds.setPassword(&quot;root&quot;);ds.setInitialSize(10);ds.setMaxActive(20);ds.setMinIdle(5);ds.setMaxWait(5000);//4、获取连接for(int i=1; i&lt;=30; i++)&#123; Connection conn = ds.getConnection(); System.out.println(&quot;第&quot; + i + &quot;个连接：&quot; + conn); conn.close();&#125;ds.close(); 将信息写入配置文件123456789Properties pro = new Properties();pro.load(TestDruid2.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));DataSource ds = DruidDataSourceFactory.createDataSource(pro);for (int i = 1; i &lt;= 30; i++) &#123; Connection conn = ds.getConnection(); System.out.println(&quot;第&quot; + i + &quot;个连接：&quot; + conn); conn.close();&#125; 附c3p0的配置：12345678910ComboPooledDataSource ds = new ComboPooledDataSource();ds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);ds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/bookstore&quot;);ds.setUser(&quot;root&quot;);ds.setPassword(&quot;123456&quot;);ds.setInitialPoolSize(10);ds.setMinPoolSize(5);ds.setMaxPoolSize(20); Apache-DBUtilsCommons-DBUtils是Apache组织提供的一个开源JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用DBUtils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 DbUtils：提供如关闭连接、释放资源、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。12345678public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。public static void commitAndClose(Connection conn)throws SQLException 用来提交连接的事务，然后关闭连接public static void commitAndCloseQuietly(Connection conn)： 用来提交连接的事务，然后关闭连接，并且在关闭连接时不抛出SQL异常。public static void rollback(Connection conn)throws SQLException允许conn为null，因为方法内部做了判断public static void rollbackAndClose(Connection conn)throws SQLExceptionrollbackAndCloseQuietly(Connection)public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 QueryRunner：实现更新（增、删、改、批处理）封装了SQL的执行，是线程安全的。QueryRunner的优点：（1）可以实现增、删、改、查、批处理；（2）考虑了事务处理需要共用Connection；（3）该类最主要的就是简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 不考虑事务而且QueryRunner对象创建时指定数据源，这样在QueryRunner的所有增删改查方法中都会从数据源中自己获取连接。如果有事务，必须传递Connection对象，因为同一个事务的多条语句必须在一个Connection连接中完成。查询所有，不需要传参12String sql = &quot;SELECT id,title,author,price,sales,stock,img_path AS imgPath FROM books&quot;;List&lt;Book&gt; list = qr.query(JDBCTools.getConnection(), sql, new BeanListHandler&lt;Book&gt;(Book.class)); 需要传递参数12String sql = &quot;SELECT id,title,author,price,sales,stock,img_path AS imgPath FROM books where id = ?&quot;;Book book = qr.query(JDBCTools.getConnection(), sql, new BeanHandler&lt;Book&gt;(Book.class),1); 查询单值12String sql = &quot;SELECT COUNT(*) FROM books&quot;;Long count = qr.query(JDBCTools.getConnection(), sql, new ScalarHandler&lt;Long&gt;()); 查询分组（Map）12String sql = &quot;SELECT did,AVG(salary),MAX(salary) FROM t_employee WHERE did =? GROUP BY did&quot;;Map&lt;String, Object&gt; map = qr.query(JDBCTools.getConnection(), sql, new MapHandler(), 1); 嵌套的查询12String sql = &quot;SELECT did,AVG(salary),MAX(salary) FROM t_employee GROUP BY did&quot;;List&lt;Map&lt;String, Object&gt;&gt; query = qr.query(JDBCTools.getConnection(), sql, new MapListHandler()); 更新，修改12String sql = &quot;UPDATE users SET `password` = ? WHERE username = ?&quot;;int len = qr.update(JDBCTools.getConnection(), sql, &quot;123456&quot;, &quot;jeff&quot;); 删除12String sql = &quot;DELETE FROM users WHERE username = ?&quot;;int len = qr.update(JDBCTools.getConnection(), sql, &quot;jeff&quot;); 增加12String sql = &quot;INSERT INTO users VALUES(NULL,?,?,?)&quot;;int len = qr.update(JDBCTools.getConnection(), sql, &quot;jeff&quot;,&quot;123&quot;,&quot;jeff@123.com&quot;); 增加并获取主键123456String sql = &quot;INSERT INTO users VALUES(NULL,?,?,?)&quot;;//因为JDBC底层，preparedStatement执行完了后，调用getGeneratedKeys()返回的是ResultSet结果//所以这里仍然要指定这个结果集如何处理：ResultSetHandler//这个自增长的键值是一个整数值，用ScalarHandler处理Long id = qr.insert(JDBCTools.getConnection(), sql, new ScalarHandler&lt;Long&gt;(), &quot;jeff&quot;,&quot;123&quot;,&quot;jeff@123.com&quot;); Apache提供了很多Java类供Java程序员使用，合理的查看文档可以做到事半功倍。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一梦十年]]></title>
    <url>%2F2018%2F06%2F17%2F180617%E6%89%8B%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[&lt;随笔&gt;&lt;自己写来玩的，留给自己日后翻阅，多年后看来可能又别有一番风味，我的成长记忆没有什么图片，都只有一些奇奇怪怪的文字，我些东西的文风怪怪的，思路跳跃也是极大，别人阅读可能会引起不适，在此道歉，语文没学好不怨老师，这里向老师道歉，最后极度不推荐偶然来访的朋友阅读Life分类的文章。&gt;昨天看世界杯的时候，晃眼看成了2008年奥运会，乍以为是电视转播出了问题，定睛一看原来已是2018。嘲笑过一梦三四年的标题党，原来只是不自知罢了。 说到2008，又会想到那个夏天，大雪，地震，台风，奥运会的一年，也是我青春里最美好的年岁，那几年学的是九年义务教育，课余读的是水浒西游，都是些国内国外的名著，读书也算刻苦，有过梦想，还觉得自己会成为什么了不起的人物。总的来说，照着发展下去，也许不是什么了不起的人但是也绝不会如我现在这般困窘。年少的梦与想啊，被时间沧桑。 别的不说，九年的义务教育我完成的还是极好的。呵，全无用处。读高中时，接触到互联网，玩着大三亿，看的是神墓，星辰变，辰东，唐三与番茄之流。流行快餐文化是灵魂的海洛因。这也是我绝不会使用抖音，快手等APP的原因，辣鸡微信公众号的断章取义毒害的是中华民族的青年们。不幸的是我get到了当时盛行的“读书无用”理论，很多时候人都只能听到自己想要听到的东西，对于独立意识模糊，自主意识不健全的青少年来说，我的思想已经中毒了。直至此刻，娱乐至上已经全民化，辣鸡影视作品在侵蚀我们的下一代，那些年我读过的辣鸡文学，这几年被升级成了各种电视剧，电影。我看到的是腐蚀了我的民族。 “为中华崛起而编程”我不是随便说说，我知道我一个写web的菜鸡我没资格上升到中华民族的高度，我是青年一代，但是我代表不了民族希望，代表希望的是那些现在看爱情公寓，三生三世的00后，彼时我也将它们视为神作，此时只有鄙夷和不屑。他们能扛得住人口老龄化的中国吗，掏空了六个钱包，它们是不是如同香港和日本的青年亦或是更差？ 四年lol，一朝入社会。方鸿渐留洋三年，花的是老丈人的钱，拿回来是应付的一纸文凭，浪费着大好的时光，却无半点才学。我同他别无两样，有的是一文不值的傲，能与苏文纨，赵辛楣交好，自觉高人一等的错觉，说来实在羞耻。于我而言，刘是同赵辛楣相似的人，在妥协于生活之前，把我拖出来，我现在即使过的不如16年轻松，但是至少不是little hunger，我自觉算得上是great hunger。 编程给我带来的绝对不是coding，加班，我觉得这段生活经历它拯救了我的灵魂，至少我觉得向我这样受过教育的青年都只想着安逸，不学习，不思考，不进取，给我们背负重担的那些人总有一天会被我这根稻草压垮。我们社会的重担是压在少数人的身上的，敢于承担，富有拼搏的人在为我们扛起整个国家，有政客，有科研人员，有商人，各个角落。与他们一样，也有坐吃山空，游山玩水，好逸恶劳，逃税漏税，但更多的是吃吃喝喝，网络毒舌，娱乐至死的家长里短。于我个人，我知道我读个书，对社会影响力为0，我不是明星，我没有粉丝，我没有流量，我不会说好听的话，so bad，我做这些只是让我和家人能过的好一些，从我辞职到现在快一年了，家人的鼓励与陪伴是我最大的动力。我曾觉得自己冷血无情，可能只是那时年少吧。父母给了我很多，我放弃自己的同时也在放弃他们。 我总是后知后觉，该学习的时候，我在读网络文学，该恋爱的年纪我在lol，该工作的年纪我开始想学习了，我想下一步该结婚的年纪我应当事业刚起步。但是那又怎样呢，我至少还没放弃，有时候我看到那些三四十岁被生活摧残的老哥踏上IT不归路，想一想如果我今日不上车，他会不会就是我的明天。我今年26岁，梦醒了，我开始考虑自己的人生，生活不止眼前的苟且，还有很多的苟且在后面接踵而至，但是为了生活，为了父母，为了以后可能遇到的人，为了自己现阶段，写Java，写python，写golang，写web。我可能活不了很久，但是人生苦短，何妨一试。至少我现在听音乐+coding的时候，我觉得自己是神。哪怕我在写hello world。如果没有爱人和婚姻，我怕是要写一辈子代码了。提前送自己一首凉凉。 “勇敢，自信，责任，担当，不做绝大多数，为中华崛起而编程!”2018.06.17 北京市丰台区六里桥东随笔]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2018%2F06%2F14%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[什么是泛型集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把存储元素类型设计为Object，JDK1.5之后使用泛型来解决。存放元素时除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection，List，ArrayList 这个就是类型参数，即泛型。在声明阶段定义一个标签，当此标签被传入泛型实参后，容器里存放怎样的数据就定格了。 从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List，这表明该List只能保存字符串类型的对象。 为什么使用泛型使用泛型优于Object是因为在Object读取类型对象的时候需要进行类型强转，这个过程可能会发生类型转换异常。但是使用泛型不需要进行类型转换，减少了类型异常的风险。同时Object可以接受Java的任意对象，这使得集合中的元素具有不同类型的风险，但是泛型只有指定的元素可以存放至集合，集合元素类型更安全。 简单的来说，泛型就是为了解决声明阶段不能确定元素类型，但在使用阶段可以确定类型的情况。12345678910public class Main &#123; public static void main(String[] args) &#123; // 未使用泛型的集合，管理混乱 ArrayList list = new ArrayList(); list.add(1); list.add("jeff"); list.add(3.14); &#125;&#125; 上面的代码未使用泛型，集合里存入数据具有不确定性，什么类型都可以存，这使得数据读取变得麻烦.1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; // 未使用泛型的集合，管理混乱 ArrayList list = new ArrayList(); list.add(1); list.add("jeff"); list.add(3.14); int a =(int)list.get(0);// 强转时注意不要转错了，这也是缺点之一，转型错误编译时也不会报错 System.out.println(a); String b =(String) list.get(1); System.out.println(b); double c = (double) list.get(2); System.out.println(c); &#125;&#125; 也许强制类型转换可以解决这个问题，但是迭代遍历可没有这么方便了。而且这样操作实在麻烦。此时没有标明泛型，则编译的时候按照泛型擦除的状态进行操作，类似于Object类型存储。12345 // 使用泛型后 ArrayList&lt;Integer&gt; list= new ArrayList&lt;&gt;(); list.add(2);// list.add(&quot;string&quot;);//不同的类型在编译阶段就会报错// list.add(3.14); 注意：（1）泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object； （2）泛型实参不能指定为基本数据类型。 泛型分类泛型类/泛型接口1【修饰符】 class/interface 类名/接口名&lt;泛型形参列表&gt;&#123;&#125; 泛型类上定义的泛型形参在类中可以当作数据类型使用。可以使用在: 属性； 方法； 方法的返回值类型； 自定义一个泛型类1234567891011121314151617181920212223242526272829303132333435363738394041class Student&lt;T&gt;&#123; private String name; private T score; public Student() &#123; super(); &#125; public Student(String name, T score) &#123; super(); this.name = name; this.score = score; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public T getScore() &#123; return score; &#125; public void setScore(T score) &#123; this.score = score; &#125; @Override public String toString() &#123; return "姓名：" + name + ", 成绩：" + score; &#125;&#125;public class TestStudentScore &#123; public static void main(String[] args) &#123; Student&lt;Integer&gt; s1 = new Student&lt;Integer&gt;("张三",89); Integer score = s1.getScore(); Student&lt;Integer&gt; s2 = new Student&lt;Integer&gt;();// s2.setScore("优秀"); s2.setScore(99); &#125;&#125; 泛型上限12345678910class Person&lt;T extends Person&gt;&#123; private T parnter;//伴侣&#125;class Man extends Person&lt;Woman&gt;&#123; &#125;class Woman extends Person&lt;Man&gt;&#123; &#125; 注意： (1)不可将类定义泛型的类型作为类的静态成员的数据类型。 (2)泛型类和泛型接口上的泛型形参可以指定上限T extends xx,一旦泛型形参指定上限xx，泛型实参就不能超过它，只能指定为它或它的子类类型。 泛型类的泛型继承123456789101112131415161718192021class Father&lt;T1,T2&gt;&#123; &#125;//子类不保留父类的泛型//1)没有类型 擦除class Son extends Father&#123;//等价于class Son extends Father&lt;Object,Object&gt;&#123; &#125;//2)具体类型class Son2 extends Father&lt;Integer,String&gt;&#123; &#125;//子类保留父类的泛型//1)全部保留class Son3&lt;T1,T2&gt; extends Father&lt;T1,T2&gt;&#123; &#125;//2)部分保留class Son4&lt;T2&gt; extends Father&lt;Integer,T2&gt;&#123; &#125; 123456789101112131415161718192021class Father&lt;T1,T2&gt;&#123; &#125;//子类不保留父类的泛型//1)没有类型 擦除class Son&lt;A,B&gt; extends Father&#123;//等价于class Son extends Father&lt;Object,Object&gt;&#123; &#125;//2)具体类型class Son2&lt;A,B&gt; extends Father&lt;Integer,String&gt;&#123; &#125;//子类保留父类的泛型//1)全部保留class Son3&lt;T1,T2,A,B&gt; extends Father&lt;T1,T2&gt;&#123; &#125;//2)部分保留class Son4&lt;T2,A,B&gt; extends Father&lt;Integer,T2&gt;&#123; &#125; 使用泛型类时未指定泛型的具体类型：类似于Object，不等同于Object的泛型擦除，默认按照Object处理但编译不会类型检查,明确指定Object，编译会按Object类型检查. 给泛型类传递实参可以在泛型类实例化时，也可以在继承了泛型类的子类中传递，或者子类继续基础泛型形参类型，在它生成对象时传递实参。 泛型方法（1）当某一个方法中它的形参类型等类型不确定时，和其他方法无关，那么这样的情况下，可以为这一个方法单独设计泛型形参。（2）当某些静态方法需要泛型形参时，也要单独设计，因为它不能用类上的泛型。1【修饰符】 &lt;泛型形参列表&gt; 返回值类型 方法名（【形参列表】）抛出的异常列表 1234567891011121314151617181920212223public class TestMyArrays &#123; public static void main(String[] args) &#123; Integer[] arr = &#123;1,2,3,4&#125;; String str = MyArrays.toString(arr); System.out.println(str); &#125;&#125;class MyArrays&#123; public static &lt;T&gt; String toString(T[] arr)&#123; String str = "["; int i = 0; for (T t : arr) &#123; str += t; if(i!=arr.length-1)&#123; str += ","; &#125; i++; &#125; str += "]"; return str; &#125;&#125; 注意：调用此方法时，泛型形参的类型和方法的形参的值都由实参决定，并且泛型方法声明泛型时也可以指定上限。 泛型通配符注意：通配符？一般出现在方法的形参类型上，不能在类/接口上出现，表示可以接收任意，解决了泛型不支持继承的问题。1234567891011121314151617&#123; ArrayList list = new ArrayList(); list.add(1); list.add(&apos;1&apos;); list.add(&quot;厉害了&quot;); new Main().test1(list); &#125; public void test1(ArrayList&lt;?&gt; list)&#123; /*list.add(&quot;hello&quot;); list.add(1);*/ for (Object object : list) &#123; System.out.println(object); &#125; &#125; 此时通配符泛型作为方法的形参，可以接收任意的通配符形参，但是上面这段代码只可以读取，不可以添加，而且也没有起到泛型应该履行的职责，所以不建议这样使用。 1public void test2(ArrayList&lt;Object&gt; list)&#123;&#125; 明确指明泛型类型又没有使用到通配符。如果此时形参集合未指明泛型，即擦除泛型，那么还是按照Object来定义。1234ArrayList&lt;?&gt; list = new ArrayList();list = new ArrayList&lt;String&gt;();list = new ArrayList&lt;Integer&gt;();list = new ArrayList&lt;Object&gt;(); 通配符泛型的正确使用方式。 extends是上限，super是下限。1public void putAll(Map&lt;? extends K,? extends V&gt; m) 泛型通配符的使得子类的类型不得大于超过K的值。12345678910 //K：Fu,V：Zi,Zi继承Fu，Fu继承YEYE HashMap&lt;Fu,Zi&gt; map = new HashMap&lt;&gt;();// 对于map而言他的KV的上限就是FU与Zi HashMap&lt;Zi,SunZi&gt; map2 = new HashMap&lt;&gt;(); map.putAll(map2);// map2的KV均小于map所以可以进行操作 HashMap&lt;YeYe,SunZi&gt; map3 = new HashMap&lt;YeYe,SunZi&gt;();// map.putAll(map3);//map3的K并不小于等于Fu所以不能直接操作 12// 将T... elements多个元素add到c中，所以T的类型要小于等于cpublic static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements) 1234567 ArrayList&lt;Fu&gt; list = new ArrayList&lt;Fu&gt;(); Collections.addAll(list, new Zi(),new Zi());//T解读为Zi ArrayList&lt;SunZi&gt; list2 = new ArrayList&lt;SunZi&gt;(); // Collections.addAll(list2, new Zi(),new Zi());// 同理这样也是会报错的， 使用泛型1234567891011121314151617181920public class TestExer1 &#123; public static void main(String[] args) &#123; HashMap&lt;String, ArrayList&lt;String&gt;&gt; map = new HashMap&lt;String,ArrayList&lt;String&gt;&gt;(); ArrayList&lt;String&gt; bj = new ArrayList&lt;String&gt;(); bj.add(&quot;北京市&quot;); map.put(&quot;北京市&quot;, bj); ArrayList&lt;String&gt; hn = new ArrayList&lt;String&gt;(); hn.add(&quot;海口市&quot;); hn.add(&quot;三亚市&quot;); map.put(&quot;海南省&quot;, hn); Set&lt;Entry&lt;String, ArrayList&lt;String&gt;&gt;&gt; entrySet = map.entrySet(); for (Entry&lt;String, ArrayList&lt;String&gt;&gt; entry : entrySet) &#123; System.out.println(entry); &#125; &#125;&#125; 使用泛型时的注意事项泛型没有多态如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G并不是G的子类型！比如：String是Object的子类，但是List并不是List的子类。1ArrayList&lt;Fu&gt; list = new ArrayList&lt;Zi&gt;();//泛型没有多态,所以这样是会报错的 要实现这样类似多态要使用通配符泛型1ArrayList&lt;? extends Fu&gt; list = new ArrayList&lt;Zi&gt;();//使用通配符可以实现 没有泛型数组1Tiger&lt;String&gt;[] as = new Tiger&lt;String&gt;[];//是错误的，没有泛型数组 不能在try-catch中使用泛型定义1234// 错误，不可以再此处使用泛型try&#123;&#125;catch(T t)&#123;&#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lambda]]></title>
    <url>%2F2018%2F06%2F12%2Flambda%2F</url>
    <content type="text"><![CDATA[关于Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。很长一段时间java被吐槽是冗余和缺乏函数式编程能力的语言，随着函数式编程的流行java8也引入了这种编程风格。在此之前我们都在写匿名内部类干这些事，但是并不出色。在JS，python等语言中，lambda使用十分广泛，Java吸取其他语言的优点，增加了这个新特性，非常好用。 匿名内部类实现将一段代码作为数据传递使用。12345678910class lambda &#123; public static void main(String[] args)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("nothing");// nothing &#125; &#125;).run(); &#125;&#125; 当然，匿名内部类的作用就是用来当作数据使用的代码块，他的缺点就是，代码过于冗长，实现一个简单的功能也要写上很多代码，代码也没有复用性使得代码冗长，不好阅读。 使用lambda12345678class lambda &#123; public static void main(String[] args)&#123; Runnable r = () -&gt; System.out.println("anything"); r.run();// anything new Thread(() -&gt; System.out.println("everything")).start();//everything &#125;&#125; 可以看出lambda函数式更加的简便，lambda表达式关注参数和方法体，而没有方法名，这也很符合匿名函数这个名字。 lambda函数调用方式12//无参无返回值Runnable r = () -&gt; System.out.println(&quot;anything&quot;); 注意：()不能省略，如果{}中只有一个语句，那么{}可以省略。1234567891011121314// 有参无返回值// list.forEach((String element) -&gt; &#123;System.out.println(element);&#125;);// 完全形态 // list.forEach((String element) -&gt; System.out.println(element));// 方法体只有一个语句 // list.forEach((element) -&gt; System.out.println(element));// 形参只有一个，且数据类型明确，可以省去数据类型 list.forEach(element -&gt; System.out.println(element));// 括号都可以不要 ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); arr.add(1); arr.add(5); arr.add(3); arr.forEach(t -&gt; System.out.println(t)); 注意：如果{}中只有一个语句，那么{;}可以省略;如果形参的类型是明确的，那么数据类型可以省略;如果形参的类型省略了，而且形参的个数只有一个，那么()可以省略.1234// 无参有返回值// Supplier&lt;String&gt; s = () -&gt; &#123;return new String();&#125;; Supplier&lt;String&gt; s = () -&gt; new String(); 注意：()不可以省略，如果{}中只有一个语句，那么{return ;}可以省略。123456789101112131415161718192021222324252627// 有参有返回值class lambda &#123; public static void main(String[] args)&#123; ArrayList&lt;Student&gt; arr = new ArrayList&lt;&gt;(); arr.add(new Student(1)); arr.add(new Student(5)); arr.add(new Student(3)); Collections.sort(arr,(t1, t2) -&gt; t1.id-t2.id); arr.forEach(a -&gt; System.out.println(a)); &#125;&#125;class Student&#123; int id; Student(int id)&#123; this.id = id; &#125; @Override public String toString() &#123; return &quot;Student id = &quot; + id; &#125;&#125; 注意：如果{}中只有一个语句，那么{return ;}可以省略；如果形参的类型是明确的，那么数据类型可以省略；如果形参的类型省略了，而且形参的个数只有一个，那么()可以省略。 四大核心函数式接口lambda表达式应用于这些函数式接口。这几个函数式接口都定义在java.util.function下。本质上本质上它们都是一个接口，但是它是一种特殊的接口：SAM类型的接口（Single Abstract Method）。特点是：函数式接口中有且只能有一个抽象方法，当然可以有静态方法和默认方法，还可以有Object中的方法。只能是符合函数式接口的变量，形参才能赋值为一个Lambda表达式。所以建议在声明一个接口时，如果明确要表示这个接口是一个函数式接口，那么最好在接口声明的上方加上注解：@FunctionalInterface。 消费型接口：Consumer12345678910@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t); default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125;&#125; 注解说明是一个函数接口，声明一个方法，方法的参数时T类型。基本特征：有参无返回值，相当于消费了，所以称作消费型接口。 供给型接口：Supplier12345678910@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get();&#125; 特点：不需要参数就可以得到某类型参数，无中生有供给型函数式接口。 函数型接口：Function12345678910@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t); default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); &#125;&#125; 特点：Function需要两个参数(可不同类型)，返回值为一个。Function衍生出一些特别的子类BiFunction，DoubleFunction等。 断定型接口：Predicate123public interface Predicate&lt;T&gt; &#123; boolean test(T t); &#125; 断定型的特点是对于传入的对象返回一个boolean类型的结果，也衍生出DoublePredicate，IntPredicate等接口。 方法引用特点：实现抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！使用方式：123（1）类名::实例方法名（2）对象::实例方法名（3）类名::静态方法名 三种方式：123456789101112131415public class Main &#123; public static void main(String[] args) &#123; Comparator&lt;String&gt; c = new Comparator&lt;String&gt;()&#123; @Override public int compare(String o1, String o2) &#123; return o1.compareTo(o2); &#125; &#125;; Comparator&lt;String&gt; s = (t1, t2) -&gt; t1.compareTo(t2); Comparator&lt;String&gt; s1 = String :: compareTo; &#125;&#125; 方法引用虽然使用起来非常简便，但是条件却是非常的苛刻。12345678910public void test()&#123; List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;,&quot;world&quot;); //forEach形参的类型是java.util.function.Consumer&lt;T&gt;接口 //抽象方法：有参无返回值void accept(T t) //(1)Lambda是通过调用现成System.out对象的println()方法完成，而且也是有参无返回值 //(2)而且accept的形参，正好是println()的实参 list.forEach(t -&gt; System.out.println(t)); list.forEach(System.out::println);&#125; 123456789public void test4()&#123; //方法体的实现得到两个小数当中的最大值 BinaryOperator&lt;Double&gt; bo = (a,b) -&gt; Math.max(a,b); // apply(T t1, T t2)两个形参，正好是给max的两个实参 // 返回值类型 apply(T t1, T t2)的返回值是T，这里是Double // 而我们max的返回值类型也是a,b类型，Double BinaryOperator&lt;Double&gt; bo2 = Math::max;&#125; 构造器引用构造器引用的Lambda体是通过创建一个对象完成的。使用方式类名::new示例1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestConstrunctorReference &#123; public void test4()&#123; //函数型：Function&lt;T,R&gt; : R apply(T t) Function&lt;Integer,String[]&gt; f = len -&gt; new String[len]; Function&lt;Integer,String[]&gt; f2 = String[]::new; &#125; public void test3()&#123; //函数型：BiFunction&lt;T,U,R&gt; : R apply(T t,U u) BiFunction&lt;String,Integer,Person&gt; f = (name,id) -&gt; new Person(name,id); BiFunction&lt;String,Integer,Person&gt; f2 = Person::new; &#125; public void test2()&#123; //函数型：Function&lt;T,R&gt; : R apply(T t) Function&lt;String,Person&gt; f = name -&gt; new Person(name); Function&lt;String,Person&gt; f2 = Person::new; &#125; public void test()&#123; //供给型：Supplier&lt;T&gt; : T get()，无参有返回值 Supplier&lt;String&gt; s = () -&gt; new String(); Supplier&lt;String&gt; s1 = String::new; Supplier&lt;Person&gt; p = () -&gt; new Person(); Supplier&lt;Person&gt; p2 = Person::new; &#125;&#125;class Person&#123; private String name; private int id; public Person(String name, int id) &#123; this.name = name; this.id = id; &#125; public Person(String name) &#123; this.name = name; &#125; public Person() &#123; &#125;&#125; Optional一般会与lambda语句一同使用，用于解决Java常见的空指针异常，Optional本质是一个存放对象的容器，解决空指针异常的本质就是不用我们显式的判断数据是否为null了，但是空值判断还是要以其他方法进行(Optional的方法)。 创建Optional的三种方式 （1）Optional.empty()：空的容器，里面相当于是封装的是null； （2）Optional.of(非空对象)； （3）Optional.ofNullable(可以是null可以不是null)。Optional方法 获取数据：get()：从容器中取出对象，但是要求这个容器中对象必须非空；orElseGet(Supplier s)：从容器中取出对象，如果这个容器中的对象是非空，那么就取出这个对象给调用者，如果这个容器的对象是空的，那么就由Supplier这个供给型接口的实现方法来提供一个对象给调用者。这两种方式得到的对象一定不是空的，而且也没有显式进行空值判断。 判断是否容器中包含对象：isPresent()，判断是否存在，如果存在，对这个对象执行由Comsumer接口指定的操作：ifPresent(Consumer&lt;? super T&gt; consumer)。 orElse(T t):从容器中取出对象，如果这个容器中的对象是非空，那么就取出这个对象给调用者，如果这个容器的对象是空的，那么就由t对象代替。 orElseThrow(Supplier s)：从容器中取出对象，如果这个容器中的对象是非空，那么就取出这个对象给调用者，如果这个容器的对象是空的，那么就报由Supplier提供异常信息返回。 Optional filter(Predicate&lt;? super T&gt; predicate) ：判断当前Optional容器中是否存在对象，并且是否满足Predicate指定的条件判断，如果满足，那么就返回一个合理的Optional对象，如果不存在或不满足条件，就返回一个Empty的Optional。 Optional map(Function&lt;? super T,? extends U&gt; mapper)，如果当前Optional容器中对象是null，就什么也不干，如果是非空的对Optional容器中对象进行某种操作，按照Function指定的操作进行，返回有Function的操作完的结果返回。使用Optional123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146public class TestOptional &#123; public void test12()&#123; Optional&lt;List&lt;Integer&gt;&gt; of = Optional.of(Arrays.asList(6,3,2,9,10)); //取出集合中的最大值 Optional&lt;Integer&gt; max = of.flatMap(list -&gt; &#123;Collections.sort(list); return Optional.of(list.get(list.size()-1));&#125;); System.out.println(max); &#125; public void test11()&#123; Optional&lt;List&lt;Integer&gt;&gt; of = Optional.of(Arrays.asList(6,3,2,9,10)); //取出集合中的最大值 Optional&lt;Integer&gt; max = of.map(list -&gt; Collections.max(list)); System.out.println(max); &#125; public void test10()&#123; Student stu = new Student("张三",78); Optional&lt;Student&gt; of = Optional.ofNullable(stu); //取出学生对象的姓 Optional&lt;String&gt; map = of.map(t -&gt; t.getName().substring(0, 1)); System.out.println(map); &#125; public void test9()&#123; Student stu = new Student("张三",78); Optional&lt;Student&gt; of = Optional.ofNullable(stu);// Optional&lt;Student&gt; of = Optional.ofNullable(null); //对of中的对象，加10分，如果of中的对象不为空的话 //参数：Function&lt;T,R&gt;：R apply(T t) Optional&lt;Student&gt; map = of.map(t -&gt; &#123;t.setScore(t.getScore()+10); return t;&#125;); System.out.println(map); &#125; public void test8()&#123; Student stu = new Student("张三",78);// Optional&lt;Student&gt; of = Optional.ofNullable(stu); Optional&lt;Student&gt; of = Optional.ofNullable(null); //判断of中包装的学生，成绩是否是&gt;=60分，如果是，返回该学生对象，如果不是，返回空 //Predicate&lt;T&gt;：boolean test(T t) Optional&lt;Student&gt; result = of.filter(t -&gt; t.getScore()&gt;=60); System.out.println(result); &#125; public void test7()&#123;// Optional&lt;String&gt; of = Optional.ofNullable("张三"); Optional&lt;String&gt; of = Optional.ofNullable(null); //形参是Supplier&lt;T&gt;: T get() String name = of.orElseThrow(() -&gt; new RuntimeException("用户名不存在")); System.out.println(name); &#125; public void test6()&#123;// Optional&lt;String&gt; of = Optional.ofNullable("张三"); Optional&lt;String&gt; of = Optional.ofNullable(null); String name = of.orElse("无名"); System.out.println(name); &#125; public void test5()&#123; Optional&lt;String&gt; of = Optional.ofNullable("张三"); //如果是空的，就什么也不做，如果不是空的，截取出它的姓，并打印 //形参类型是：Consumer&lt;T&gt;：void accept(T t) of.ifPresent(name -&gt; System.out.println(name.substring(0,1))); &#125; public void test4()&#123; Optional&lt;String&gt; of = Optional.ofNullable(null); //因为of容器中的对象可能是null，可能不是null //那么可以判断 System.out.println(of.isPresent()); &#125; public void test3()&#123; Optional&lt;String&gt; of = Optional.ofNullable(null);// String string = of.get();//从容器中取出元素// System.out.println(string);//No value present //orElseGet(Supplier s) //Supplier&lt;T&gt;：T get()// String s2 = of.orElseGet(() -&gt; new String()); String s2 = of.orElseGet(String::new); System.out.println(s2); String address = "beijing"; if(s2.equals(address))&#123; System.out.println("地址是北京"); &#125; &#125; public void test2()&#123; String address = "beijing"; Optional&lt;String&gt; of = Optional.of(address); String string = of.get();//从容器中取出元素 System.out.println(string); &#125; public void test()&#123; Optional&lt;Object&gt; empty = Optional.empty(); System.out.println(empty); String address = "beijing"; Optional&lt;String&gt; of = Optional.of(address); System.out.println(of); // Student stu = null; Student stu = new Student(); Optional&lt;Student&gt; of2 = Optional.ofNullable(stu); System.out.println(of2); &#125;&#125;class Student&#123; private String name; private int score; public Student(String name, int score) &#123; this.name = name; this.score = score; &#125; public Student() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getScore() &#123; return score; &#125; public void setScore(int score) &#123; this.score = score; &#125; @Override public String toString() &#123; return "Student [name=" + name + ", score=" + score + "]"; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map]]></title>
    <url>%2F2018%2F06%2F12%2FMap%2F</url>
    <content type="text"><![CDATA[MapMap与Collection并列存在。用于保存具有映射关系的数据:Key-Value。Map中的key和value都可以是任何引用类型的数据，Map中的key不允许重复，key和value之间存在单向一对一关系，即通过指定的key总能找到唯一的、确定的value。Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。允许使用null键和null值，与HashSet一样，不保证映射的顺序。 Map常用方法 添加：put(Object key,Object value)：添加一对k-v，putAll(Map m)：把m的Map的映射关系都添加到当前map中。 获取有效映射关系的对数：size()。 可以根据key获取value：Object get(Object key)。 删除：remove(Object key)，clear()。 是否包含：boolean containsKey(Object key)，boolean containsValue(Object value)。 是否为空：isEmpty()。 遍历Map123456789101112131415161718192021System.out.println(&quot;map的所有key:&quot;);Set keys = map.keySet();//HashSetfor(Object key : keys)&#123; System.out.println(key+&quot;-&gt;&quot;+map.get(key));&#125;System.out.println(&quot;map的所有的value：&quot;);Collection values = map.values();Iterator iter = values.iterator();while(iter.hasNext())&#123; System.out.println(iter.next());&#125;System.out.println(&quot;map所有的映射关系：&quot;);//映射关系的类型是Map.Entry类型，它是Map接口的内部接口Set mappings = map.entrySet();for(Object mapping : mappings)&#123; //System.out.println(mapping); Map.Entry entry = (Map.Entry)mapping; System.out.println(&quot;key是：&quot;+ entry.getKey()+ &quot;，value是：&quot;+entry.getValue());&#125; 注意： Map的遍历，不能支持foreach； 可以单独遍历所有key，根据key获取对应value； 可以单独遍历value； 成对遍历：遍历的是映射关系Map.Entry，Map.Entry是Map接口的内部接口。每一种Map内部有自己的Map.Entry的实现类。在Map中存储数据，实际上是将Key，value的数据存储在Map.Entry接口的实例中，再在Map集合中插入Map.Entry的实例化对象。 HashMapHashMap判断key与value是否相等的操作与HashSet的方式一致（hashcode与equals）。 1.8之前的HashMapHashMap的内部存储结构其实是数组和链表的结合。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。 1.8之后的HashMapHashMap的内部存储结构其实是数组和链表/树的结合。当实例化一个HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last,或树的叶子结点。（七上八下） HashMap什么时候进行扩容和树形化呢？当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树在转为链表。 LinkedHashMap是HashMap的子类，维护了添加的顺序。效率更低，在添加，删除时，要多费心来维护前后的关系。 TreeMapTreeMap存储 Key-Value 对时，需要根据 key进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。 TreeMap 的 Key 的排序分为两种：自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException；定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。若使用自定义类作为TreeMap的key，所属类需要重写equals()和hashCode()方法，且equals()方法返回true时，compareTo()方法应返回0。 HashtableHashtable与HashMap基本上实现都一样，只是Hashtable是个比较老的 Map 实现类（JDK1.0），它是线程安全，HashMap线程不安全。与HashMap不同的是Hashtable 不允许使用 null 作为 key 和 value。 PropertiesProperties 类是 Hashtable 的子类，该对象用于处理属性文件，由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型，存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法。 注意： 不管哪种Map，添加到map中后，这个key就不用修改了，特别是这个属性值涉及到hashCode和equals或comparexx的计算或比较的属性。一旦修改了key，和原来的key就不一样，那么就找不到原来的数据了。所以实际开发中，比较多见把String或Integer这样的不可变的类型作为key值。 Map集合框架]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection]]></title>
    <url>%2F2018%2F06%2F11%2FCollection%2F</url>
    <content type="text"><![CDATA[前言在说集合之前，要先提一下数组这个数据结构。数组本身是一个线性的数据结构，从物理结构看是一个顺序存储结构。每次申请一段连续的空间，一旦申请到，内存就固定了。所有数据存储在这个连续的空间中，数组中的每一个元素都是一个具体的数据（或对象），所有数据都紧密排布，不能有间隔。数组可以通过下标快速的查找元素，但是当数组做插入和删除操作操作时，效率则会极其的低下，而且也不能直接访问到当前数组中有效元素的个数。介于数组的缺点，为满足数据更多种的逻辑关系，而设计的一系列的不同于数组的可变的聚合的抽象数据类型，被称作集合。 特点 盛放数据的逻辑概念； 实现集合的底层物理结构是数组和链表。底层的逻辑结构有在物理结构的基础上又封装了一层，对于使用者来说，不用关心内部的物理结构，通过方法直接来使用它的功能； 具备功能：添加，删除，查找获取，和直接获取有效元素的个数； Java集合分为两类，Collection和Map（可理解为list和dict，但是种类复杂得多）； 只能存放对象； 容量自动调节。​CollectionCollection简介Collection层次结构中的根接口。Collection表示一组对象，这些对象也称为collection的元素。一些collection允许有重复的元素，而另一些则不允许。一些collection是有序的，而另一些则是无序的。JDK不提供此接口的任何直接实现：它提供更具体的子接口（如Set和List）实现。此接口通常用来传递collection，并在需要最大普遍性的地方操作这些collection。Collection(java.util)继承了Iterable(java.lang)，所以集合都是可以迭代的,Iterable(java.lang)是集合类的最上层接口。12345678public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; default void forEach(Consumer&lt;? super T&gt; action) &#123;// Iterable方法，1.8后增加，用于lambda遍历 Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125;&#125; Collection方法Collection里规定了很多方法： 添加:add(Object obj),添加单个对象，addAll(Collection coll)：添加一组对象。 删除：remove(Object o)，删除单个对象，removeAll(Collection c)，删除两个集合的交集部分，clear()：清空。 查找：contains(Object o)，是否包含某个对象，containsAll(Collection c)，是否包含某个集合。 isEmpty()是否空集。 size()获取有效元素的个数。 Object[] toArray()返回所有对象。 retainAll(Collection c)保留当前集合与c交集的部分。 Iterator iterator()获取当前集合的迭代器对象，迭代器对象可用来遍历当前集合。 Collection操作操作Collection：12// c可以进行上述的方法操作Collection c = new ArrayList(); Collection特点 Collection本身不可以直接而实例化对象，操作Collection就是操作的Collection的子类(可隔代)实例化对象操作。 Collection是一个上层概念，但是Collection还有上层，Collection的上层是Iterable，Collection继承了它。 Collection包含了集合的基本操作方法，但是大多数方法都未实现，只是定义了接口，需要不同的子接口根据需求自行实现。 ListList是Collection的子接口之一，它实现了很多方法，除了父接口继承的以外又增加了一些。List的特点是单值，有序，可重复。1public interface List&lt;E&gt; extends Collection&lt;E&gt; List方法1get， set， lastIndexOf， listIterator， subList等 List特点 List是Collection的子接口，同时它也是一个上层接口，它不直接实现对象，使用List类型的集合需要使用实现了它的子类的实例； List相较于Collection也增建了一些接口，但是都是抽象接口，它本身并未实现； 所有的List共有特点单值，有序，可重复； 它实现一个ListIterator迭代器，这个迭代器相较于Iterator又增加了一些实用的方法。 ArrayList和Vector(动态数组)共同父类AbstractCollection1public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt;// 具体实现了indexOf和lastIndexOf，clear，addAll， AbstractList具体实现了indexOf和lastIndexOf，clear，addAll，removeRange等，定义（private class Itr implements Iterator）内部类具体实现迭代的细节（内部类方式实现迭代）。 两者异同比较123456// 发行时间不同 * @since 1.2public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable * @since JDK1.0public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 1234// 底层实现物理结构都是数组transient Object[] elementData; // non-private to simplify nested class accessprotected Object[] elementData; 1234567891011121314151617181920212223242526272829303132333435// 创建与扩容机制不同 private static final int DEFAULT_CAPACITY = 10;// 默认创建长度是10，但是初始化数组为空时集合长度0，直到加入数据时长度变为10 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 扩容1.5倍 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; public Vector() &#123; this(10);//初始是10字节 &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity);// 扩容一倍或capacityIncrement多字节 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); &#125; 异同总结： 共同父类AbstractCollection，内部很多方法都基本一致； 两者底层实现都是数组的操作； 版本不同ArrayList(1.2)比Vector(1.0)新； Vector线程安全，效率略低，ArrayList线程不安全，效率高 扩容机制不同通过无参构造创建Vector时，默认的数组的长度为10，当容量不够，扩容要么按照指定的capacityIncrement进行扩容，要么扩大为原来的2倍；通过无参构造创建ArrayList对象时，默认是初始化为一个长度为0空数组常量。如果一开始是初始化为空数组时，当添加第一个元素时，扩容为长度为10的数组。当容量再不够时，扩容为原来的1.5倍，尽量减少浪费。 注意：ArrayList在JDK1.7及以前一开始就会扩容长度10的数组。 LinkedList123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable LinkedList也是List的实现类，他的逻辑结构类似于双端连接的链表。 LinkedList特点 动态数组需要开辟连续的空间，而双向链表不需要，是通过结点(Node)的互相“引用，连接”的方法把集合的元素串起来； LinkedList遍历查找的效率低，因为动态数组位置连续的，还可以根据索引index直接定位位置，而LinkedList只能从head或last两头开始遍历查找； LinkedList在频繁的插入、指定对象删除一个对象时，效率反而高，因为不涉及移动大量的元素，只需要修改前后元素的next,pre即可。 注意：实现List接口的还有一种集合，Stack，栈结构特点先入后出，平时使用并不多。 List新增方法 add，add(index, obj)：指定位置添加，addAll(index, Collection c)：指定位置插入集合c； get(index)获取指定位置的元素； indexOf(obj)：返回第一个找到的对象的索引，没有就返回-1，int lastIndexOf(Object o) ：返回最后一个找到的对象的索引，没有返回-1； set(index,value)，设定指定位置对象； subList(int fromIndex, int toIndex)，截取当前列表的一部分； ListIterator listIterator()，ListIterator继承了Iterator。ListIterator方法123456* （1）hasPrevious()：是否有前一个元素* （2）previous() ：取出前一个元素* （3）add(Object)：说明可以在遍历的同时添加元素* （4）set(Object)：说明可以在遍历的同时替换元素* （5）nextIndex()：下一个元素的索引* （6）previousIndex()：前一个元素的索引 SetSet接口是Collection的子接口，set接口没有提供额外的方法，Set不保证添加顺序，数据不可重复。Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals 方法。因此存放到Set集合中的元素一定要注意equals方法的重写。Set的常用实现类有：HashSet、TreeSet、LinkedHashSet。 HashSetHashSet：依据元素的hashCode()和equals()方法，来确定它的存储的顺序和保证不可重复，认为两个对象equals相等，即是重复元素，不能保证元素的排列顺序，非线程安全，元素可以为null。底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍。 工作方式：当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据hashCode值，通过某种散列函数决定该对象在HashSe 中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）。如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败，如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链接。TreeSet：依据元素的“大小”顺序来确定他的存储顺序和保证不可重复，认为两个对象“大小”相等，即是重复的元素，元素的“大小”顺序依赖于Comparable或Comparator的接口的实现方法。 LinkedHashSetLinkedHashSet：LinkedHashSet是HashSet的子类，既延续了父类的特征，又扩展了一些特性，元素是有序的，比HashSet多维护了添加时前后元素的关系，效率低。 集合遍历集合遍历有三种方式：集合调用方法返回数组，然后通过for循环遍历数组；直接使用foreach遍历集合；通过迭代器遍历集合。123456789101112131415161718192021222324252627282930public void test()&#123; Collection big = new ArrayList(); big.add(&quot;老大&quot;); big.add(&quot;老二&quot;); big.add(&quot;jefflike&quot;); // 方式一：for循环 Object[] array = big.toArray(); for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125; // 方式二：foreach for (Object object : big) &#123; System.out.println(object); &#125; // 方式三：Iterator迭代 Iterator iterator = big.iterator();//直接就返回一个迭代器对象 while(iterator.hasNext())&#123; Object next = iterator.next(); if(&quot;老大&quot;.equals(next))&#123; iterator.remove(); &#125; &#125; for (Object object : big) &#123; System.out.println(object); &#125;&#125; 三种遍历集合方式的比较： foreach和Iterator没有下标信息； foreach不能修改元素； for下标遍历应用不广泛，效率不如foreach高； Iterator可以在遍历过程中进行删除，修改等操作； 迭代器是一个独立的对象，他有自己的方法与属性，它以内部类方式实现。 集合的继承关系：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String StringBuffer和StringBiuld]]></title>
    <url>%2F2018%2F06%2F11%2FStringAndStringBufferAndStringBiuld%2F</url>
    <content type="text"><![CDATA[前言通过前面查看String的源码，对String也有一定的了解了，String是编程语言里时常会使用到的数据类型，虽然Java里的String不是基本数据类型，但是他的重要性绝对不亚于基本数据类型的。关于String类型的问题，最大的一点就是String本身是一个不可变的数据类型，在完成大量的字符串拼接的情况下，非常的低效，所以后来就衍生出了可变字符序列。 可变字符序列是怎样实现的对于可变字符序列，他的底层还是字符数组，只是通过控制创建字符数组的长度，来减少新数组创建的次数，从而使得字符序列修改增删变得非常的便捷快速。 代码细节(以StringBuffer为例)底层实现依然是字符数组：1private transient char[] toStringCache; 构造器1234567891011121314151617public StringBuffer() &#123; super(16);// 初始化底层的字符数组的长度就是16&#125;public StringBuffer(int capacity) &#123; super(capacity);// 可以指明初始化时的字符数组的长度&#125;public StringBuffer(String str) &#123; super(str.length() + 16); append(str);&#125;public StringBuffer(CharSequence seq) &#123; this(seq.length() + 16); append(seq);&#125; 后两个构造器，初始化的字符数组的长度，比传入的字符大16，就是为了方便字符数组的扩容而准备充足的空间。 方法1234@Overridepublic synchronized int length() &#123; return count;&#125; 字符数组的长度。 1234@Overridepublic synchronized int capacity() &#123; return value.length;&#125; 当前容器的容量。 123456@Overridepublic synchronized char charAt(int index) &#123; if ((index &lt; 0) || (index &gt;= count)) throw new StringIndexOutOfBoundsException(index); return value[index];&#125; 索引为index的字符。 123456public synchronized void setCharAt(int index, char ch) &#123; if ((index &lt; 0) || (index &gt;= count)) throw new StringIndexOutOfBoundsException(index); toStringCache = null; value[index] = ch;&#125; 修改索引为index的字符。 reverse方法12345678910111213141516171819public AbstractStringBuilder reverse() &#123; boolean hasSurrogates = false; int n = count - 1; for (int j = (n-1) &gt;&gt; 1; j &gt;= 0; j--) &#123; int k = n - j; char cj = value[j]; char ck = value[k]; value[j] = ck; value[k] = cj; if (Character.isSurrogate(cj) || Character.isSurrogate(ck)) &#123; hasSurrogates = true; &#125; &#125; if (hasSurrogates) &#123; reverseAllValidSurrogatePairs(); &#125; return this;&#125; 重载了很多序列增删改查的方法，具体实现都是继承的父类相应的方法。 父类的序列扩容策略：123456789101112131415161718private int newCapacity(int minCapacity) &#123; // overflow-conscious code int newCapacity = (value.length &lt;&lt; 1) + 2;// 扩容为两倍+2 if (newCapacity - minCapacity &lt; 0) &#123; newCapacity = minCapacity;// 还不够就增加至当前的长度 &#125; return (newCapacity &lt;= 0 || MAX_ARRAY_SIZE - newCapacity &lt; 0) ? hugeCapacity(minCapacity) : newCapacity;&#125;private int hugeCapacity(int minCapacity) &#123; if (Integer.MAX_VALUE - minCapacity &lt; 0) &#123; // overflow throw new OutOfMemoryError();//字符长度超出容量的最大值了 &#125; return (minCapacity &gt; MAX_ARRAY_SIZE) ? minCapacity : MAX_ARRAY_SIZE;&#125; 最近看到有面试题将String，StringBuffer和StringBuilder拿来作比较，所以就看了一下这三种类型，并且将他们做一个比较。 首先String是不可变的字符序列(不能原地修改)，StringBuffer和StringBuilder是可变字符序列(可以原地修改)； String底层数组不可扩容，StringBuffer和StringBuilder底层数组可扩容，默认的长度是16字节，扩容时先扩大两倍+2，如果还不够则将字符数组的最小长度作为数组长度； String可以直接创建常量值，而StringBuffer和StringBuilder只能用new的方式创建新对象； StringBuffer和StringBuilder支持链式调用，例如append方法的返回值就是this，String是不可以链式调用的。 StringBuffer和StringBuilder的区别是：StringBuffer：线程安全，效率较慢；StringBuilder： 线程不安全，效率较高。这里效率指的是修改字符串的效率，当然效率快慢是这两者之间的比较，StringBuffer还是比String快的多的。比较一下效率：1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestTime &#123; public static void main(String[] args) &#123; testStringBuilder();// testStringBuffer();// testString(); &#125; public static void testString()&#123; long start = System.currentTimeMillis(); String s = new String("0"); for(int i=1;i&lt;=10000;i++)&#123; s += i; &#125; System.out.println(s); long end = System.currentTimeMillis(); System.out.println("String拼接+用时："+(end-start));//445 long memory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory(); System.out.println("String拼接+memory: " + memory);// 53169472 &#125; public static void testStringBuilder()&#123; long start = System.currentTimeMillis(); StringBuilder s = new StringBuilder("0"); for(int i=1;i&lt;=10000;i++)&#123; s.append(i); &#125; System.out.println(s); long end = System.currentTimeMillis(); System.out.println("StringBuilder拼接+用时："+(end-start));//10 long memory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory(); System.out.println("StringBuilder拼接+memory: " + memory);//1950488 &#125; public static void testStringBuffer()&#123; long start = System.currentTimeMillis(); StringBuffer s = new StringBuffer("0"); for(int i=1;i&lt;=10000;i++)&#123; s.append(i); &#125; System.out.println(s); long end = System.currentTimeMillis(); System.out.println("StringBuffer拼接+用时："+(end-start));//12 long memory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory(); System.out.println("StringBuffer拼接+memory: " + memory);//1950488 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ClassLoader]]></title>
    <url>%2F2018%2F06%2F10%2FClassLoader%2F</url>
    <content type="text"><![CDATA[类加载过程从本质上来说，JVM在加载Java程序的时候，先从main入口开始加载main所在的类，在运行main函数的过程中遇到需要加载其他的类，那么就会先加载其他的类。 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据（类的成员等）只能通过这个Class对象。类加载(ClassLoader)的过程需要类加载器来完成。 类加载器分类（1）引导类加载器（bootstrap class loader）用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容），这个引导类加载器是用C/C++开发的。（2）扩展类加载器（extensions class loader）加载Java的扩展库（JAVA_HOME/jre/lib/ext/*.jar或java.ext.dirs路径下的内容）。（3）应用程序类加载器（application class loader）根据Java应用的类路径（classpath,java.class.path）的类，通俗的讲就是自定义类型。（4）自定义类加载器例如tomcat就是用自定义类 加载器去加载它需要的class类型，一般来说就是第三方但不是我们实现的类型。 获取类加载器获取某个类型的类加载器对象：Class对象.getClassLoader()；获取系统类的类加载器：ClassLoader.getSystemClassLoader()。 类加载器的代理模式每一种加载器都只负责单一的任务。 类加载器的工作流程：首先系统类加载器（例如：应用程序类加载）接到一个任务（加载类的任务），系统类加载器，把这个任务传给上一级，一直层层往上到达引导类加载器，引导类加载器，先判定这个类型在它的路径下存不存在，如果存在，就加载，如果不存在，把任务往回传，传给了扩展类加载器，扩展类加载器在负责的路径下搜索，如果存在，就加载，如果不存在，把任务往回传，传给了应用程序类加载，应用程序类加载在负责的路径下搜索，如果存在，就加载，如果不存在，如果后面也没有下一级的类加载器了，就报ClassNotFoundException。 应用程序类加载器把扩展类加载器称为上级，作为父加载器parent（不是继承关系）；扩展类加载器把引导类加载器称为上级，作为父加载器parent（不是继承关系）。 Java加载设计成如此是出于安全考虑的，这样你自己写的java.lang.Object类就不会覆盖Java的Object类，你要加载java.lang.Object会一路找到JAVA_HOME/jre/lib/rt.jar里的java.lang.Object。 类加载器加载类路径下的资源文件类加载器的核心作用是加载类，除此之外类加载器还可以加载类路径下的资源文件，配置文件等。 写代码的时候我们可以简单的认为src下的路径就是所谓的类路径，实际上编译后在bin/classes目录下的就是类路径文件。 当配置文件在类路径src目录下时可使用ClassLoader.getSystemResourceAsStream(文件名)加载，此加载为应用程序类加载器。123456//现在info.properties在src下，类路径下Properties pro = new Properties();pro.load(ClassLoader.getSystemResourceAsStream(&quot;info.properties&quot;));String s = pro.getProperty(&quot;info&quot;);System.out.println(s); 当需要使用自定义类加载的时候要使用自定义类加载对象.getResourceAsStream(文件名)。1234567Properties pro = new Properties();ClassLoader c = TestClassLoader2.class.getClassLoader();pro.load(c.getResourceAsStream(&quot;info.properties&quot;));String s = pro.getProperty(&quot;info&quot;);System.out.println(s); 当配置文件在类路径下的目录下时1234567//现在info.properties在src下的包中，在类路径下Properties pro = new Properties();//如果是类，写包名，如果是文件，写路径pro.load(ClassLoader.getSystemResourceAsStream(&quot;com/jeff/classloader/info.properties&quot;));String s = pro.getProperty(&quot;info&quot;);System.out.println(s); 当配置文件在类路径外时12345678//现在type.properties在src外面，在项目的根目录下Properties pro = new Properties();pro.load(new FileInputStream(&quot;info.properties&quot;));// pro.load(new FileInputStream(&quot;resources/info.properties&quot;));String s = pro.getProperty(&quot;info&quot;);System.out.println(s); 当配置文件在src文件夹外类路径内时在src外config文件夹下，config是一个Source Floder，源代码文件夹，最终编译后也在bin/classes目录，所以config中也是类路径。12345Properties pro = new Properties();pro.load(ClassLoader.getSystemResourceAsStream(&quot;config.properties&quot;));String s = pro.getProperty(&quot;config&quot;);System.out.println(s);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflect]]></title>
    <url>%2F2018%2F06%2F10%2FReflect%2F</url>
    <content type="text"><![CDATA[Reflect我们一般自己在编写代码的时侯，使用到某个类都是先声明再使用，即声明类，创建类对象，调用方法，我们知道我们要使用的类的各种细节(自己写的类，心中有数)，这种情况是不太需要使用Reflect的。但是在某些地方，比如通用性强的框架设计的代码里，框架设计者并不需要知道使用框架的人设计类的细节，所以，框架设计者需要为一个未知类创建对象，调用对象方法。即在运行时加载、探知、使用编译期间完全未知的类，这就是反射。反射体现了Java语言的动态性(虽然Java是一门静态语言)。 类加载完成后吗，在堆内存的方法区就成生了一个Class的对象(一个类只有一个Class对象)，这个Class对象包含这个类完整的结构信息，我们通过这个对象看类的结构的过程，我们就叫它反射。 Reflect使用情景 动态的创建任意类型的对象； 获取任意类型的信息； 获取任意对象的属性并设置或获取它的属性值； 获取任意对象的方法并调用它。 Reflect的根源是java.lang.Class，Class类的实例表示正在运行的Java应用程序中的类和接口(他认为枚举是一种类，注解是一种接口)。 注意：除了类(class)以外，每个数组属于被映射为Class对象的一个类，所有具有相同元素类型和维数的数组都共享该Class对象。基本的Java类型（boolean、byte、char、short、int、long、float 和 double）和关键字void也表示为Class对象。Java运行程序时，每一种类型被加载到内存后，都会产生这个类型的唯一的一个Class对象。 获取某个类型的Class对象获取运行时的Class的对象方式有四种： 类型.class，要求是编译期间这个类型是已知的。 对象.getClass()，getClass()在java.lang.Object类声明，获取某个对象的运行时类型。 Class.forName(“类型的全名称”)，在运行期间获取某个类型的Class对象，这个对象编译时可能不存在，但是运行时必须要存在，否则会抛ClassNotFoundException。 ClassLoader对象.loadClass(“类型的全名称”)。类型.class123456789101112131415161718192021222324252627282930313233343536373839404142class TestReflect &#123; public static void main(String[] args) &#123; // 类型.class // 引用数据类型 Class c1 = String.class; System.out.println(c1);// class java.lang.String // 接口 Class c2 = Runnable.class; System.out.println(c2);// interface java.lang.Runnable // 枚举类型 Class c3 = ElementType.class; System.out.println(c3);// class java.lang.annotation.ElementType // 注解 Class c4 = Override.class; System.out.println(c4);// interface java.lang.Override // 基本数据类型 Class c5 = int.class; System.out.println(c5);// int // 数组 Class c6 = int[].class; System.out.println(c6);// class [I // void Class c7 = void.class; System.out.println(c7);// void Class c8 = int.class; System.out.println(c5 == c8);// true Class c10 = int[][].class; System.out.println(c6 == c10);//维度不一样,不是同一个Class类 false Class c11 = double[].class; System.out.println(c6 == c11);//元素的数据类型不同，也不是同一个Class， false &#125;&#125; 特点： 在使用前已经知道确切的类型； 所有的Java在运行时都有确定的Class类型； Java运行程序时，每一种类型被加载到内存后，都会产生这个类型的唯一的一个Class对象，所以两个int.class是同一个Class对象； 关于数组，相同的数组对象必须是类型，维度都一样才是相同的Class对象。对象.getClass()1234567891011121314151617181920212223242526272829303132class TestReflect &#123; public static void main(String[] args) &#123; // 对象.getClass() // 引用数据类型 Class c1 = new String("jefflike").getClass(); System.out.println(c1);// class java.lang.String // 接口 Class c2 = new Runnable()&#123; @Override public void run() &#123; &#125; &#125;.getClass(); System.out.println(c2);// class com.jeff.TestReflect$1 // 基本数据类型// Class c5 = 1.getClass();// System.out.println(c5);// 静态数据类型没有.class // 数组 Class c6 = new int[2].getClass(); System.out.println(c6);// class [I Class c12 = new Student().getClass(); System.out.println(c12); // class com.jeff.Student &#125;&#125;class Student&#123;&#125; 结论： java.lang.Object实现了getClass()，且底层实现是非java实现的，所以基本数据类型是不具有getClass()方法的。 调用getClass()的是运行时的实例对象，所以使用这种方法必须要有一个instance。 Class.forName(“类型的全名称”)12345678910111213public class Main &#123; public static void main(String[] args) throws Exception &#123; Class c = Class.forName("com.jeff.Test"); System.out.println(c);// class com.jeff.Test Class c1 = Class.forName("java.util.Scanner"); System.out.println(c1);// class java.util.Scanner &#125; public class Test &#123; &#125;&#125; 结论： 因为文件可能不存在，所以需要处理ClassNotFoundException异常； 即使类在编译时不存在，在编译过程中也不会报错； 在运行时如果类型还是不存在，那么会抛出异常。ClassLoader对象.loadClass(“类型的全名称”)1234567public class Main &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Class c2 = ClassLoader.getSystemClassLoader().loadClass("com.jeff.Test"); System.out.println(c2);// class com.jeff.Test &#125;&#125; 结论：与使用Class.forName(“类型的全名称”)基本上类似。 反射的作用No.1 在运行期间创建任意类型的对象Object newInstance()1234Class c2 = ClassLoader.getSystemClassLoader().loadClass(&quot;com.jeff.Test&quot;);System.out.println(c2);// class com.jeff.TestObject instance1 = c2.newInstance();System.out.println(instance1);// com.jeff.Test@4554617c 注意：使用此方法的类型必须包含无参构造，而且还不能是私有的无参构造器； 构造器对象.newInstance([形参列表])要点：用Class对象，获取到这个类型的构造器对象，然后在调用构造器对象.newInstance([形参列表])。既可以获取无参构造，也可以获取有参构造，还可以获取私有的构造器，有了构造器，就可以创建它的对象。因为构造器可能被重载，一个类型可能存在多个构造器，需要通过形参列表来确定用哪一个构造器，关注的是构造器的形参的类型以及个数，顺序，对于形参名不关心。1234567891011121314public class Main &#123; public static void main(String[] args) throws Exception &#123; Properties pro = new Properties(); pro.load(new FileInputStream("setting.properties")); // 配置文件在项目内src外 String s = pro.getProperty("key"); Class c3 = ClassLoader.getSystemClassLoader().loadClass(s); System.out.println(c3);//class com.atguigu.Test Constructor cs = c3.getConstructor();//获取无参构造,构造器可以不是public，但是不可以时私有 Object instance2 = cs.newInstance(); System.out.println(instance2);// com.atguigu.Test@74a14482 &#125;&#125; 12345678Properties pro = new Properties();pro.load(new FileInputStream(&quot;setting.properties&quot;)); // 配置文件在项目内src外String s = pro.getProperty(&quot;key&quot;);Class c3 = ClassLoader.getSystemClassLoader().loadClass(s);Constructor cs = c3.getConstructor(String.class, int.class);//获取形参列表是(String, int)的构造器,只返回制定参数类型访问权限是public的构造器Object instance3 = cs.newInstance(&quot;jeff&quot;, 25);System.out.println(instance3);// com.atguigu.Test@4554617c 1234Constructor cs = c3.getDeclaredConstructor(String.class, int.class);//获取形参列表是(String, int)的构造器,只返回制定参数类型访问权限是public的构造器cs.setAccessible(true);Object instance3 = cs.newInstance(&quot;jeff&quot;, 25);System.out.println(instance3);// com.atguigu.Test@4554617c 结论： Class对象获取它的构造器方法是getConstructor()； 获取无参构造器时方法内不需要传参数，但是无参构造器修饰符必须是public； 获取有参构造器时方法内需要传递相应的实参，构造器的修饰符也必须是public； getDeclaredConstructor()可以获取任意修饰符的构造器，要取得构造器使用权限需设置构造器对象.setAccessible(true)； 向构造器提供相应参数即可创建对象。 如此便可在运行过程中创建类的对象。 No.2 动态获取类的各个属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Main &#123; public static void main(String[] args) &#123; //以String类型为例 Class clazz = String.class; //(1)获取类型全名称 System.out.println("类型全名称：" + clazz.getName());// 类型全名称：java.lang.String //(2)获取包名 Package p = clazz.getPackage(); System.out.println("包名：" + p.getName()); //(3)获取类型的修饰符 int mod = clazz.getModifiers(); System.out.println("修饰符：" + mod);//修饰符：17 //修饰符类型Modifier System.out.println("修饰符：" + Modifier.toString(mod)); //(4)获取直接父类 Class c = clazz.getSuperclass(); System.out.println("父类：" + c.getName()); //(5)获取父接口们 System.out.println("父接口们："); Class[] interfaces = clazz.getInterfaces(); for (Class class1 : interfaces) &#123; System.out.println(class1); &#125; System.out.println("属性们："); //(6)获取属性们// clazz.getField(name)//获取具体的一个属性，而且是公共的// clazz.getDeclaredField(name)//获取具体的一个属性，只有是它声明的// clazz.getFields()//获取多个，都是公共的 Field[] fields = clazz.getDeclaredFields();//获取所有，只有是它声明的 //为什么要把属性抽象为Field类型，因为所有的属性都有修饰符，数据类型，属性名，都有set,get的行为 for (Field field : fields) &#123; System.out.println(field); &#125; //(7)获取构造器们 System.out.println("构造器们："); Constructor[] constructors = clazz.getDeclaredConstructors(); //构造器的共同特征：（1）修饰符（2）构造器名（3）形参列表（4）行为：创建对象newInstance() for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; //(8)获取方法们 System.out.println("方法们："); Method[] methods = clazz.getDeclaredMethods(); //方法的共同特征：（1）修饰符（2）返回值类型（3）方法名（4）形参列表（5）抛出的异常列表（6）行为：被调用 invoke for (Method method : methods) &#123; System.out.println(method); &#125; &#125;&#125; 结论： Java面向对象的应用非常广泛； 类中的所有成员都可以被抽象出来，成为一类； 当一个类可以有多个XX时，返回的往往是一个数组；No.3 动态获取，设置对象属性与属性值1234567891011121314151617181920212223242526272829303132public class Main &#123; public static void main(String[] args) &#123; //1、获取类型的Class对象 Class clazz = Class.forName("com.jeff.bean.Teacher"); //2、先创建或获取Teacher的对象 Object tea1 = clazz.newInstance(); Object tea2 = clazz.newInstance(); //3、设置tea1对象的id属性值 //(1)先获取id属性对象 Field idField = clazz.getDeclaredField("id"); //(2)因为id属性是私有的，那么需要设置它可访问的权限 idField.setAccessible(true); //(3)设置tea1对象的id属性的值 //参数一：哪个对象的id属性,这里tea1 //参数二：设置为xx值 idField.set(tea1, 1); //4、获取tea的id属性值 Object value1 = idField.get(tea1);//参数：获取哪个对象的id属性 System.out.println(value1); //5、可以设置tea2对象的id属性值和获取id属性值 idField.set(tea2, 2); Object value2 = idField.get(tea2);//参数：获取哪个对象的id属性 System.out.println(value2); &#125;&#125; 动态获取对象的属性123456Properties pro = new Properties();pro.load(new FileInputStream(&quot;setting.properties&quot;)); // 配置文件在项目内src外String s = pro.getProperty(&quot;key&quot;);Class c3 = ClassLoader.getSystemClassLoader().loadClass(s);Field f = c3.getDeclaredField(&quot;id&quot;);System.out.println(f);// private int com.jeff.Test.id 获取运行Class对象，并获取属性。 动态设置对象的属性123456Constructor cc = c3.getConstructor();//获取无参构造Object instance2 = cc.newInstance();Field f = c3.getDeclaredField(&quot;id&quot;);System.out.println(f);// private int com.jeff.Test.idf.setAccessible(true);f.set(instance2, 25); id属性是私有的，需要设置它可访问的权限,set设置此对象的值。 动态获取对象的属性值1234567891011121314Properties pro = new Properties();pro.load(new FileInputStream(&quot;setting.properties&quot;)); // 配置文件在项目内src外String s = pro.getProperty(&quot;key&quot;);Class c3 = ClassLoader.getSystemClassLoader().loadClass(s);Constructor cc = c3.getConstructor();//获取无参构造Object instance2 = cc.newInstance();Field f = c3.getDeclaredField(&quot;id&quot;);System.out.println(f);// private int com.jeff.Test.idf.setAccessible(true);f.set(instance2, 25);Object a = f.get(instance2);System.out.println(a);// 25System.out.println(a instanceof Integer);// true 总结： 先得到运行的Class对象； 获得此对象的实例对象newInstance()； 获得属性对象Field； 操作属性对象set，get； 属性若是私有，需Class对象.getDeclaredField(属性名)获取属性对象； 操作它（set，get）需要设置它可访问的权限：属性对象.setAccessible(true)。No.4 动态调用对象的方法1234567891011121314151617181920class Test &#123; private int id; public Test()&#123;&#125; public Test(String a, int b)&#123; System.out.println(a + b); &#125; public void test(int id)&#123; this.id = id; System.out.println(this.id); &#125;&#125; Properties pro = new Properties(); pro.load(new FileInputStream(&quot;setting.properties&quot;)); // 配置文件在项目内src外 String s = pro.getProperty(&quot;key&quot;); Class c4 = ClassLoader.getSystemClassLoader().loadClass(s); Object obj = c4.newInstance(); Method m = c4.getDeclaredMethod(&quot;test&quot;, int.class); m.invoke(obj, 25); No.5 动态读取类与方法上的注解信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Main &#123; public static void main(String[] args) throws Exception&#123; // 动态读取自定义注解 //(1)获取类型的Class对象 Class clazz = MyClass.class; //(2)获取类上面的注解 //获取指定的注解类型对象，返回的对象是Annotation对象 Annotation a = clazz.getDeclaredAnnotation(MyAnnotation.class); //(3)获取注解的配置参数值 MyAnnotation m = (MyAnnotation) a; String value = m.value(); System.out.println(value);// jeff //(4)获取方法对象 Method m1 = clazz.getDeclaredMethod("test"); //(5)获取方法上的注解 Annotation a1 = m1.getDeclaredAnnotation(MyAnnotation.class); //(6)获取注解的配置参数值 MyAnnotation m2 = (MyAnnotation) a1; String value2 = m2.value(); System.out.println(value2);// jefflike &#125;&#125;// 使用自定义注解@MyAnnotation("jeff")class MyClass&#123; @MyAnnotation public void test()&#123;&#125;&#125;// 自定义注解//@Target指明这个注解只能用在类上和方法上//@Retention指明注解的生命周期，RUNTIME才能被反射读取到@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation&#123; String value() default "jefflike";&#125; 总结： 要能读取到注解信息，注解生命周期一定是RUNTIME。 getDeclaredAnnotation()方法得到的是Annotation类型，读取value值需要转化为MyAnnotation类型，Annotation没有value()。 自定义注解的value是一个方法，而不是属性。No.6 动态获取泛型父类的泛型实参123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TestGenericType &#123; public static void main(String[] args) &#123; Son s = new Son(); &#125;&#125;//1、声明泛型类,T是泛型形参//这个T什么时候指定（1）创建它的对象（2）继承时abstract class Father&lt;T,U&gt;&#123; private Class type;//希望存储的是T的泛型的实参的类型 //父类的构造器，无参构造 //子类继承时一定会调用父类的无参构造 Father()&#123; //因为Father是抽象类，不能直接创建对象，当子类创建对象时，会调用父类的无参构造， //那么这个this代表的是正在创建的子类的对象 //this.getClass()获取的是运行时的子类的类型 //(1)获取子类的类型 Class ziType = this.getClass(); System.out.println(ziType); //(2)获取子类的泛型父类的类型// Class fuType = ziType.getSuperclass();//这个方法可以获取父类的类型，但是不能包括泛型实参// System.out.println(fuType); //返回值类型是Type，而不是Class，因为我们的泛型的父类的&lt;&gt;中可能还是T等各种情况，不是百分百是具体的类型 Type type = ziType.getGenericSuperclass(); //因为这里的子类是Father&lt;String&gt;，那么它是属于ParameterizedType //(3)把泛型父类强制成ParameterizedType ParameterizedType p = (ParameterizedType) type; //(4)获取泛型父类的泛型实参的类型 Type[] arr = p.getActualTypeArguments(); type = arr[0]; System.out.println("T的泛型实参的类型是：" + type); &#125; public void test()&#123; //例如：在这里我想要获取T的泛型实参的类型 //转换为获取T的泛型实参的Class对象// System.out.println("泛型实参的类型是：" + T.class);//错误的 System.out.println("泛型实参的类型是：" + type); &#125;&#125;//2、声明子类，继承泛型父类，String是泛型实参class Son extends Father&lt;String,Integer&gt;&#123; &#125; 总结： 泛型形参直接.class是不能获取当前泛型实参类型的； 获取当前对象泛型实参的方式是创建子类对象时会调用父类的无参构造，父类无参构造的this就是子类的对象； Class包含了常用的所有的类型的class，但是不能包含T，E等泛型的类型，所以我们要使用Type（它是Class的父接口）； Type的五种类型：（1）传统的类型Class; （2）GenericArrayType：泛型的数组类型 （3）ParameterizedType：参数类型 ArrayList&lt;String&gt; Father&lt;String&gt;使用 （4）TypeVariable：类型变量 &lt;T&gt; 使用 （5）WildcarType：带通配符的泛型 &lt;?&gt;使用]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的设计模式]]></title>
    <url>%2F2018%2F06%2F06%2F%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[首先设计模式并不是那一种编程语言所特有的。设计模式是所有编程语言的从业人员，在实际的编写代码过程中，对于解决某种，某些特定问题比较优质的解决方案，设计模式代表的是一种种的思想，值得我们去学习和了解他。 本篇博客简单介绍一些简单的设计模式的思想及代码的简单实现。 模板设计模式说明这里的模板指的不是那种一成不变的模板，而是主体部分和格式是确定的（整体流程固定不变），少量的变化的部分由使用者修改（具体细节实现暂不确定），不同的人实现的不尽相同。类似于请假条模板，整个模板的功能就是书面表达请假信息，格式固定，一般公司的请假条模板，会空出姓名和时间由具体使用请假条对象的员工来填写。即当某个功能它的实现的算法结构（解题的思路，步骤）是固定的，但是其中某一小步，或几步的具体实现代码是不确定的，是变化的，应该有使用者来决定。 实现思路在父类中编写这个功能，把能确定的部分先实现，把不能确定的部分，通过抽象方法暴露出来，给子类（使用者）来实现它。 代码实现请假条模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 请假条的父模板abstract public class Tips &#123; // 所有人的请假条都是这个格式的 public String write()&#123; return "姓名：" + getName() + ",请假时间：" + getTime(); &#125; abstract String getName(); abstract void settName(String n); abstract String getTime(); abstract void setTime(String t);&#125;// 子类实现请假条提供方法public class MyTips extends Tips &#123; private String name; private String time; @Override void settName(String n) &#123; name = n; &#125; @Override String getName() &#123; return name; &#125; @Override void setTime(String t) &#123; time = t; &#125; @Override String getTime() &#123; return time; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Tips m = new MyTips(); m.settName("jefflike"); m.setTime("7:00-9:00"); System.out.println(m.write()); &#125;&#125; 请假条格式固定，将填写姓名和时间的方法抽象给子类（也就是填写请假条的人）来实现。这样每个人拿到这个请假条模板直接就可以修改自己的信息直接使用，就十分的方便。 实现程序运行时间模板123456789101112131415161718192021222324252627282930313233abstract class RunTime &#123; public final long getTime()&#123; long startTime = System.currentTimeMillis(); // 我们不知道运行那段代码 RunCoding(); long stopTime = System.currentTimeMillis(); return stopTime - startTime; &#125; protected abstract void RunCoding();&#125;public class SubRunTime extends RunTime &#123; public void RunCoding()&#123; long sum = 0; for(int i =0; i&lt;100000000; i++)&#123; sum += i; &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; SubRunTime s = new SubRunTime(); System.out.println(s.getTime()); &#125;&#125; 我们不需要知道子类到底进行测试时间的代码块是什么，我们将代码实现的整个过程固定下来，子类实现的代码块抽象成方法，让子类自行决定，这样我们的功能固定，就是一个测试时间的功能，但是不论子类实现什么样的代码，只要想看运行时间，都可以继承我这个模板。这与python的闭包装饰器的实现很相似，这就是模板设计模式。 简单工厂模式说明我们一般会在使用一个对象的时候new一个对象，工厂模式的目的是将创建对象与使用对象的操作分离开。 代码实现一个简单的汽车工厂123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TestSimpleFactory &#123; public static void main(String[] args) &#123; //(1)无工厂 BMW b = new BMW(); b.run(); //(2)通过工厂 //与BMW被使用者解耦合 Car car = SimpleFactory.getCar(1); car.run(); &#125;&#125;class SimpleFactory&#123; public static final int BMW = 1; public static final int AUDI = 2; public static Car getCar(int type)&#123; switch(type)&#123; case BMW: return new BMW(); case AUDI: return new Audi(); default: return null; &#125; &#125;&#125;interface Car&#123; void run();&#125;class BMW implements Car&#123; @Override public void run() &#123; System.out.println("宝马跑。。。。"); &#125;&#125;class Audi implements Car&#123; @Override public void run() &#123; System.out.println("奥迪跑..."); &#125;&#125; 使用工厂造车，我们除了解耦了使用与生产的过程，同时我们隐藏了造车的具体细节，我们只需要知道自己想要一个什么车，我们就能得到一个这个车的实例对象，而使用者并不需要知道怎么去造车。 一般工厂模式说明在简单工厂模式中，只存在一个工厂类，即汽车工厂。这算是简单工厂模式的一个弊端，他的工厂功能单一，难以扩展。即现在我的工厂只能生成奥迪或者宝马，我想再增加新的产品就必须修改我们的工厂类，这违背了面向对象设计模式的原则：对修改关闭，对扩展开放。所以简单工厂的扩展性限制了他的使用范围。而一般工厂模式可以做到当增加一个新产品，不会涉及到修改原来的代码，只要扩展新的产品类和对应工厂类即可。 实现思路建立多个工厂类，每个工厂只生产自己的单个商品，增加新商品就增加新的工厂类，而不需要修改原来的工厂代码。 代码实现新工厂1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class TestFactoryMethod &#123; public static void main(String[] args) &#123; Factory f = new BMWFactory(); Car car = f.getCar(); car.run(); &#125;&#125;//(1)接口：产品的的标准interface Car&#123; void run();&#125;//(2)接口的实现类们：产品class BMW implements Car&#123; public void run()&#123; System.out.println("宝马"); &#125;&#125;class Audi implements Car&#123; public void run()&#123; System.out.println("奥迪"); &#125;&#125;class QQ implements Car&#123; public void run()&#123; System.out.println("qq"); &#125;&#125;//（3）多个工厂：每一个工厂只生产一种产品interface Factory&#123; Car getCar();&#125;class BMWFactory implements Factory&#123; public BMW getCar()&#123; return new BMW(); &#125;&#125;class AudiFactory implements Factory&#123; public Audi getCar()&#123; return new Audi(); &#125;&#125;class QQFactory implements Factory&#123; public QQ getCar()&#123; return new QQ(); &#125;&#125; 一般工厂模式创建太多的代码，但是更符合面向对象的设计原则。 代理者模式说明代理者在我们生活中也有很多实例，比如中介就是代理的一员，我们的业务类只关注核心的，不易变的业务逻辑，而把一些复杂，多变的辅助功能交给代理完成。我们买房子关注的就是交钱和入住的环节，剩下由中介完成即可，所以这就是代理。 实现思路将被代理者作为实参传入代理者的代理方法中。 代码实现中介1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class TestProxy &#123; public static void main(String[] args) &#123; Buy b = new Proxy(new Customer()); b.buy(); &#125;&#125;//主题：联系代理者和被代理者的主题interface Buy&#123; void buy();&#125;//被代理者class Customer implements Buy&#123; @Override public void buy() &#123; System.out.println("付钱，拿钥匙入住，拿房本..."); &#125; &#125;//代理者class Proxy implements Buy&#123; private Buy target;//被代理者的目标 public Proxy(Buy target) &#123; super(); this.target = target; &#125; @Override public void buy() &#123; doBefore(); //核心业务功能，由被代理者自己完成 target.buy(); doAfter(); &#125; public void doBefore()&#123; System.out.println("寻找房源，甄别房源的真实性，是否是有抵押，是否是凶宅..."); &#125; public void doAfter()&#123; System.out.println("尾款的交付，物业的交割..."); &#125; &#125; 单例模式说明单例模式就是某个类型在整个系统运行期间，有且只有唯一的一个对象。单例模式在代码中使用的还是非常广泛的。比如再flask框架中，request对象时多个，并且每个用户的request对象都不一样，但是核心app对象（处理request等）就只有一个，处理不同request对象的都是唯一一个app核心对象。 实现思路单例的实现就是不想让使用者自己随意的创造实例对象，而是调用类已经创建好的对象。所以，我们需要暴露得到对象的方法，但是又隐藏构造器（没法直接new新的对象）。 coding实现单例模式最简洁的单例模式（饿汉式）：123enum Singleton&#123; INSTANCE&#125; enum的枚举对象就是隐藏了私有的构造器，当我们只有一个枚举对象的时候，就实现了单例模式。 饿汉式之二12345class Hungry&#123; public static final Hungry INSTANCE = new Hungry(); private Hungry()&#123; &#125;&#125; JDK1.5之前枚举类型的实现，这也是单例模式。 饿汉式之三12345678910class E&#123; private static final E INSTANCE = new E(); private E()&#123; &#125; public static E getInstance()&#123; return INSTANCE; &#125;&#125; 直接将获取实例的操作也私有化。 饿汉式的单例模式的问题是在创建类的时候就已经创建对象了，与之不同的是懒汉式，懒汉的特点就是用的时候在创建，未调用时实例并未创建。12345678910111213class Lazy&#123; private static Lazy instance; private Lazy()&#123; &#125; //当用户调用这个方法时，说明需要这个对象 public static Lazy getInstance()&#123; if(instance == null)&#123; instance = new Lazy(); &#125; return instance; &#125;&#125; 这样的懒汉式单例模式存在问题，在并发的调用时会存在多个线程同时抢夺到公共资源instance，此时instance的值为null那么这些线程每个人都有一个Lazy的对象，这就不是一个单例模式了。 所以改良一下这个单例模式。123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args) &#123; SingleTon s = SingleTon.getInstance(); SingleTon s1 = SingleTon.getInstance(); SingleTon s2 = SingleTon.getInstance(); System.out.println(s == s1); System.out.println(s2 == s1); &#125;&#125;class SingleTon extends Thread&#123; private static SingleTon instance; private SingleTon()&#123;&#125; public static SingleTon getInstance() &#123; if (instance == null) &#123; synchronized (SingleTon.class) &#123; if (instance == null) &#123; instance = new SingleTon(); &#125; &#125; &#125; return instance; &#125;&#125; 生产者消费者模型说明两个（多个）共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。要解决该问题，就必须让生产者在缓冲区满时等待(wait)，等到下次消费者消耗了缓冲区中的数据的时候，生产者才能被唤醒(notify)，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入等待(wait)，等到生产者往缓冲区添加数据之后，再唤醒消费者(notify)。通常采用线程间通信的方法解决该问题。依据线程间的通信方式解决这类的生产者和消费者的问题的模式，叫做生产者与消费者设计模式 实现思路生产者和消费者都可以是一个或者多个，生产者有一个生产商品的方法，消费者则是消耗一个商品的方法。为保证商品的数量不超过上限所以需要一个数组存放商品，存放和消耗时都要进行数量的判断，因为这块共享空间信息会被两者修改，所以我们需要对它加同步锁。当存放达到上限时，需要将生产者wait住，等待消耗到了产品再将生产者激活。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class Main &#123; public static void main(String[] args) &#123; // 多个生产者与消费者时，notify应该改为notifyAll Worker w1 = new Worker(); Worker w2 = new Worker(); Saler s1 = new Saler(); Saler s2 = new Saler(); w1.start(); w2.start(); s1.start(); s2.start(); &#125;&#125;class Repo&#123; public static Object[] products = new Object[10];// 简化问题就不进行扩容了，默认上限10个产品 public static int count=0;// 默认初始没有产品 synchronized public static void add(Object obj) &#123; if(count &gt;= products.length)&#123; try &#123; //当前线程wait() //锁对象.wait() Repo.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; products[count]=obj; count++; System.out.println("生产者生产了一台产品，库存量是：" + count); Repo.class.notifyAll();// 只有一个消费者所以使用notify即可 &#125; synchronized public static void take()&#123; if(count &lt;= 0)&#123; try &#123; //当前线程wait() //锁对象.wait() Repo.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.arraycopy(products, 1, products, 0, count-1); products[count-1]=null; count--; System.out.println("库存量是：" + count); Repo.class.notifyAll(); &#125;&#125;class Product&#123; private String name; public Product(String name) &#123; super(); this.name = name; &#125; @Override public String toString() &#123; return "Product [name=" + name + "]"; &#125;&#125;class Worker extends Thread&#123; private int i = 1; public void run()&#123; while(true)&#123; Repo.add(new Product("产品" + i++)); &#125; &#125;&#125;class Saler extends Thread&#123; public void run()&#123; while(true)&#123; Repo.take(); &#125; &#125;&#125; 注意： 操作共享仓库的操作需要加同步锁； 多个线程操作的时候，motify唤醒对方时需要唤醒所有，即notifyAll；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-String类型(三)]]></title>
    <url>%2F2018%2F06%2F05%2FJava-String%E7%B1%BB%E5%9E%8B-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[继续接着上一篇博客内容继续讲，看到源码的1925行，里面很多一部分都是注释，大部分的方法介绍的都很全面，基本上读完注释，使用起来没什么难度。这说明了，写代码多写注释确实是一个很好的习惯。 substring12345678910public String substring(int beginIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; int subLen = value.length - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);&#125; 只传一个数值参数，如果是0则返回整个string对象，否则要创建新的字符串，从beginIndex一直复制到末尾的位置。1234567891011121314public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; int subLen = endIndex - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen);&#125; 这个是重载的加强版，new String(value, beginIndex, subLen)，创建一个从index到end的新字符串。 subSequence123public CharSequence subSequence(int beginIndex, int endIndex) &#123; return this.substring(beginIndex, endIndex);// 底层的实现是substring方法&#125; 12345678910public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123;// 如果拼接的是空串 return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len);// 就是这个地方实现的拼接，这个方法用于拼接 return new String(buf, true);&#125; concat虽然实现了+=一样的效果，但是底层并不是用+=实现的。使用了str.getChars(buf, len)。 replace1234567891011121314151617181920212223242526public String replace(char oldChar, char newChar) &#123; if (oldChar != newChar) &#123; int len = value.length; int i = -1; char[] val = value; /* avoid getfield opcode */ while (++i &lt; len) &#123; if (val[i] == oldChar) &#123;//遍历找到i break; &#125; &#125; if (i &lt; len) &#123; char buf[] = new char[len]; for (int j = 0; j &lt; i; j++) &#123; buf[j] = val[j];// 新的字符数组 &#125; while (i &lt; len) &#123; char c = val[i];//并换掉之前的字符 buf[i] = (c == oldChar) ? newChar : c; i++; &#125; return new String(buf, true);// 同理返回的是一个新的字符串 &#125; &#125; return this;&#125; matches123public boolean matches(String regex) &#123; return Pattern.matches(regex, this);//与正则是否匹配&#125; contains123public boolean contains(CharSequence s) &#123; return indexOf(s.toString()) &gt; -1;&#125; contains的实现就是查看这个序列的字符串能不能索引的到，能索引的到肯定是有这个子串的。 replaceFirst1234// 正则匹配到的第一个，将其替换 public String replaceFirst(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceFirst(replacement); &#125; replaceAll1234// 先是匹配到所有的正则的字符串，然后都替换成新的str public String replaceAll(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceAll(replacement); &#125; replace1234public String replace(CharSequence target, CharSequence replacement) &#123; return Pattern.compile(target.toString(), Pattern.LITERAL).matcher( this).replaceAll(Matcher.quoteReplacement(replacement.toString()));&#125; replace也是全部替换，但是他不可以使用正则匹配，虽然他的底层使用了正则。 split12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public String[] split(String regex, int limit) &#123; /* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx&apos;s meta characters &quot;.$|()[&#123;^?*+\\&quot;, or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */ char ch = 0; // 验证正则 if (((regex.value.length == 1 &amp;&amp; &quot;.$|()[&#123;^?*+\\&quot;.indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == &apos;\\&apos; &amp;&amp; (((ch = regex.charAt(1))-&apos;0&apos;)|(&apos;9&apos;-ch)) &lt; 0 &amp;&amp; ((ch-&apos;a&apos;)|(&apos;z&apos;-ch)) &lt; 0 &amp;&amp; ((ch-&apos;A&apos;)|(&apos;Z&apos;-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) &#123; int off = 0; int next = 0; boolean limited = limit &gt; 0; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); while ((next = indexOf(ch, off)) != -1) &#123; if (!limited || list.size() &lt; limit - 1) &#123; list.add(substring(off, next)); off = next + 1; &#125; else &#123; // last one //assert (list.size() == limit - 1); list.add(substring(off, value.length)); off = value.length; break; &#125; &#125; // If no match was found, return this if (off == 0) return new String[]&#123;this&#125;; // Add remaining segment if (!limited || list.size() &lt; limit) list.add(substring(off, value.length)); // Construct result int resultSize = list.size(); if (limit == 0) &#123; while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) &#123; resultSize--; &#125; &#125; String[] result = new String[resultSize]; return list.subList(0, resultSize).toArray(result); &#125; return Pattern.compile(regex).split(this, limit);&#125;public String[] split(String regex) &#123; return split(regex, 0);&#125; 也是可以根据正则切割。 join123456789101112131415161718192021222324252627282930313233343536373839public static String join(CharSequence delimiter, CharSequence... elements) &#123; Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); // Number of elements not likely worth Arrays.stream overhead. StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) &#123; joiner.add(cs); &#125; return joiner.toString();&#125;public StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix) &#123; Objects.requireNonNull(prefix, &quot;The prefix must not be null&quot;); Objects.requireNonNull(delimiter, &quot;The delimiter must not be null&quot;); Objects.requireNonNull(suffix, &quot;The suffix must not be null&quot;); // make defensive copies of arguments this.prefix = prefix.toString(); this.delimiter = delimiter.toString(); this.suffix = suffix.toString(); this.emptyValue = this.prefix + this.suffix;&#125;public StringJoiner add(CharSequence newElement) &#123; prepareBuilder().append(newElement); return this;&#125;public static String join(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements) &#123; Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) &#123; joiner.add(cs); &#125; return joiner.toString();&#125; @since 1.8才有的这个方法。123456789class jie&#123;public static void main(String[] args)&#123; String c = "丁"; String d = "杰"; System.out.println(String.join(",", c, d, "是大帅哥"));// 丁,杰,是大帅哥 System.out.println("dingjie@123.com".replaceFirst("\\w+", "jefflike"));//jefflike@123.com&#125; &#125; 这个join是一个静态的方法，实现的功能类似于python的join效果。将字符串Sequence放到StringJoiner中，StringJoiner实现这个效果。 toLowerCase与toUpperCaseJava在实现这两个方法的过程上花了很大的篇幅，主要是考虑到实现的过程中保证线程安全。 trim123456789101112131415161718public String trim() &#123; int len = value.length; int st = 0; char[] val = value; /* avoid getfield opcode */ while ((st &lt; len) &amp;&amp; (val[st] &lt;= &apos; &apos;)) &#123; //找出前面空串的长度 &#125; st++; &#125; while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= &apos; &apos;)) &#123; //找出后面空串的长度 &#125; len--; &#125; // 通过字串截除有效的长度 return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;&#125; toCharArray123456public char[] toCharArray() &#123; // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result;&#125; 因为底层就是String的字符数组，所以直接copy过来返回就可以了。 format1234567public static String format(String format, Object... args) &#123; return new Formatter().format(format, args).toString();&#125;public static String format(Locale l, String format, Object... args) &#123; return new Formatter(l).format(format, args).toString();&#125; 静态的format方法1.5以后有的，调用Formatter实例对象实现。 valueOf12345678910111213141516public static String valueOf(Object obj) &#123; return (obj == null) ? &quot;null&quot; : obj.toString();&#125;public static String valueOf(char data[]) &#123; return new String(data);&#125;public static String valueOf(char data[], int offset, int count) &#123; return new String(data, offset, count);&#125;//可以看bollean的valueOfpublic static String valueOf(boolean b) &#123; return b ? &quot;true&quot; : &quot;false&quot;;&#125; 对于传入一个非null的对象，结果就是此对象的toString()方法。 copyValueOf12345678910111213public static String copyValueOf(char data[], int offset, int count) &#123; return new String(data, offset, count);&#125;public static String copyValueOf(char data[]) &#123; return new String(data);&#125;// 各种基本数据类型都可以作为此方法的参数public static String valueOf(char c) &#123; char data[] = &#123;c&#125;; return new String(data, true);&#125; 与上面的方法基本一致，只是返回的是一个新的字符串对象。 intern1public native String intern(); 这个方法的功能是将堆中的字符串数据作为常量存放到方法区的常量区，底层的代码实现不是用Java实现的，所以修饰符是native。 以上就是String的所有方法了，在实现String的代码过程中： String的底层都是使用字符数组完成各项操作； 大量使用注释，方便学习阅读各个方法的使用细节； 面向对象编程，大量使用重载和封装，减少代码冗余； 大量封装代码，减少代码复用； 在代码实现的细节上，首先会进行特殊值判断，null，length的特殊值，临界值等； 字符串常量存储在字符串常量池，目的是为了共享，字符串非常量对象存储在堆中。 关于常量所在区域：常量与常量的拼接结果在常量池，只要其中有一个是变量，结果就在堆中，如果拼接的结果调用intern()方法，就在常量池中。12str = &quot;123&quot;;// 字符串常量str1 = new String(&quot;123&quot;); // 非字符串常量，存储在堆中 非常浅显的整理了一下String的源码，有些代码写得很精妙，但是还无法彻底领会，随着后面深入理解Java还会再次修改这里面的一些内容。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类型源码解析(二)]]></title>
    <url>%2F2018%2F06%2F04%2FJava-String%E7%B1%BB%E5%9E%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[本篇继续介绍String类的源码，从常用的类方法开始介绍。 String的长度123public int length() &#123; return value.length;&#125; 因为字符串的底层是由字符数组存放的就是char[] value，所以这个字符数组的长度就是有效的String对象的长度。 String是否为空123public boolean isEmpty() &#123; return value.length == 0;&#125; 同理，判断字符串对象是否为空就是判断底层字符数组是否长度为0. charAt()取出字符串中索引为index的字符。123456public char charAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125;// 不在合理返回会抛出异常 return value[index];&#125; 同理，返回的就是字符数组的相应索引的值。 codePointAt()123456public int codePointAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointAtImpl(value, index, value.length);&#125; 12345System.out.println(new String(new char[]&#123;&apos;\u1234&apos;,&apos;\u4e01&apos;, &apos;\u6607&apos;&#125;, 0, 1).codePointAt(0));//4660System.out.println(new String(new char[]&#123;&apos;\u4e01&apos;, &apos;\u6607&apos;&#125;, 0, 1).codePointAt(0));//19969 System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;, 4, 4).codePointAt(1));//105 System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;, 4, 4).codePointAt(2));//107 System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;, 4, 4).codePointAt(3));//102 index索引的char转化为十进制的值（其实就是Unicode编码值，体现为十进制数字），底层是字符的codePointAtImpl方法实现的。 codePointBefore1234567public int codePointBefore(int index) &#123; int i = index - 1; if ((i &lt; 0) || (i &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointBeforeImpl(value, index, 0);&#125; 123System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;, 4, 4).codePointBefore(1));//108System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;, 4, 4).codePointBefore(2));//105System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;, 4, 4).codePointBefore(3));//107 作用是：index索引前一个字符转化为十进制的值。实现方式与上面完全一致。完全可以调用上面的方法，传入index-1实现。 codePointCount()123456public int codePointCount(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0 || endIndex &gt; value.length || beginIndex &gt; endIndex) &#123; throw new IndexOutOfBoundsException(); &#125; return Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex);&#125; 1System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;).codePointCount(1,7));//6 统计区间中的字符数，半闭半开区间。 offsetByCodePoints1234567public int offsetByCodePoints(int index, int codePointOffset) &#123; if (index &lt; 0 || index &gt; value.length) &#123; throw new IndexOutOfBoundsException(); &#125; return Character.offsetByCodePointsImpl(value, 0, value.length, index, codePointOffset);&#125; 个人觉得这个方法貌似没什么用，value从index到codePointOffset的长度。12System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;).offsetByCodePoints(1,7));//8System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;).offsetByCodePoints(1,1));//2 getChars12345678910111213141516void getChars(char dst[], int dstBegin) &#123; System.arraycopy(value, 0, dst, dstBegin, value.length);&#125;public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123; if (srcBegin &lt; 0) &#123; throw new StringIndexOutOfBoundsException(srcBegin); &#125; if (srcEnd &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(srcEnd); &#125; if (srcBegin &gt; srcEnd) &#123; throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); &#125; System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);&#125; 暂时不知道会用在哪里，没有返回值，但是会从原字符串切一段。 getBytes()12345678910111213141516171819202122@Deprecatedpublic void getBytes(int srcBegin, int srcEnd, byte dst[], int dstBegin) &#123; if (srcBegin &lt; 0) &#123; throw new StringIndexOutOfBoundsException(srcBegin); &#125; if (srcEnd &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(srcEnd); &#125; if (srcBegin &gt; srcEnd) &#123; throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); &#125; Objects.requireNonNull(dst); int j = dstBegin; int n = srcEnd; int i = srcBegin; char[] val = value; /* avoid getfield opcode */ while (i &lt; n) &#123; dst[j++] = (byte)val[i++]; &#125;&#125; 上面的无返回值的getBytes()已经不使用的12345public byte[] getBytes(String charsetName) throws UnsupportedEncodingException &#123; if (charsetName == null) throw new NullPointerException(); return StringCoding.encode(charsetName, value, 0, value.length);&#125; 将整段字符串的每个字节按照相应的编码转换成二进制存放到byte[]。123456789101112131415161718import java.io.UnsupportedEncodingException;class Test&#123; public static void main(String[] args)&#123; try&#123; byte[] str = "丁杰".getBytes("utf-8");//utf8每个汉字是三个字节， System.out.println(str[0]);//-28 System.out.println(str[1]);//-72 System.out.println(str[2]);//-127 System.out.println(str[3]);//-26 System.out.println(str[4]);//-99 System.out.println(str[5]);//-80 System.out.println(str[6]);//异常 &#125;catch(UnsupportedEncodingException e)&#123; System.out.println(e); &#125; &#125;&#125; equals123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123;// 首先，比较的两者都是同一个对象，那么返回ture return true; &#125; if (anObject instanceof String) &#123;// 如果传进来进行比较的也是String类型的对象 String anotherString = (String)anObject;//强制类型转换 int n = value.length; if (n == anotherString.value.length) &#123;//首先两者的字符的长度一定是相等的 char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123;//长度等于零的时候停止循环，整个遍历的过程只要出现两者的字符不相等情况就返回false停止循环 if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; String继承了超级父类Object，所以他也有equals方法，并且String重写了父类的equals方法。先进行了一系列的操作，然后遍历底层的两个字符数组，判断两者的字符是否完全一致，只有两者完全一致的情况下才会返回true。 contentEquals1234567891011121314151617181920212223242526272829303132public boolean contentEquals(StringBuffer sb) &#123; return contentEquals((CharSequence)sb); &#125; public boolean contentEquals(CharSequence cs) &#123; // Argument is a StringBuffer, StringBuilder if (cs instanceof AbstractStringBuilder) &#123; if (cs instanceof StringBuffer) &#123; synchronized(cs) &#123; return nonSyncContentEquals((AbstractStringBuilder)cs); &#125; &#125; else &#123; return nonSyncContentEquals((AbstractStringBuilder)cs); &#125; &#125; // Argument is a String if (cs instanceof String) &#123; return equals(cs); &#125; // Argument is a generic CharSequence char v1[] = value; int n = v1.length; if (n != cs.length()) &#123; return false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (v1[i] != cs.charAt(i)) &#123; return false; &#125; &#125; return true;&#125; 配合下面的方法，判断出String与StringBuffer对象内容完全相等。 nonSyncContentEquals1234567891011121314private boolean nonSyncContentEquals(AbstractStringBuilder sb) &#123; char v1[] = value; char v2[] = sb.getValue(); int n = v1.length; if (n != sb.length()) &#123; return false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (v1[i] != v2[i]) &#123; return false; &#125; &#125; return true;&#125; 判断字符串与AbstractStringBuilder对象的值（内容也是字符串类似的）是否完全相等。也是遍历比较的方式。 equalsIgnoreCase1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public boolean equalsIgnoreCase(String anotherString) &#123; return (this == anotherString) ? true : (anotherString != null) &amp;&amp; (anotherString.value.length == value.length) &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length);&#125;public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) &#123; char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1. if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) &#123; return false; &#125; while (len-- &gt; 0) &#123; char c1 = ta[to++]; char c2 = pa[po++]; if (c1 == c2) &#123;//两个都一样继续 continue; &#125; if (ignoreCase) &#123; // If characters don&apos;t match but case may be ignored, // try converting both characters to uppercase. // If the results match, then the comparison scan should // continue. char u1 = Character.toUpperCase(c1);// 开启了大小写忽略，两个字符不一样会进行比较 char u2 = Character.toUpperCase(c2); if (u1 == u2) &#123; continue; &#125; // Unfortunately, conversion to uppercase does not work properly // for the Georgian alphabet, which has strange rules about case // conversion. So we need to make one last check before // exiting. if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123; continue;// 好像是为了重新验证（last check before exiting）一下，转为小写是不是能走到这个分支。 &#125; &#125; return false;//出现不匹配就false &#125; return true;&#125; 比较并忽略大小写。返回的是一个三元表达式，比较的两个字符串是同一个对象会返回true，否则则要判断两者的内容了，对象不能是null，长度要相等，并且每一个字符还要匹配（regionMatches）。 startsWith123456789101112131415161718192021public boolean startsWith(String prefix, int toffset) &#123;// 字符串prefix用于查找 char ta[] = value;//原字符串的字符数组 int to = toffset; char pa[] = prefix.value;开始的字符串的字符数组 int po = 0;//从索引0开始比较 int pc = prefix.value.length;//字符串prefix长度 // Note: toffset might be near -1&gt;&gt;&gt;1. if ((toffset &lt; 0) || (toffset &gt; value.length - pc)) &#123; return false; &#125; while (--pc &gt;= 0) &#123;// 逐位比较 if (ta[to++] != pa[po++]) &#123; return false; &#125; &#125; return true;&#125;public boolean startsWith(String prefix) &#123;// 是不是某个字符串开头 return startsWith(prefix, 0);&#125; endsWith1234public boolean endsWith(String suffix) &#123;// 调用的还是startsWith的那个方法 return startsWith(suffix, value.length - suffix.value.length);&#125; hashCode123456789101112public int hashCode() &#123; int h = hash;// 默认的hash是0 if (h == 0 &amp;&amp; value.length &gt; 0) &#123;//初始的hash并且str是有值的 char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123;// 计算hash值 h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 将hash的字符串的char数组逐个遍历hash = 31 * hash + val[i]，就实现了hash的计算。 indexOf12345678910111213141516171819202122232425262728293031323334353637383940414243public int indexOf(int ch) &#123;//调用下面的方法 return indexOf(ch, 0);&#125;public int indexOf(int ch, int fromIndex) &#123; final int max = value.length;//最长遍历长度 if (fromIndex &lt; 0) &#123;// 范围不对的fromIndex会被默认为0或者不存在 fromIndex = 0; &#125; else if (fromIndex &gt;= max) &#123; // Note: fromIndex might be near -1&gt;&gt;&gt;1. return -1; &#125; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123;// 0x010000即65535，也就是有效输入 // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value;//从前往后找到第一个相同char的下标 for (int i = fromIndex; i &lt; max; i++) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1;//找不到就返回-1 &#125; else &#123; return indexOfSupplementary(ch, fromIndex); &#125;&#125;// Handles (rare) calls of indexOf with a supplementary(追加的) characterprivate int indexOfSupplementary(int ch, int fromIndex) &#123; if (Character.isValidCodePoint(ch)) &#123; final char[] value = this.value; final char hi = Character.highSurrogate(ch); final char lo = Character.lowSurrogate(ch); final int max = value.length - 1; for (int i = fromIndex; i &lt; max; i++) &#123; if (value[i] == hi &amp;&amp; value[i + 1] == lo) &#123; return i; &#125; &#125; &#125; return -1;&#125; lastIndexOf1234567891011121314151617181920212223242526272829303132333435public int lastIndexOf(int ch) &#123; return lastIndexOf(ch, value.length - 1);&#125;public int lastIndexOf(int ch, int fromIndex) &#123; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; int i = Math.min(fromIndex, value.length - 1);//等于遍历时从大到小，从后遍历到前面 for (; i &gt;= 0; i--) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return lastIndexOfSupplementary(ch, fromIndex); &#125;&#125;private int lastIndexOfSupplementary(int ch, int fromIndex) &#123; if (Character.isValidCodePoint(ch)) &#123; final char[] value = this.value; char hi = Character.highSurrogate(ch); char lo = Character.lowSurrogate(ch); int i = Math.min(fromIndex, value.length - 2); for (; i &gt;= 0; i--) &#123; if (value[i] == hi &amp;&amp; value[i + 1] == lo) &#123; return i; &#125; &#125; &#125; return -1;&#125; lastIndexOf与IndexOf的实现基本上差不多，lastIndexOf的实现就是从后往前找到第一个匹配的并返回索引。两者的差别就是遍历，一个从零往后++,另一个从后往前从length往前–。 重载indexOf方法，传入一个字符串对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public int indexOf(String str) &#123; return indexOf(str, 0);&#125;public int indexOf(String str, int fromIndex) &#123; return indexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex);&#125;static int indexOf(char[] source, int sourceOffset, int sourceCount, String target, int fromIndex) &#123; return indexOf(source, sourceOffset, sourceCount, target.value, 0, target.value.length, fromIndex);&#125;// 传入一个字符串，到了这里，参数的意义分别是source是原string的字符数组，sourceOffset，sourceCount是这个字符数组从0到str的总长度// target是查找的数组的字符数组，targetOffset，targetCount是它从0到总长度，fromIndex是查找的起始的位置。static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; // 排除特殊值 if (fromIndex &gt;= sourceCount) &#123; return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount);//执行循环的次数 for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first);//一直找到两个str首字符相同再比较 &#125; /* Found first character, now look at the rest of v2 */ if (i &lt;= max) &#123;//i要是&gt;max查找的str的长度肯定就比i后面的str部分长，没有必要比较了 int j = i + 1; int end = j + targetCount - 1; // 两个str要是不相等中途就break了，j的长度&lt;end for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); //j的长度&lt;end，进不了这个判断的分支 if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public int lastIndexOf(String str) &#123; return lastIndexOf(str, value.length);&#125;public int lastIndexOf(String str, int fromIndex) &#123; return lastIndexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex);&#125;static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, String target, int fromIndex) &#123; return lastIndexOf(source, sourceOffset, sourceCount, target.value, 0, target.value.length, fromIndex);&#125;static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; /* * Check arguments; return immediately where possible. For * consistency, don&apos;t check for null str. */ int rightIndex = sourceCount - targetCount; if (fromIndex &lt; 0) &#123; return -1; &#125; if (fromIndex &gt; rightIndex) &#123; fromIndex = rightIndex; &#125; /* Empty string always matches. */ if (targetCount == 0) &#123; return fromIndex; &#125; int strLastIndex = targetOffset + targetCount - 1; char strLastChar = target[strLastIndex]; int min = sourceOffset + targetCount - 1; int i = min + fromIndex;startSearchForLastChar:// 这个语法用于循环的跳转，类似于goto while (true) &#123; while (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123; i--; &#125; if (i &lt; min) &#123; return -1; &#125; int j = i - 1; int start = j - (targetCount - 1); int k = strLastIndex - 1; while (j &gt; start) &#123; if (source[j--] != target[k--]) &#123; i--; continue startSearchForLastChar; &#125; &#125; return start - sourceOffset + 1; &#125;&#125; last的实现也是类似于从右到左的实现了indexOf。 看了这么多的方法，可以得到一个结论，String在底层的实现都是字符数组的操作。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类型源码解析（一）]]></title>
    <url>%2F2018%2F06%2F03%2FJava-String%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[要讲Java的String类型，我们需要结合他的代码来看，根据源码的解读可以更好的理解Java底层实现的具体细节，所以这次的博客篇幅会比较的长，所以我会分成几个部分来写，希望通过源码的解读，学习到优秀的Java代码该如何实现。 本篇博客介绍String类的基本属性和众多的构造器，构造器的重载，体现出Java的多态性。 java.lang.String简介1.8版本String12* Copyright (c) 1994, 2013, Oracle and/or its affiliates. All rights reserved.* ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. String包声明在java.lang下。1package java.lang; String包简介：123456789* @author Lee Boynton//作者们* @author Arthur van Hoff* @author Martin Buchholz* @author Ulf Zibis* @see java.lang.Object#toString()// 另请参阅* @see java.lang.StringBuffer* @see java.lang.StringBuilder* @see java.nio.charset.Charset* @since JDK1.0//版本号 String类声明属性String类声明1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;&#125; final表示String类是不可被继承的，String实现了Serializable（可序列化）接口，Comparable（可比较）接口，CharSequence（字符序列）接口。 value属性12/** The value is used for character storage. */private final char value[]; The value is used for character storage.就是说这个声明的value数组用于存储字符，这个value非常的重要，String的底层实现都靠它来是实现。 并且声明的char类型的value数组使用final修饰，说明底层存储String对象是将String中的每一个字符存放到一个不可变的char类型的数组中。 hash属性12/** Cache the hash code for the string */private int hash; // Default to 0 默认缓存一个String的hash值，空列表（空字符串）的hash值默认是成员变量的初始默认值，这里是int类型，所以是0. serialVersionUID属性12/** use serialVersionUID from JDK 1.0.2 for interoperability */private static final long serialVersionUID = -6849794470754667710L; 定义了一个静态的serialVersionUID常量。作为IO时对象存入文件时使用。 String构造器们无参构造器12345678/** * Initializes a newly created &#123;@code String&#125; object so that it represents * an empty character sequence. Note that use of this constructor is * unnecessary since Strings are immutable. */public String() &#123; this.value = &quot;&quot;.value;&#125; 第一个构造器：无参构造器使用String的无参构造器生成的对象默认是一个空字符串。我们可以使用代码验证一下。123456class Test&#123; public static void main(String[] args)&#123; System.out.println(new String());// 调用字符串的无参构造器，会生成一个空字符串对象 System.out.println(1+new String()+2);//12 这里生成的是一个字符串拼接的结果 &#125;&#125; 传入String对象构造器1234567891011121314/** * Initializes a newly created &#123;@code String&#125; object so that it represents * the same sequence of characters as the argument; in other words, the * newly created string is a copy of the argument string. Unless an * explicit(明确的) copy of &#123;@code original&#125; is needed, use of this constructor is * unnecessary since Strings are immutable(不可变的). * * @param original * A &#123;@code String&#125; */public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; 第二个构造器：传入String对象String的有参构造器中可以传入一个字符串类型的对象，此构造器初始化字符串类型的value数组与hash值。in other words, the newly created string is a copy of the argument string.意思是换句话说，新创建的字符串复制了参数的字符串。 传入字符数组构造器123456789101112/** * Allocates a new &#123;@code String&#125; so that it represents the sequence of * characters currently contained in the character array argument. The * contents of the character array are copied; subsequent modification of * the character array does not affect the newly created string. * * @param value * The initial value of the string */public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125; 第三个构造器：传入一个字符数组很明显你还可以传入一个字符数组，当然你得到的还是一个新的字符串，字符数组的值赋给了String的value数组了。12345class Test&#123; public static void main(String[] args)&#123; System.out.println(new String(new char[]&#123;'j', 'e', 'f', 'f'&#125;));//jeff &#125;&#125; 传入下标字符数组构造器12345678910111213141516171819public String(char value[], int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= value.length) &#123; this.value = &quot;&quot;.value;//count=0，返回一个空串 return; &#125; &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; value.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125;//offset+count&gt;len,此时会报错 this.value = Arrays.copyOfRange(value, offset, offset+count);&#125; 第四个构造器：传入一个字符数组的起始下标与传入的个数。这种传入街截取下表索引的方式，一般的判断方式是：判断这两者都不能小于0，count=0则返回一个空串。offset+count超过总长也会报错。1234567class Test&#123; public static void main(String[] args)&#123; System.out.println(new String(new char[]&#123;'j', 'e', 'f', 'f', 'l', 'i', 'k', 'e'&#125;, 4, 4));//like System.out.println(new String(new char[]&#123;'j', 'e', 'f', 'f', 'l', 'i', 'k', 'e'&#125;, 4, 0));//还是一个空串 // System.out.println(new String(new char[]&#123;'j', 'e', 'f', 'f', 'l', 'i', 'k', 'e'&#125;, 4, 5));//java.lang.StringIndexOutOfBoundsException: String index out of range: 9 &#125;&#125; 传入Unicode数组的构造器1234567891011121314151617181920212223242526272829303132333435363738394041424344public String(int[] codePoints, int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= codePoints.length) &#123; this.value = &quot;&quot;.value; return; &#125; &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; codePoints.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; final int end = offset + count; // 到这里end的值已经不可能大于这个传入数组的总长了，上面进行了一系列的判断已经排除超出总长的可能性了 // Pass 1: Compute precise size of char[] int n = count; for (int i = offset; i &lt; end; i++) &#123;//遍历codePoints int c = codePoints[i]; if (Character.isBmpCodePoint(c))//Determines whether the specified character，这个功能貌似是判断这个字符是不是一个specified的字符 continue; else if (Character.isValidCodePoint(c))//whether the specified code point is a valid，这个字符是不是合法 n++; else throw new IllegalArgumentException(Integer.toString(c)); &#125; // Pass 2: Allocate and fill in char[] 填充这个char[] final char[] v = new char[n]; for (int i = offset, j = 0; i &lt; end; i++, j++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) v[j] = (char)c; else Character.toSurrogates(c, v, j++);//c是当前遍历到的字符，v是当前数组里所有的数值组成的数组，这个方法类似于将超长的非法的字符，转换成一个可以存储的字符 &#125; this.value = v;//将字符存到数组中，用于生成新的字符串&#125; 第五个构造器：参数int[] codePoints，Array that is the source of Unicode code points。传入的构造器实参可以是一个Unicode的数组。 1System.out.println(new String(new char[]&#123;&apos;\u4e01&apos;, &apos;\u6607&apos;&#125;, 0, 1));//丁 废弃了的构造器12345678910111213141516171819202122@Deprecatedpublic String(byte ascii[], int hibyte, int offset, int count) &#123; checkBounds(ascii, offset, count); char value[] = new char[count]; if (hibyte == 0) &#123; for (int i = count; i-- &gt; 0;) &#123; value[i] = (char)(ascii[i + offset] &amp; 0xff); &#125; &#125; else &#123; hibyte &lt;&lt;= 8; for (int i = count; i-- &gt; 0;) &#123; value[i] = (char)(hibyte | (ascii[i + offset] &amp; 0xff)); &#125; &#125; this.value = value;&#125;@Deprecatedpublic String(byte ascii[], int hibyte) &#123; this(ascii, hibyte, 0, ascii.length);&#125; 这两个构造器被声明为过时的希望不被再使用了。 传入字节数组及索引的构造器1234567891011121314151617public String(byte bytes[], int offset, int length, String charsetName)//传入字符编码charset throws UnsupportedEncodingException &#123; if (charsetName == null)// 还必须要传入一个charset throw new NullPointerException(&quot;charsetName&quot;); checkBounds(bytes, offset, length);//调用底下的检查，传入的数据是否合理 this.value = StringCoding.decode(charsetName, bytes, offset, length);&#125;// 判断传进来的参数与数组的关系private static void checkBounds(byte[] bytes, int offset, int length) &#123; if (length &lt; 0) throw new StringIndexOutOfBoundsException(length); if (offset &lt; 0) throw new StringIndexOutOfBoundsException(offset); if (offset &gt; bytes.length - length) throw new StringIndexOutOfBoundsException(offset + length);&#125; 第八个构造器：直接传进来一个byte的数组，起始和长度（类似于count）位置，最后还设置一个字符编码的格式。1234public String(byte bytes[], int offset, int length) &#123; checkBounds(bytes, offset, length); this.value = StringCoding.decode(bytes, offset, length);&#125; 传入参数不为null就调用的这个构造器。 传入字节数组的构造器1234public String(byte bytes[], String charsetName) throws UnsupportedEncodingException &#123; this(bytes, 0, bytes.length, charsetName);//调用上面的构造器&#125; 此构造器实际上就是调用了上面的构造器。并传入整个数组不进行切片。 1234 * @since 1.6public String(byte bytes[], Charset charset) &#123; this(bytes, 0, bytes.length, charset);&#125; 上面构造器1.6改写后的构造器，只是字符集条件不是String而是Charset类型。 接收StringBuffer作为参数的构造器12345public String(StringBuffer buffer) &#123; synchronized(buffer) &#123; this.value = Arrays.copyOf(buffer.getValue(), buffer.length()); &#125;&#125; 接收StringBuilder作为参数的构造器123public String(StringBuilder builder) &#123; this.value = Arrays.copyOf(builder.getValue(), builder.length());&#125; 结语： String类中有十几种构造器方法，构造器之间的重载，体现出Java的多态性。 构造器里可以传哪些东西：空参；String对象；字符数组；字符数组+offset+count；Unicode code points+offset+count；bytes数组+offset+count+charset；StringBuffer对象；StringBuilder对象。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java包装类]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[包装类的由来Java发明时正遇上C语言盛行的时候，因此Java保留/延续/借鉴了C语言中八种基本数据类型。但是Java是一门面向对象的语言，而八种基本数据类型不属于面向对象的范畴，但是基本数据类型有它的优势：（1）长度确定（2）计算效率高。所以Java还是选择保留了基本数据类型。所以Java和python不同的是，Java里并不是“一切皆对象”的。Java绝大部分的特性是为对象而设计的，例如：泛型，集合等，这些特性是不支持基本数据类型的。为了解决这样的矛盾，Java为八种基本数据类型设计了对应的包装类型。 基本数据类型与其对应的包装类 这些包装类型定义在java.lang包下，所以我们可以直接调用。 装箱与拆箱装箱就是把基本数据类型的数据装箱为包装类的对象。 Integer num = new Integer(int的变量或值);拆箱反过来把包装类型的对象，拆箱为基本数据类型的数据。 int m = Integer的对象.intValue();JDK1.5之前，只能用刚才的形式进行手动装箱和手动拆箱。JDK1.5之后，开始支持自动装箱与自动拆箱.JDK1.5之前的手动装箱拆箱的操作：123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; //1、创建一个包装类的对象 Integer i = new Integer(12); //2、手动装箱操作 int a = 10; //需要把变量a的值存储到集合，或传给引用数据类型的形参时，那么就需要把a变成包装类对象 Integer num = new Integer(a); Integer n1 = new Integer(10); Integer n2 = new Integer(20); // 手动拆箱 // 求和，对象不能直接相加,拆箱成基本数据类型 int m1 = n1.intValue(); int m2 = n2.intValue(); System.out.println(m1 + m2); &#125;&#125; JDK1.5之后，自动拆箱，装箱1234567891011121314151617public class TestWrapper &#123; public static void main(String[] args) &#123; //自动装箱，自动拆箱 int b = 10; Integer bNum = b;//自动装箱，等价于 Integer bNum = new Integer(b); Integer cNum = new Integer(23); int c = cNum;//自动拆箱，等价于 int c = cNum.intValue(); //5、演示错误 double d = 12;//整型的值是可以赋值给double型的变量，自动类型转换// Double dNUm = 12;//错误的 int类型的值和变量只能自动装箱为Integer// Double dNUm = 12.0F;//错误的，12.0F只能自动装箱为Float Double dNum = 12.0;//可以 &#125;&#125; 注意：装箱与拆箱的操作，只能与自己对应的基本数据类型和包装类进行，即没有变量提升一说。 数据类型转换字符串转成包装类对象各个包装类除了Character类型，其他7中类型都有1个构造方法，其参数是字符串类型。12Integer t2=new Integer(&quot;500&quot;);//参数是字符串，字符串的值是必须对应的数值Integer t3=new Integer(&quot;abc&quot;);// java.lang.NumberFormatException: For input string: &quot;abc&quot; 除此之外包装类的valueOf方法也可以做到。1Integer i=Integer.valueOf(&quot;500&quot;); 字符串转成基本数据类型通过包装类的parseXxx(String s)静态方法:123int i=Integer.parseInt(&quot;500&quot;);int i = Integer.valueOf(str1);//隐含了自动拆箱int j = new Integer(str1);//隐含了自动拆箱 缓存的常量对象在python中也存在着一个维持的小数池，对于-128到127的值，引用的是同一个对象，按道理说，每new一个包装类的对象，那他就会在堆中创建一个新的包装类对象，但是：123456789101112131415161718192021222324252627282930313233343536373839404142public class Main &#123; public static void main(String[] args) &#123; //1. 在堆中创建了两个Integer包装类对象，那么他们的地址肯定不同，比较一定是false Integer i1 = new Integer(1); Integer i2 = new Integer(1); System.out.println(i1 == i2);//false // 2.比较的是基本数据类型的大小，不是比较内存地址了，大小相等 int i3 = 128; int i4 = 128; System.out.println(i3 == i4);//true // 3. 不过是基本数据类型进行了自动装箱，本质上还是创建了两个包装类的对象，地址不同 Integer i5 = 128; Integer i6 = 128; System.out.println(i5 == i6);//false // 小于128的整型在方法区（暂且这么说）有一个常量池，都指向的是这个常量池对象，所以是同一个对象 int i7 = 1; int i8 = 1; System.out.println(i7 == i8);//true // 由于浮点数的存储机制不同，没有那么大的空间可以存常量，也不精确，所以覅浮点型是没有常量池的 Double d1 = 2.0; Double d2 = 2.0; System.out.println(d1 == d2);//false Boolean b1 = true; Boolean b2 = true; System.out.println(b1 == b2);//true Character c1 = 'a'; Character c2 = 'a'; System.out.println(c1 == c2);//true // 中文字符也是没有常量池的，字数太多了 Character c3 = '中'; Character c4 = '中'; System.out.println(c3 == c4);//false &#125;&#125; 包装类对象可能存储缓存的常量对象： Byte,Short,Integer,Long：-128~127 float，double：不缓存 Character：0~127 Boolean：true,false注意：常量池和对象的地址比较是相对于包装类来说的，基本数据类型与包装了类的比较不是比较的地址，比较的是熟知的大小。例如：123456789101112public static void ces() &#123; Integer i1 = 128; Integer i2 = 128; int i3 = 128; int i4 = 128; System.out.println(i1 == i2);// false System.out.println(i3 == i4);// true System.out.println(i1 == i3);// 判断的是值相等 true System.out.println(new Integer(10) == 10);// true&#125; i1与i3的比较是int与Integer的比较，两者比较的是值是否相等。 附：包装类还提供了处理 类型时非常有用的其他一些常量：(1)Integer Integer.MAX_VALUE Integer.MIN_VALUE(2)Double Double.MAX_VALUE Double.MIN_VALUE等 类型转换：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Main &#123; public static void main(String[] args) &#123; // String:"1", Integer对象:1，与int:1三者之间的转换关系 // 1. Integer转换为String的三种方式 // 1.1将Integer转换为String Integer int1 = new Integer(1); Integer int2 = null; String str1 = Integer.toString(int1); // String str11 = Integer.toString(int2);// 当Integer对象为空时,空指针异常 System.out.println(str1 instanceof String);// true // 1.2将Integer转换为String String str2 = int1.toString();// String str21 = int2.toString(); // 同样是空指针 System.out.println(str2 instanceof String);// true // 1.3将Integer转换为String String str3 = String.valueOf(int1); String str31 = String.valueOf(int2); String str32 = null; System.out.println(str2 instanceof String);// true System.out.println(str31 instanceof String);// true System.out.println(str32 instanceof String);// false // 2. String转换成Integer // 2.1 String s2 = "2"; Integer i2 = Integer.valueOf(s2); System.out.println(i2 instanceof Integer);// true // 2.2 Integer i3 = new Integer(s2); System.out.println(i3 instanceof Integer);// true // 3. String转换成int // 3.1 String s3 = "3"; int i4 = Integer.parseInt(s3); // 3.2 这两种给隐藏了自动拆箱的过程 int i5 = new Integer(s3); int i6 = Integer.valueOf(s3); // 4. int转换成String // 4.1 String s4 = 5 + ""; // 5. int与Integer之间的转换就是拆装箱的操作 // 5.1 手动装箱 Integer i7 = new Integer(5); // 5.2 自动装箱 Integer i8 = 5; // 5.3 手动拆箱 int i9 = i7.intValue(); // 5.4 自动拆箱 int int10 = i8; /* * 总结： 1. int,integer与String之间的转换方式非常的丰富； * 2. 在使用类型方法的时候记住不要是null对象调用，即注意空指针异常； * */ &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常处理]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常处理机制的目的是为了当程序发生异常时，使得程序不崩溃继续运行，同时通过提示用户等方式解决。 注意：语法错误不属于异常，这种情况编译不通过，无法运行；逻辑错误不属于异常，这种情况属于BUG，必须修正；异常本身是指不可预知的非正常的情况。在Java中异常也被封装成对象操作。不同的异常对象中封装了相应的错误信息。Java是采用面向对象的方式来处理异常的。 Java的异常处理机制的过程，原理：Java程序当某一句代码发生异常时，JVM会在该句代码的位置暂停下来，然后会根据异常的情况，创建一个相应的异常对象，这个对象会包含异常的类型、错误的信息等，并把异常对象提交给JRE。JVM会在这句代码的外围搜索有没有异常的处理的代码（例如：try…catch），如果有对应的catch可以捕获这个异常的对象，那么就相当于这个异常被处理了。程序继续从try..catch下面继续运行。如果没有对应的catch可以捕获它，那么当前代码的方法就会把这个异常对象，抛给上级（调用者），上级继续按照刚才的逻辑，先找是否有catch，如果有就捕获，从catch后继续运行，如果没有，继续往上级抛异常直到main都没有能够catch它，那么程序就崩溃了。 异常的超级父类异常的超级父类是java.lang.Throwable。Throwable类是Java语言中所有错误或异常的超类。只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。只有此类或其子类之一才可以是 catch 子句中的参数类型。 异常的分类Error重大错误：此类错误，不建议用try..catch等代码处理的，而是应该停下来，重新修正代码。 比较常见的有：VirtualMachineError(OutOfMemoryError堆内存溢出, StackOverflowError栈内存溢出) OOM错误12345678public class Main &#123; public static void main(String[] args) &#123; // 创建一个内存特别大的数组，此时数组所占内存的长度就大于内存会报超出内存的错误 // Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit int[] arr = new int[Integer.MAX_VALUE]; &#125;&#125; 栈溢出错误123456789101112public class Main &#123; public static void main(String[] args) &#123; // Exception in thread "main" java.lang.StackOverflowError test(); &#125; public static void test()&#123; test(); &#125;&#125; Exception异常，它指出了合理的应用程序想要捕获的条件。 异常也分为两种： (1) 受检异常，也称为编译时异常 即在编译时必须throws或者try..catch处理，否则编译不通过。 (2) 非受检异常，也称为运行时异常 编译时不提示，运行过程中可能发生的异常，例如：NullPointerException、ArrayIndexOutOfBoundsException，ClassCastException等。 异常处理异常处理的两个动作：抓（try…catch），抛（throws）。 try…catch1234567891011try&#123; 可能发生异常的代码&#125;catch(异常的类型1 异常名e)&#123; 抓住该异常后处理的代码&#125;catch(异常的类型2 异常名e)&#123; 抓住该异常后处理的代码&#125; ...finally&#123; 无论是否发生异常，都要执行的代码&#125; (1) 如果try中没有异常，那么catch中的不会执行; (2) 如果try中有异常，在发生异常的那句代码停下来，JVM会自动new一个异常的对象，抛出来，从上到下找对应的catch，如果类型匹配，就进入到catch中，如果所有catch的类都不匹配，就相当于没有抓住异常，默认抛出上一级。其中catch的关系应该是一层大于一层的，否则父类在前，子类在后，那么父类总会把子类的异常处理掉，那么默认子类异常毫无意义。 (3) finally块中的代码是不管try中是否发生异常，而且不管异常是否被catch，都要执行的代码。 注意：当异常处理的代码执行结束以后，是不会回到try语句块去执行尚未执行的代码的。只会执行try…catch…finally后面的代码。 关于finally不论什么情况都会在最后执行，相关练习：练习1：1234567891011121314151617181920212223242526public class Test&#123; public static void main(String[] args) &#123; int result = test(4,2); System.out.println(result); &#125; public static int test(int a, int b)&#123; int result = 0; try&#123; if(a&lt;0 || b&lt;0)&#123; result = -1; return result; &#125; result = a/b; return result; &#125;catch(Exception e)&#123; result = a + b; return result; &#125;finally&#123; result ++; return result;// 3 &#125; &#125;&#125; 一般函数在return后就结束了，但是在这里即使try中没有发生异常，并且执行到return，但是依然要执行完finally的内容才可以return，reuturn的是finally返回的result值。 1234567891011121314151617181920212223242526public class Test&#123; public static void main(String[] args) &#123; int result = test(4,0); System.out.println(result); &#125; public static int test(int a, int b)&#123; int result = 0; try&#123; if(a&lt;0 || b&lt;0)&#123; result = -1; return result; &#125; result = a/b; return result; &#125;catch(Exception e)&#123; result = a + b; return result; &#125;finally&#123; result ++; return result;// 5 &#125; &#125;&#125; 同理，在catch中有return但是实际的return的结果还是会返回finally的result结果。 123456789101112131415161718192021222324public class Test&#123; public static void main(String[] args) &#123; int result = test(4,0); System.out.println(result); &#125; public static int test(int a, int b)&#123; int result = 0; try&#123; if(a&lt;0 || b&lt;0)&#123; result = -1; return result; &#125; result = a/b; return result; &#125;catch(Exception e)&#123; result = a + b; return result; &#125;finally&#123; result ++; &#125; &#125;&#125; 如果finally中没有return的值，那么返回的result要看有没有异常被捕获了。即使如此finnaly的值还是被执行了的，只是在执行++之前，return的值已经在catch中返回了catch中的result的值了。 throws与try…catch不同，try…catch相当于捕获到异常自己就处理了，类比一些编程学习人员，遇到问题自己就解决了。而throws则是发现问题即时上报，相应的一部分人在学习编程时，只要一遇到任何问题，第一时间就抛出问题，不假思索的在学习群，社区或是论坛发出问题。一般的底层的也就是小白可以拥有throws的权利，但是到了最上层的大佬（main）他必须要使用try…catch方法解决问题。大佬也解决不了的问题，那一定是大问题，系统就崩了。 throws的语法12345【修饰符】 abstract 返回值类型 方法名（【形参列表】）【throws 异常列表】;【修饰符】 返回值类型 方法名（【形参列表】）【throws 异常列表】&#123; 方法体&#125; 其中RuntimeException及其子类可以不写【throws 异常列表】。其他类需要写【throws 异常列表】，异常列表可以是多个，顺序没有影响。 注意：在方法重写的时候，子类的重写的方法throws异常的类型 &lt;= 父类被重写的方法throws的异常类型。123456789101112class Father&#123; public void test()throws Exception&#123; &#125;&#125;class Son extends Father&#123; @Override public void test() throws RuntimeException &#123; &#125; &#125; 如果子类的异常类型大于父类的异常类型，那么子类可能会抛出一个异常，这个异常的类型大于父类的异常的类型，父类则无法接受此异常，就是类型转换异常了。 throw除了jvm会抛异常以外，程序员也可以在代码中手动抛异常。抛异常的工具就是throw。123456789101112131415161718192021222324public class TestThrow &#123; public static void main(String[] args) &#123; try &#123; Scanner input = new Scanner(System.in); System.out.println("请输入被除数："); int a = input.nextInt(); System.out.println("请输入除数："); int b = input.nextInt(); if(b==0)&#123; throw new Exception("除数不能为0"); &#125; &#125; catch (Exception e) &#123;// e.printStackTrace();//标准的异常信息打印形式，包含异常类型、异常的错误信息，堆栈跟踪信息等，底层其实用的是System.err打印 System.out.println(e);//把异常对象当做普通对象打印，只包含异常类型、异常的错误信息。 System.err.println(e);//把异常对象红色打印，包含异常的类型和错误信息 System.out.println(e.getMessage()); // System.out和System.err两个线程负责的，因此谁先出来，不一定。 &#125; &#125;&#125; 自定义ExceptionJava核心类库中无法涵盖所有的异常情况。某些异常情况，我也想要通过类型去说明问题，那么这个时候就可以自定义异常。 （1）必须继承Throwable或它的子类，我们写的一般是继承Exception或RuntimeException比较多。 （2）一般自定义异常需要实现java.io.Serializble接口（IO用），因为异常对象可能被记录日志中。 （3）自定义异常类型保留两个构造器：无参构造，另一个是为父类的message赋值的构造器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TestException &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println("用户名："); String user = input.next(); System.out.println("密码："); String pwd = input.next(); try &#123; boolean flag = login(user,pwd); System.out.println("登录成功"); &#125; catch (Exception e) &#123; System.out.println("登录失败，原因是：" + e.getMessage()); &#125; &#125; public static boolean login(String user, String pwd) throws Exception &#123; if ("jefflike".equals(user) &amp;&amp; "123".equals(pwd)) &#123; return true; &#125; else &#123; //用户名不存在，用户名和密码错误，服务器的问题等// return false; //用throw语句代替return 语句 if(!"jefflike".equals(user))&#123; throw new UsernameNotExistException("用户名不存在"); &#125;else&#123; throw new UsernameOrPasswordErrorException("用户名或密码错误"); &#125; &#125; &#125;&#125;class UsernameNotExistException extends Exception &#123; public UsernameNotExistException() &#123; super(); &#125; public UsernameNotExistException(String message) &#123; super(message); &#125; &#125;class UsernameOrPasswordErrorException extends Exception &#123; public UsernameOrPasswordErrorException() &#123; super(); &#125; public UsernameOrPasswordErrorException(String message) &#123; super(message); &#125;&#125; 注意： 要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下。 不要进行小粒度的异常处理——应该将整个任务包装在一个try语句块中。 异常往往在高层处理。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解]]></title>
    <url>%2F2018%2F05%2F29%2FJava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[上一篇博客提到了Java的枚举类型，Java的枚举类型从本质上实现是Java的类，所以可以看作是一个特殊的Java类。本篇博客要说的是Java里的注解（Annotation），此处说的注解与我们之前所说的单行注释，多行注释不是一类对象，单行注释，多行注释是编程人员将代码结构进行注释方便日后代码维护所添加的对机器无用的代码块，而Annotation会在代码中起到非常重要的作用，同时它可以被其他的程序读取，下面我们来详细的介绍。 注解三要素 声明（一般是框架或者核心类库等声明了注解，我们自己也可以自定义声明注解）； 使用注解（在程序的相应位置，按照一定的格式声明注解）； 读取注解（读取注解的程序一般声明注解的人写好的，我们不需要重复操作）。最基本的三个注解一、 @Override 声明：系统预定义的，JRE核心类库已经声明好了。在java.lang.Override中； 使用：在重写的方法上加注解，表示这个方法是重写的方法，并且检查重写的格式是否正确； 读取它：javac.exe读取它。 作用：编译时会对这个方法进行格式检查，看这个方法是否复合重写的要求。 二、@SuppressWarnings 声明：系统预定义的，JRE核心类库已经声明好了。在java.lang.SuppressWarnings中； 使用：在相应位置表示抑制xx警告； 读取：javac.exe读取它。 三、@Deprecated 声明：系统预定义的，JRE核心类库已经声明好了。在java.lang.Deprecated中； 使用：在相应位置使用，表示这个类、方法、属性（看使用的位置在哪）已经过时了，不再建议程序员使用它，以弹出警告的方式告知程序员这个xx已经过时了。 读取：javac.exe读取它。 注意：已过时的一般来说，就是设计有问题，或者有重大bug，不建议程序员使用的。 文档注解 声明：JRE核心类库已经声明好了。 使用：通用：123456/** * @author 作者 * @see 另请参阅 * @since 从xx版本开始 * @version 当前版本*/ 方法上：12345678910/** * 这是一个求两个整数的商的方法 * @param a int 被除数 * @param b int 除数 * @return int 返回a/b的商，只保留整数部分 * @throws ArithmeticException 当b=0时，会报算术异常 */public static int divide(int a, int b)throws ArithmeticException&#123; return a/b;&#125; 读取：javadoc.exe读取。 跟踪代码依赖性，替代原来.xml配置文件跟踪代码依赖性，实现替代配置文件功能，类似flask装饰器指向路由的使用，后续框架部分详细介绍。 JUnit框架的注解注意：使用JUnit测试的类必须是public的。JUnit4常见的注解和要求：这些方法都必须是public，无参，无返回值。 @Test 声明：不是JRE提供的，而是有JUnit框架提供的； 使用：使用的方法必须是公共的、无参、void、非静态的；12@Test(timeout=1000)：设置超时时间，如果测试时间超过了你定义的timeout，测试失败 @Test(expected)： 申明出会发生的异常，比如 @Test（expected = Exception.class） @BeforeClass 标记在静态方法上。因为这个方法只执行一次。在类初始化时执行。 @AfterClass 标记在静态方法上。因为这个方法只执行一次。在所有方法完成后执行。 @Before 标记在非静态方法上。在@Test方法前面执行，而且是在每一个@Test方法前面都执行。 @After 标记在非静态方法上。在@Test方法后面执行，而且是在每一个@Test方法后面都执行。 @Ignore 标记在本次不参与测试的方法上。这个注解的含义就是“某些方法尚未完成，暂不参与此次测试”。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class TestJUnit &#123; @Test public void test()&#123; System.out.println("helloworld"); &#125; @Test public void method()&#123; int sum = 0; for (int i = 1; i &lt;= 10; i++) &#123; sum += i; &#125; System.out.println("sum = " + sum); &#125; @BeforeClass public static void bc()&#123; System.out.println("在所有测试方法之前运行，而且一个类只运行一次"); &#125; @AfterClass public static void ac()&#123; System.out.println("在所有测试方法之后运行，而且一个类只运行一次"); &#125; @Before public void b()&#123; System.out.println("每一个测试方法之前运行"); &#125; @After public void a()&#123; System.out.println("每一个测试方法之后运行"); &#125; @Ignore public static void c()&#123; System.out.println("不参与测试"); &#125;&#125;public class TestTest &#123; public static void main(String[] args) &#123; TestJUnit t = new TestJUnit(); t.test(); &#125;&#125; 自定义注解注解三步走，声明，使用，读取，生成一个我们自己的注解也需要编写这三部分。 声明：12【修饰符】 @interface 注解名&#123;&#125; 元注解 给注解加的注解叫元注解，简称为注解的注解。用来注解我们自定义的注解的一些基本信息的。一共有四个。 @Target：目标位置，用来指明某个注解将来可以加在哪些位置。这个目标位置存放在ElementType枚举类型的常量对象中。 123456789101112131415161718192021222324252627282930313233343536373839public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE&#125; 注意：TYPE（类型上，例如：类、接口等），FIELD（属性上），METHOD（方法上）等。 @Retention：生命周期，用来指明某个注解被使用后，可以保留到什么阶段。三个阶段：RetentionPolicy枚举类型的三个常量对象：SOURCE：源代码阶段 –&gt; CLASS：字节码阶段–&gt;RUNTIME：运行时阶段(只有这个阶段的注解，才能被反射代码读取到). 123* 源代码 ---&gt;.class --&gt;Class ---&gt; 运行时* SOURCE CLASS RUNTIME* javac.exe 类加载器 反射 @Inherited：该注解是否可以被子类继承。 @Documented：该注解是否可以被javadoc.exe文档读取到API中。默认情况下,javadoc是不包括注解的，但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理。1234567891011121314151617181920212223public class TestDefineAnnotation &#123; public static void main(String[] args) &#123; //读取一个注解，我们自定义注解只能在运行时读取它，读取注解需要用到反射 Class&lt;MyClass&gt; clazz = MyClass.class; MyAnnotation my = clazz.getAnnotation(MyAnnotation.class); System.out.println(my); &#125;&#125;//使用一个注解@MyAnnotationclass MyClass&#123; @MyAnnotation public void test()&#123; &#125;&#125;//自定义注解，声明一个注解@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation&#123; &#125; 注解的配置参数在注解中往往还需要传入参数。声明：123【修饰符】 @interface 注解名&#123; 数据类型 配置参数名() 【default 默认值】;&#125; 赋值: （1）如果一个注解声明了配置参数，而且没有默认值，那么在使用注解时必须手动给它赋值,赋值的标准格式：( 参数名 = 参数值); （2）如果一个注解它的配置参数只有一个，而且参数名是value，那么可以在赋值的时候省略value=; （3）配置参数的类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组. 12345678910111213141516171819202122232425262728293031323334353637import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;class TestDefineAnnotation2 &#123; public static void main(String[] args) &#123; //3、读取注解 Class&lt;YourClass&gt; c = YourClass.class; YourAnnotation y = c.getAnnotation(YourAnnotation.class); String value = y.value(); System.out.println(value); Class&lt;OtherClass&gt; c2 = OtherClass.class; YourAnnotation y2 = c2.getAnnotation(YourAnnotation.class); String value2 = y2.value(); System.out.println(value2); &#125;&#125;//2、使用@YourAnnotation("dingjie")class YourClass&#123;&#125;//这里因为@YourAnnotation的配置参数有默认值，可以不赋值@YourAnnotationclass OtherClass&#123;&#125;//1、声明@Retention(RetentionPolicy.RUNTIME)@interface YourAnnotation&#123; String value() default "jefflike";&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名内部类和局部内部类扩展]]></title>
    <url>%2F2018%2F05%2F28%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AA%E8%83%BD%E8%AE%BF%E9%97%AEfinal%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[为什么匿名内部类和局部内部类只能访问final变量前面我们提到了Java里的内部类，也提到了关于局部内部类与匿名类，可以访问到所在方法的局部常量，并且在JDK8.0版本以后，即使你在方法中并没有声明变量为final，默认编译的时候也是final类型的，即你不可以改变此方法中被局部内部类引用了的变量（就是变量）。在这里就简单的说一说为什么Java会这样设定。 局部内部类或匿名内部类的对象可以被外部方法作为返回值，返回到方法外使用，那么如果这样的话，就会出现矛盾。12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; Change c = method(); //这里method()已经结束，按理说局部a早就失效，那么下面调用change()，打印出a的值就矛盾了，即change()访问了一个不存在的变量，这是不允许的。 c.change(); &#125; public static Change method()&#123; int a = 10; class Inner implements Change&#123; public void change()&#123; System.out.println("a="+a); &#125; &#125; Change in = new Inner(); return in; &#125;&#125;interface Change&#123; void change();&#125; 如果说这里的a是一个变量，那么这里就已经产生矛盾了。 要理解这一点，我们需要知道局部内部类和匿名内部类访问局部变量的机制。 在java中，类是封装的，内部类也不例外。我们知道，非静态内部类能够访问外部类成员是因为它持有外部类对象的引用 Outer.this，就像子类对象能够访问父类成员是持有父类对象引用super一样。局部内部类也和一般内部类一样，只持有了Outer.this，能够访问外部类成员，但是它又是如何访问到局部变量的呢？ 实际上java是将局部变量作为参数传给了局部内部类的构造函数，而将其作为内部类的成员属性封装在了类中。我们看到的内部类访问局。部变量实际上只是访问了自己的成员属性而已，这和类的封装性是一致的。那么上面的代码实际上是这样：12345678910111213141516171819202122232425262728293031public class TestInner &#123; public static void main(String[] args) &#123; Change c = method(); c.change(); //change()访问的就不是method()的局部变量a， //而是Inner内部类的成员变量a，只是它的值是method()的局部变量a的副本 &#125; public static Change method()&#123; int a = 10; class Inner implements Change&#123; //实际上内部做了这样的操作，内部类的a只是方法中的copy，是内部类的私有变量，所以自己可以访问得到 private int a; Inner(int a)&#123; this.a =a; &#125; public void change()&#123; // 调用的也是内部私有变量a，copy的a不是方法里面的变量a System.out.println("a=" + this.a); &#125; &#125; Change in = new Inner(a);//a=10 return in; &#125;&#125;interface Change&#123; void change();&#125; 所以，方法里的a改不改，和我内部类里面的a实际上没有关系。 那么，如果java不做这个自动添加final特性，而是将这两种a认作是两个变量（常量），那么我们的代码是这样的：1234567891011121314151617181920212223public class TestInner &#123; public static void main(String[] args) &#123; Change c = method(); &#125; public static Change method()&#123; int a = 10; class Inner implements Change&#123; public void change()&#123; a = 20; //如果这里可以修改a的值 System.out.println("a=" + a);//20 &#125; &#125; Change in = new Inner(); in.change(); System.out.println(“a=”+a);//从阅读角度，这里预期打印a=20，然而只会打印出a=10，会让人误解，因为在Inner的change()中修改的是Inner内部类对象的this.a，它是method的局部变量a的副本 return in; &#125;&#125;interface Change&#123; void change();&#125; 一眼看下去，我们一定认为，内部类引用了方法里的a，这样代码的可读性太差了。 结论为了保证阅读与运行的一致性，只能规定局部变量a（和副本a）不能修改，这样阅读和运行就可保持一致。那么就只能限定a为final，即定义为常量。当然，不是常量，声明周期也结束了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类]]></title>
    <url>%2F2018%2F05%2F26%2FJava%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java类的成员分为五类：属性，方法，构造器，代码块，和内部类。 为什么使用内部类首先类指的是：具有相同特性的事物抽象出的一类抽象概念，而接口则是具有某种相同功能的事物的抽象出的概念。但是事物与事物之间的关系除了什么是什么的关系，还存在着什么有什么的关系，在python中是以组合的概念描述，在Java里，我们一般使用内部类的来表示，什么有什么的这种关系。当然Java的面向对象也是有组合概念的，内部类不只是表达组合关系，而且在内部类中可以使用外部类的属性与方法。比如说，一个人的类，他有很多的器官，人的器官要使用人的血液，组织液等属性。人的器官使用人的心跳供血等方法，那么你可能会想，那么我们把器官抽象成一个属性，然后在外部类中给他创建方法不就可以使用器官类了吗。但是在实际的环境中，器官也可能是是一类抽象出来的类，它也是一个十分复杂的抽象概念，他是有细胞，组织等属性方法的类，不是一个外部类属性可以用一两个属性就能概括出来的概念。这时候我们需要使用到Java的内部类来描述器官这个抽象概念。 内部类特征 在一个类内部存在着一个独立的另一类事物，他也有自己的数据描述，行为特征，那么我们使用内部类来描述这个内部独立类事物； 内部类只为外部类服务，单独存在没有意义，而且可以访问到外部类的私有属性方法等，为外部类服务。内部类的分类 成员内部类（类中方法外） 静态成员内部类 非静态成员内部类 局部内部类（方法体{},方法形参(),代码块{}中） 局部内部类 匿名内部类 静态成员内部类声明1234外部类&#123; [修饰符] static class 静态内部类名 [extends 父类名] [implements 接口名]&#123; &#125;&#125; 权限修饰符private，缺省，protected，public，static，abstract，final。注意：修饰方法的时候，abstract与static不可以一起使用。（static不让继承，abstract必须继承的矛盾） 成员属性，方法，构造器，代码块，内部类 使用1.静态内部类使用外部类的成员123456789101112131415class Outer&#123; private String outField = "外部类非静态属性"; private static String outStaticField = "外部类静态属性"; static class Inner&#123; public void testIn()&#123; //System.out.println("outField=" + outField);//无法使用非静态的属性，Non-static field 'outField' cannot be referenced from a static context System.out.println("outStaticField=" + outStaticField); &#125; public static void methodIn()&#123; System.out.println("内部类的静态方法"); &#125; &#125;&#125; 通过上面一段代码，我们可以类比的出，在内部静态类中使用外部类的属性时，只可以使用外部类的静态属性，方法与代码块。（静态只能访问静态，此时非静态还未生成） 2.外部类中使用静态内部类的成员1234567891011121314151617181920212223242526272829class Outer&#123; private String outField = "外部类非静态属性"; private static String outStaticField = "外部类静态属性"; static class Inner&#123; public void testIn()&#123; System.out.println("outStaticField=" + outStaticField); &#125; public static void methodIn()&#123; System.out.println("内部类的静态方法"); &#125; &#125; // 2.在外部类中使用内部类的属性与方法 public void OutUseInt()&#123; //1. 使用内部类的静态属性与方法 Inner.methodIn(); // 2. 使用内部类的非静态属性与方法 new Inner().testIn(); &#125; static &#123; //1. 使用内部类的静态属性与方法 Inner.methodIn(); // 2. 使用内部类的非静态属性与方法 new Inner().testIn(); &#125;&#125; 通过上面的代码，我们可以看出来，在外部类使用内部类的静态与非静态属性方法时，与正常调用一个类的调用方式一致，一般要写在外部类的代码块或方法中。使用类名调用静态属性方法，使用对象调用非静态属性与方法。 3.在外部类的外面使用静态内部类的成员1234567891011public class Main &#123; public static void main(String[] args) &#123; // 3.在外部类的外面调用内部类的静态属性方法 Outer.Inner.methodIn(); // 创建内部类对象 Outer.Inner obj = new Outer.Inner(); obj.testIn(); &#125;&#125; 在主函数中（外部类的外面）调用内部类的静态方法与非静态方法，就是按照上述的方式。关于内部类的类型声明时的数据类型名，是按照他生成的字节码来生成的，文件中生成的字节码为Outer$Inner.class。内部类的类型为Outer.Inner。 非静态成员内部类声明1234外部类&#123; [修饰符] class 非静态内部类名 [extends 父类] [implements 接口名]&#123; &#125;&#125; 权限修饰符private，缺省，protected，public，abstract，final。 非静态那么static就不可以使用了。 成员在非静态内部类中不允许声明静态的成员（是因为加载的顺序的问题），除了静态的常量（常量的值在编译时已经确定了）。 使用1.在非静态内部类中使用外部类的成员123456789101112131415class Outer&#123; private String outField = "外部类的非静态属性"; private static String outStaticField = "外部类的静态属性"; class Inner&#123; public static final int MAX_VALUE = 10000;//常量可以// private static String inField;//非静态类中不能声明一个静态的属性或方法 public void testIn()&#123; // 1.非静态成员类中可以使用外部类的静态或非静态的属性与方法 System.out.println("outField =" + outField); System.out.println("outStaticField =" + outStaticField); &#125; &#125;&#125; 非静态成员内部类可以使用外部类的静态或非静态的属性与方法。 2.在外部类中使用非静态内部类的成员123456789101112131415161718192021class Outer&#123; private String outField = "外部类的非静态属性"; private static String outStaticField = "外部类的静态属性"; class Inner&#123; public static final int MAX_VALUE = 10000;//常量可以// private static String inField;//非静态类中不能声明一个静态的属性或方法 public void testIn()&#123; // 1.非静态成员类中可以使用外部类的静态或非静态的属性与方法 System.out.println("outField =" + outField); System.out.println("outStaticField =" + outStaticField); &#125; &#125; // 此处不可以是一个静态的方法 public void testOut()&#123; Inner in = new Inner(); in.testIn(); &#125;&#125; 因为非静态成员内部类没有静态属性与方法，所以调用他的非静态的属性与方法时，都需要生成一个内部类的对象，在调用属性与方法，并且不可以在外部类的静态代码块或方法里调用一个非静态的属性。3.在外部类的外面使用非静态内部类的成员分为两种方法：首先传统方法，在后面可能不适用。1234567891011121314151617181920212223242526272829303132333435363738394041public class Main &#123; public static void main(String[] args) &#123; //3.在外部类的外面调用内部非静态成员内部类 // 先创建的是外部类的对象 Outer out = new Outer(); // 方法一：创建一个内部非静态成员类的对象 Outer.Inner in = out.new Inner();//这种写法略微有点怪异了，一般也不使用这种方式。但是这么做是可以的 //最后就是使用了 in.testIn(); // 方法二：getInner方法 Outer.Inner in1 = out.getInner(); in1.testIn(); &#125;&#125;class Outer&#123; private String outField = "外部类的非静态属性"; private static String outStaticField = "外部类的静态属性"; class Inner&#123; public static final int MAX_VALUE = 10000;//常量可以// private static String inField;//非静态类中不能声明一个静态的属性或方法 public void testIn()&#123; // 1.非静态成员类中可以使用外部类的静态或非静态的属性与方法 System.out.println("outField =" + outField); System.out.println("outStaticField =" + outStaticField); &#125; &#125; public void testOut()&#123; //2.在外部类中调用非静态成员内部类的属性与方法 Inner in = new Inner(); in.testIn(); &#125; public Inner getInner()&#123; return new Inner(); &#125;&#125; 以上就是两种方法，如何在外部类的外部调用一个内部成员非静态类的属性与方法。后面一种get获取内部类的方式更为通用。注意：非静态内部类的字节码文件名：外部类$内部类.class，非静态内部类的全名称：外部类.非静态内部类。 有名字的局部内部类声明123456外部类&#123; 方法&#123; 【修饰符】 class 局部内部类 [extends 父类] [implements 接口名]&#123; &#125; &#125;&#125; 声明在方法中，代码块中都可以，一般都在方法中。 修饰符abstract,final。 注意：局部内部类与局部变量进行类比，他是没有权限修饰符的，同时也不会出现静态的属性，并且他也是没有static修饰的，static修饰类的成员。 使用1.在局部内部类中使用外部类的成员12345678910111213141516171819202122232425262728293031323334class Outer&#123; private String outField; private static String outStaticField; public void test()&#123; int a = 10;//局部变量 //局部内部类 class Inner&#123; private static final String NAME = "常量";//常量// private static String info;//局部内部类没有静态的属性方法 public void testIn()&#123; // 1. 有名字的局部内部类调用外部类的属性与方法 System.out.println("outField = " + outField); System.out.println("outStaticField = " + outStaticField); System.out.println("a = " + a);//优先方法中局部变量的值，其次成员变量的值 &#125; &#125; &#125; // 此时不可以使用外部类的静态成员 public static Object method()&#123; //局部内部类 class Inner&#123; private static final String NAME = "常量";//常量 public void testIn()&#123;// System.out.println("outField = " + outField);//方法是静态的，局部内部类则不能调用非静态的属性 System.out.println("outStaticField = " + outStaticField); &#125; &#125; &#125;&#125; 限制：能不能使用外部类的非静态成员，看局部内部类所在的方法是否是静态的。局部内部类取类外的值优先取方法中的值，没有再取成员变量的值. 2.在外部类中使用局部内部类12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Outer&#123; private String outField; private static String outStaticField; public void test()&#123; int a = 10;//局部变量// Inner in = new Inner();//1.会报错，需要先声明后使用// in.testIn(); //局部内部类 class Inner&#123; private static final String NAME = "常量";//常量// private static String info;//局部内部类没有静态的属性方法 public void testIn()&#123; // 1. 有名字的局部内部类调用外部类的属性与方法 System.out.println("outField = " + outField); System.out.println("outStaticField = " + outStaticField); System.out.println("a = " + a);//使用外部类的局部变量 &#125; &#125; Inner in = new Inner();//先声明后使用，有作用域 in.testIn(); &#125; public void testInner()&#123;// Inner in = new Inner();//2. 作用域隔离，注意作用=域 &#125; public static Object method()&#123; //局部内部类 class Inner&#123; private static final String NAME = "常量";//常量 public void testIn()&#123;// System.out.println("outField = " + outField);//方法是静态的，局部内部类则不能调用非静态的属性 System.out.println("outStaticField = " + outStaticField);// System.out.println("a = " + a);//使用外部类的局部变量 &#125; &#125; return new Inner(); &#125;&#125; 注意：使用的方式类似于局部变量的使用，需要先定义再使用。注意内部类名称的作用域，错误的作用域是无法调用的。 3.在外部类的外面使用局部内部类1234567891011public class Main &#123; public static void main(String[] args) &#123; //A：使用Inner类型不可以// Outer.Inner//错误的，没有这个字节码文件的生成 //B：获取到Inner的对象，使用多态引用 Object obj = Outer.method(); System.out.println(obj); &#125;&#125; 注意：在外部类的外面不可以使用局部内部类的类型；在外部类的外面可以获取到局部内部类的对象； 4.在局部内部类中可以使用所在方法/代码块的局部常量（final声明的） JDK1.8之前：必须手动加final JDK1.8之后：编译器会默认自动给加上final，如果不可以加final，那么报错。123456789101112131415161718class Outer&#123; private String outField; private static String outStaticField; public void test()&#123; int a = 10;//局部变量，实际上jdk8.0之后默认加了final，这是一个常量 // a = 20; //不能修改这个值，修改了局部内部类就会报错了。 //局部内部类 class Inner&#123; private static final String NAME = "常量";//常量 public void testIn()&#123; System.out.println("a = " + a);//使用所在方法/代码块的局部常量 &#125; &#125; &#125;&#125; 注意：局部内部类的字节码文件名：外部类名+$编号+局部内部类名.class，我们无法直接表示出一个有名字局部内部类的类型和对象，所以需要我们在方法中返回一个局部内部类的对象用于使用。 匿名内部类声明创建对象和声明类同时进行，一个匿名内部类只能有一个唯一的对象。123new 父类(【实参列表】)&#123;&#125;new 父接口()&#123;&#125; 特点 不存在修饰符； 创建对象与声明类同时进行，而且一个匿名内部类只有一个对象； 匿名内部类和局部内部类是一样的，可以用所在方法的局部常量（final）修饰1234567891011121314151617181920212223242526272829303132class TestAnonymousInner &#123; public static void main(String[] args) &#123; //这个f1指向的是Father的子类的对象 //多态引用 Father f1 = new Father()&#123; &#125;; System.out.println(f1.getClass());// class 包名.TestAnonymousInner$1 Father f2 = new Father()&#123; &#125;; System.out.println(f2.getClass());// class 包名.TestAnonymousInner$2 Father f3 = new Father()&#123; //重写父类的方法 @Override public void test()&#123; System.out.println("子类3重写父类的方法"); &#125; &#125;; f3.test();// 子类3重写父类的方法 &#125;&#125;class Father&#123; public void test()&#123; System.out.println("父类的测试方法"); &#125;&#125; 这里的f1和f2与f3指向的是三个不同的匿名对象，并且匿名对象里可以重写父类的方法，如果父类是一个抽象类或者接口，那么子类匿名类必须要实现父类的抽象方法。 如果父类中只有一个有参构造器，那么子类匿名内部类则需要调用父类的有参构造器创建类。12345678910111213141516171819class Father&#123; //只有一个有参构造 Father(String info)&#123; &#125; void test() &#123; System.out.println("父类方法"); &#125;&#125;class TestAnonymousInner &#123; public static void main(String[] args) &#123; Father m = new Father("实参")&#123; &#125;; &#125;&#125; 使用1.如果父类没有此方法，子类匿名内部类实现了这个方法：12345678910111213141516171819public class TestUse &#123; public static void main(String[] args) &#123; //多态引用，编译时按照父类编译 Object obj = new Object()&#123; public void test()&#123; System.out.println("匿名内部类的测试方法"); &#125; &#125;;// obj.test();//错误的,父类Object中没有test() //对象.方法() //匿名内部类的匿名对象 new Object()&#123; public void test()&#123; System.out.println("匿名内部类的测试方法"); &#125; &#125;.test(); &#125;&#125; 2.如果父类也有此方法，子类匿名内部类重写了这个方法：1234567891011121314151617public class TestUse2 &#123; public static void main(String[] args) &#123; Fu f = new Fu()&#123; public void test()&#123; System.out.println("子类"); &#125; &#125;; f.test();//子类 &#125;&#125;class Fu&#123; public void test()&#123; System.out.println("父类"); &#125;&#125; 3.匿名类作形参1234567891011121314151617181920212223public class TestUse3 &#123; public static void main(String[] args) &#123;// method();//实参应该是MyInter类型的一个对象，因为接口不能直接创建对象，应该传它的实现类的对象 method(new MyInter()&#123; @Override public void test() &#123; System.out.println("MyInter实现类重写了test方法"); &#125; &#125;); &#125; public static void method(MyInter my)&#123; my.test(); &#125;&#125;interface MyInter&#123; void test();&#125; 知识巩固12345class Outer&#123; abstract class Inner&#123; public abstract void test(); &#125;&#125; 问题：这是一个外部类，里面声明了一个内部类，那么如果我想要继承内部类Inner那么，我们要怎么操作呢？ 继承的语法格式：class 子类名 extends 父类名{} 非静态内部类的全名称： 外部类名.内部类名 继承抽象类：必须重写抽象类的抽象方法 要调用非静态内部类的构造器，需要外部类的对象 子类继承父类时，一定在子类的构造器的首行，一定要调用父类的构造器1234567891011121314class MyInner extends Outer.Inner&#123;/* MyInner()&#123; new Outer().super(); &#125;*/ MyInner(Outer out)&#123; out.super(); &#125; //重写抽象类的抽象方法 public void test()&#123; &#125;&#125; 注意：最后两点容易被忽视，继承内部类的时候要调用非静态内部类的构造器，需要外部类的对象。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interface实现多继承]]></title>
    <url>%2F2018%2F05%2F25%2FInterface%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[接口的概念在Java的面向对象里，类的继承关系是单继承的，与python的多继承不同，单继承的概念比较狭隘，在实际的环境里单继承的设计也不适用，Son不仅会继承father的属性，同时son也会继承mother的属性，而这种情况下，单继承就做不到让两个父类的属性都被子类继承了。不仅如此，在类抽象父类的过程中，鸭子可以水中游，船也可以水中游，但是鸭子和船却不能很好的抽象出一个合理的父类来。 接口使得很多没有父子类关系的类型对象，可以通过某个接口（标准）的类型，实现统一管理。简单的来说，我认为Java设计出接口的概念是实现多继承的一种方式，同时也是实现鸭子类型的一种方式。 接口的定义与继承接口和类是同一个级别的概念。可以理解为特殊的类，特殊的抽象类。调用的语法与声明class基本一致，只是将class关键字换成了interface。 定义：12[修饰符] interface 接口名&#123;&#125; 继承：12345678[修饰符] class 实现类 implements 父接口名&#123;&#125;[修饰符] class 实现类 implements 父接口名1，父接口名2，...&#123;&#125;[修饰符] class 实现类 extends 父类 implements 父接口名1，父接口名2，...&#123;&#125; 接口的特点 接口不能直接实例化，即不能直接创建对象(与抽象类类似)，他也不存在构造器; 接口中的成员： JDK1.8之前：接口中的成员只有三类： （1）公共的静态的常量：public static final，这几个修饰符可以省略 （2）公共的抽象的方法：public abstract，这两个修饰符可以省略 （3）公共的内部接口 设计接口的目的就是用来被实现的。 一个类实现了接口，就要求这个类必须重写（实现）接口的抽象方法，否则这个类也得是个抽象类。 一个类可以同时实现很多个接口(类似于多继承)。 一个类可以同时继承父类，又实现接口们。如果继承和实现同时存在，继承优先级更高。 接口与实现类的对象之间构成多态引用。 接口可以继承接口，而且可以继承多个接口。 coding理解interface的作用我现在想写一个可以为数组排序的一个工具类，但是不同类型的数组要怎么排序是一个问题，假设我有一个学生对象的数组，那么对于这个学生对象的数组排序，我是按照年龄排序还是按照学号排序，再或者我下一次放入一个全是整形的数组进行排序，那么我们如何让我的这个工具类都可以正常的运行呢？ 定义一个接口：12345678910111213/** 我们定义的这个接口定义了一个规范，实现我们的这个接口的类都必须实现自己的一套排序方式* 并且大小顺序按照此规则来定* */public interface SortAble &#123; /* * 规定：当前对象this 和 指定对象obj比较大小时， * 当 this “大于” obj时，返回正整数 * 当 this “小于” obj时，返回负整数 * 当 this “等于” obj时，返回零 */ public abstract int compare(Object obj);&#125; 定义一个学生类，按照接口定义的要求实现比较的细节：1234567891011121314151617181920212223242526272829303132333435363738class Student implements Sortable&#123; private int id; private String name; public Student(int id, String name) &#123; super(); this.id = id; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "Student [id=" + id + ", name=" + name + "]"; &#125; //实现接口，标准的抽象方法 @Override public int compare(Object obj) &#123;// this的学生对象和obj的学生对象进行比较大小，按照学号比较 Student other = (Student) obj; if(this.id &gt; other.id)&#123; return 1; &#125;else if(this.id &lt; other.id)&#123; return -1; &#125; return 0; &#125;&#125; 实现排序的细节：123456789101112131415161718192021public class MyArrays &#123; //功能：为任意类型的数组进行从小到大排序 //参数：Object[] public static void sort(Object[] arr)&#123; //冒泡排序：从小到大 for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length-i; j++) &#123; //如果arr[j]和arr[j+1]两个对象符合Sortable标准 //那么，我们就可以把arr[j]转成Sortable类型 Student s = (Student) arr[j];//这两种转换都可以 //Sortable s = (Sortable) arr[j]; //if(arr[j] &gt; arr[j+1])&#123;//if(前面的元素 &gt; 后面的元素)&#123; if(s.compare(arr[j+1]) &gt; 0)&#123; Object temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125;&#125; 最后我们可以进行测试：123456789101112131415class TestMyArrays &#123; public static void main(String[] args) &#123; Student[] students = new Student[3]; students[0] = new Student(4,"张三"); students[1] = new Student(1,"李四"); students[2] = new Student(5,"丁杰"); MyArrays.sort(students); for (Student student : students) &#123; System.out.println(student); &#125; &#125;&#125; 运行结果：123Student [id=1, name=李四]Student [id=4, name=张三]Student [id=5, name=丁杰] 通过上面的例子我们可以的出结论，只要是我们实现了Sortable接口的类，它实例出的对象就可以进行排序输出了。 JDK8后的接口特性接口成员除了公共的静态的常量：public static final，公共的抽象的方法：public abstract，公共内部接口以外又增加了：1234567891011121314interface MyInter&#123; //静态方法,通过接口名进行调用。 public static void method()&#123; System.out.println(&quot;接口中允许有静态方法&quot;); &#125; //默认方法,通过实现类的对象调用。子类可以不实现就直接调用，子类也可以进行重写 public default void test()&#123; System.out.println(&quot;接口的默认方法&quot;); &#125; //抽象方法 public abstract void fangFa();&#125; 默认方法：当接口的多个实现类关于某个抽象方法的实现是一样的，那么可以在接口中给出默认实现。1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestInterface &#123; public static void main(String[] args) &#123; MyInter.method(); MyImpl my = new MyImpl(); my.fangFa(); my.test(); OtherImpl other = new OtherImpl(); other.test(); &#125;&#125;interface MyInter&#123; //静态方法 public static void method()&#123; System.out.println("接口中允许有静态方法"); &#125; //默认方法, public default void test()&#123; System.out.println("接口的默认方法"); &#125; //抽象方法 public abstract void fangFa();&#125;class MyImpl implements MyInter&#123; @Override public void fangFa() &#123; System.out.println("实现类重写接口的抽象方法"); &#125;&#125;class OtherImpl implements MyInter&#123; //重写接口中的默认方法 public void test()&#123; System.out.println("重写接口的默认方法......"); &#125; @Override public void fangFa() &#123; System.out.println("实现类重写接口的抽象方法"); &#125;&#125; 运行结果：1234接口中允许有静态方法实现类重写接口的抽象方法接口的默认方法重写接口的默认方法...... 也就是说，如果你不重写父接口的默认方法，那么你就相当于继承了这个接口的此方法了。同时增加了静态方法，静态方法是不可以继承的这看起来有点奇怪，但是可能在某个时候会被我们使用到吧。 继承类与接口时遇到的冲突一个类同时实现的多个接口都有一个一样的默认方法1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestProblem1 &#123; public static void main(String[] args) &#123; MySub m = new MySub(); m.method(); &#125;&#125;interface A&#123; public default void method()&#123; System.out.println("A接口的默认方法"); &#125;&#125;interface B&#123; public default void method()&#123; System.out.println("B接口的默认方法"); &#125;&#125;// 实现了A和B，A和B都有自己的默认方法class MySub implements A,B&#123; /* @Override public void method() &#123; A.super.method();//保留A的方法实现 &#125;*/ /* @Override public void method() &#123; B.super.method();//保留B的方法实现 &#125;*/ /* @Override public void method() &#123; A.super.method();//保留A的方法实现 B.super.method();//也保留B的方法实现 &#125;*/ //选择C @Override public void method() &#123; System.out.println("我选择其他"); &#125;&#125; 继承的父类与实现接口中的默认方法一样123456789101112131415161718192021222324252627282930313233public class TestProblem2 &#123; public static void main(String[] args) &#123; Sub sub = new Sub(); sub.method(); &#125;&#125;interface myInter&#123; public default void method()&#123; System.out.println("接口中的默认方法"); &#125;&#125;class Father&#123; public void method()&#123; System.out.println("父类和接口的默认方法一样的方法"); &#125;&#125;class Sub extends Father implements myInter&#123; //(1)默认保留的是父类 //(2)明确保留父类的/* public void method()&#123; super.method(); &#125;*/ //(3)明确保留接口的/* public void method()&#123; myInter.super.method(); &#125;*/ //(4)两者都不要，其他 public void method()&#123; System.out.println("其他"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序初始化的顺序（二）]]></title>
    <url>%2F2018%2F05%2F23%2FJava%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[之前的一篇博客里我写了关于在一个类中的程序初始化顺序，但是在Java的面向对象里，类之间还存在着继承的关系。所以关于程序的初始化顺序，我们可以再细划分为：父类静态变量，父类的静态代码块，父类构造器，父类非静态变量，父类非静态代码块，子类静态变量，子类静态代码块，子类构造器，子类非静态成员变量和子类非静态代码块。本篇博客我们讨论的就是关于程序初始化的过程中，上述的成员在初始化加载先后顺序。在此前我们讨论得出的结论：在一个类中，Java程序加载的顺序是：静态变量–&gt;静态代码块–&gt;非静态变量–&gt;非静态代码块–&gt;构造器. 父类的代码：1234567891011121314151617181920212223242526public class SuperClass &#123; //父类与子类都在一个包中，这里我们就使用default修饰符 //这是一个父类的静态变量,此时还是初始化的默认值null static String superStaticVariale; // 静态代码块，给String赋值 static &#123; superStaticVariale = "父类静态代码块赋值成功"; System.out.println("此时运行的是父类的静态代码块："+superStaticVariale); &#125; // 无参构造，覆盖静态代码块的值 SuperClass()&#123; superStaticVariale = "父类构造器赋值成功"; System.out.println("此时运行的是父类的构造器："+superStaticVariale); &#125; //定义一个非静态变量 String superVariale; // 定义一个非静态代码块 &#123; superVariale = "父类非静态代码块赋值"; System.out.println("此时运行的是父类的非静态代码块："+superVariale); &#125;&#125; 子类的代码：123456789101112131415161718192021222324public class SubClass extends SuperClass&#123; static String subStaticVariale; // 静态代码块，给String赋值 static &#123; subStaticVariale = "子类静态代码块赋值成功"; System.out.println("此时运行的是子类的静态代码块："+subStaticVariale); &#125; // 无参构造，覆盖静态代码块的值 SubClass()&#123; superStaticVariale = "子类构造器赋值成功"; System.out.println("此时运行的是子类的构造器："+superStaticVariale); &#125; //定义一个非静态变量 String subVariale; // 定义一个非静态代码块 &#123; subVariale = "子类非静态代码块赋值"; System.out.println("此时运行的是子类非静态代码块："+subVariale); &#125;&#125; 测试代码：123456public class Main &#123; public static void main(String[] args) &#123; SubClass s = new SubClass(); &#125;&#125; 运行结果：123456此时运行的是父类的静态代码块：父类静态代码块赋值成功此时运行的是子类的静态代码块：子类静态代码块赋值成功此时运行的是父类的非静态代码块：父类非静态代码块赋值此时运行的是父类的构造器：父类构造器赋值成功此时运行的是子类非静态代码块：子类非静态代码块赋值此时运行的是子类的构造器：子类构造器赋值成功 很显然，在继承关系中，代码的加载顺序是：父类的静态变量–&gt;父类的静态代码块–&gt;子类静态变量–&gt;子类的静态代码块–&gt;父类非静态变量–&gt;父类的非静态代码块–&gt;父类的构造器–&gt;子类非静态变量–&gt;子类非静态代码块–&gt;子类构造器 进一步测试：12345678public class Main &#123; public static void main(String[] args) &#123; SubClass s = new SubClass(); SubClass s1 = new SubClass(); SubClass s2 = new SubClass(); &#125;&#125; 运行结果：1234567891011121314此时运行的是父类的静态代码块：父类静态代码块赋值成功此时运行的是子类的静态代码块：子类静态代码块赋值成功此时运行的是父类的非静态代码块：父类非静态代码块赋值此时运行的是父类的构造器：父类构造器赋值成功此时运行的是子类非静态代码块：子类非静态代码块赋值此时运行的是子类的构造器：子类构造器赋值成功此时运行的是父类的非静态代码块：父类非静态代码块赋值此时运行的是父类的构造器：父类构造器赋值成功此时运行的是子类非静态代码块：子类非静态代码块赋值此时运行的是子类的构造器：子类构造器赋值成功此时运行的是父类的非静态代码块：父类非静态代码块赋值此时运行的是父类的构造器：父类构造器赋值成功此时运行的是子类非静态代码块：子类非静态代码块赋值此时运行的是子类的构造器：子类构造器赋值成功 得出结论：父类与子类的静态代码都只执行一次，然后非静态代码块与构造器是组合出现的。 简化一下代码：12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; C c= new C(); &#125;&#125;class A&#123; A()&#123; System.out.println("A的无参构造器"); &#125;&#125;class B extends A&#123;// B(int a)&#123; B()&#123; System.out.println("B的无参构造器"); &#125;&#125;class C extends B&#123; C()&#123; System.out.println("C的无参构造器"); &#125;&#125; 运行结果：123A的无参构造器B的无参构造器C的无参构造器 调用C的构造器生成C的实例对象会从最上级的父类的无参构造器开始逐层调用，那么我们的类都继承了一个超级父类Object，也就是在我们最初的错误代码中，我们调用Student的无参构造创建一个对象时，首先会调用这个对象的父类Object的无参构造器，12345678910111213141516171819class Student&#123; String name; &#123; name = "老大"; &#125; Student()&#123; this(name);//这样会报错 super(); System.out.println("题目要求写一个无参的构造器"); &#125; Student(String name)&#123; this.name = name; System.out.println(name); &#125; &#125; 子类实例化默认调用父类的无参构造器，也就是如上this调用在super()之前（实际中这两者不会同时出现），name此时是非静态属性，此时会报错错误: 无法在调用超类型构造器之前引用name。123456789101112131415161718class Student&#123; static String name; &#123; name = "老大"; &#125; Student()&#123; this(name); System.out.println("题目要求写一个无参的构造器"); &#125; Student(String name)&#123; this.name = name; System.out.println(name); &#125; &#125; 当name是静态属性时，代码块是非静态时，编译通过，调用子类的无参构造器时this(name)，输出结果是：12null题目要求写一个无参的构造器 此时的this()调用实参构造并没有赋值成功。1234567891011121314151617class Student&#123; static String name; static&#123; name = "老大"; &#125; Student()&#123; this(name); System.out.println("题目要求写一个无参的构造器"); &#125; Student(String name)&#123; this.name = name; System.out.println(name); &#125;&#125; 此时运行结果：12老大题目要求写一个无参的构造器 这样赋值成功。由此证明我们的结论是正确的，this()是在子类父类构造器之前进行的操作super(),当子类代码块是非静态时，子类非静态代码块会在执行父类构造器之后执行，所以this(name)时name还没有被赋值，所以打印是null。 结论： 一个类中可以在无参构造器中调用此类的有参构造器（顺序反过来）； 在执行子类的无参构造器时会默认调用最高级父类无参构造，并逐级调用直至子类的无参构造； Java程序的加载顺为父类的静态变量–&gt;父类的静态代码块–&gt;子类静态变量–&gt;子类的静态代码块–&gt;父类非静态变量–&gt;父类的非静态代码块–&gt;父类的构造器–&gt;子类非静态变量–&gt;子类非静态代码块–&gt;子类构造器，且静态变量或代码块无论构造器调用多少次，他只会执行一次，后面再调用构造器则会执行非静态属性及代码块构造器。 最后关于为什么子类会调用父类的构造器，这个从设计着的角度来看是为了给从父类继承的属性初始化，子类需要知道父类是如何给属性初始化的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言Array与Slice]]></title>
    <url>%2F2018%2F05%2F21%2FGo%E8%AF%AD%E8%A8%80Array%E4%B8%8ESlice%2F</url>
    <content type="text"><![CDATA[数组基础为什么要讨论Go语言的数组在其他语言里，比如Java和python里数组(列表)，都是引用传递，但是到了Go语言里，数组的传递方式依然是值传递。那么值传递的数组是怎么使用的呢？这篇文章里简单的整理一下Go语言的数组的使用与其配合的Slice的工作原理。 数组定义的三种方式1234567891011// 1.定义一个数组，并赋值var arr1 [5]int//[0 0 0 0 0]//var arr1 = [5]int&#123;1,2,3,4,5&#125;//[1 2 3 4 5]// 2.:=要给数组赋初值arr2 := [3]int&#123;1,2,3&#125;//[1 2 3]fmt.Println(arr1, arr2)// 3.奇葩的赋值方式，但是好用，不确定数组的长度arr3 := [...]int&#123;2,4,6,7,10&#125;//[2 4 6 7 10]fmt.Println(arr3) 需要注意的是Go数组定义时必须指定数组的长度，并且不可以使用变量作为长度，即使变量已经赋值了。 遍历数组1234567891011121314151617181920//1.数组的遍历,长度为len()for i:=0;i&lt;len(arr2);i++&#123; fmt.Println(arr2[i])//1 2 3&#125;//2.range获取数组的下标，遍历数组for i:=range arr2&#123; fmt.Println(arr2[i])//1 2 3&#125;//3.range还可以获得数组的值for i, v:=range arr2&#123; fmt.Println(i, v)/&#125;//4.只要v的情况,_在Go语言中是一种通用方法，为匿名sum := 0for _, v := range arr2&#123; sum += v&#125; 函数内传入数组1234567891011121314//go语言的数组是值类型的，也就是说，在函数内是不会改变函数外调用的数组的值的func array2( arr [3]int)&#123; arr[0] = 100 for _,v :=range arr&#123; fmt.Println(v)//100,3,4,此处相当于将复制得来的数组改变了，但是外层的数组并没有改变 &#125;&#125;//var arr1 [5]intarr2 := [3]int&#123;2,3,4&#125;array1()//array2(arr1)//这里是会报错的，array2函数需要传入一个长度为3的数组，go语言里认为长度为3和长度为5的数组不是一个类型的，所以会飘红array2(arr2)fmt.Println(arr2)//[2 3 4] 注意： func内传入的形参是一个固定长度的数组，并且传递实参的时候只能传递一个相同长度的数组作为实参传递，否则程序会报错； 在函数中修改了数组的值，但是实际作为实参的数组的值却没有发生变化，这说明了数组只是传递了值，而不是将整个对象引用过去。形参copy了一个新的数组加以修改，而不是在原有的数组上进行修改。数组的“引用传递”Java与python中的数组本质上是一个对象，在引用传递的过程中，实际赋值操作时是将对象指向堆空间的内存地址进行传递，那么被赋值对象实际上与原对象指向的是同一块堆内存。修改其中的一个，另外一个也会相应的发生变化，这就是引用传递。Go实现类似应用传递的本质与上述的方法理论基本一致。Go指针在此处的作用大抵就是完成了上述的操作，指向同一块地址而不是copy一份到新的地址。12345678910func array3( arr *[3]int)&#123; arr[0] = 100 for _,v :=range arr&#123; fmt.Println(v)//100,3,4,此处相当于将复制得来的数组改变了，但是外层的数组并没有改变 &#125;&#125;//array3接收的是一个数组的指针，所以我们传一个arr的地址值进去array3(&amp;arr2)fmt.Println(arr2)//[100 3 4]，此时是相当于引用传递的，所以会改变数组的值 注意：从某种程度上来讲，Go语言是一门值传递语言，引入指针的概念后，更确切的说就是，Go语言的参数传递是值传递与指针传递的结合使用。 Slice我们一般翻译过来叫做切片。和其他语言的数组切片非常的相似，包括中括号取索引，半开半闭等，但是实际上Go语言的数组slice与他们相比又有很多独特的地方。 Slice切片的基本形式12345678910arr := [...]int&#123;2,4,6,8,10&#125;//两端都有s := arr[1:4]fmt.Println(s)//[4 6 8]//有前无后fmt.Println(arr[2:])//[6 8 10]//有后无前fmt.Println(arr[:4])//[2 4 6 8]//全切fmt.Println(arr[:])//[2 4 6 8 10] Go语言数组的正确打开方式其实通过上面的demo可以看出，不论是值引用方式还是指针引用方式，数组用起来都极为不便，func函数里的数组长度必须要求实参与之长度相同。这样用起来是十分麻烦的，这与Go语言所追求的极简的概念也有着冲突。所以我们平时开发时使用的都是Slice方式，你可以简单的把它理解为引用类型的数组。 12345678// 中括号不加数字就是一个切片func slice1(arr []int)&#123; //改动切片的数值 arr[0] = 100&#125;slice1(arr[:])fmt.Println(arr)//[100 4 6 8 10] Go语言在使用数组类似引用传递的操作时一般是不使用指针的，而是上述操作的切片的方式。go文档里说，slice是对数组的一个视图（view），只看我要看的这一小段。切片作为数组的上层视图，可以理解为就是对数组本身的某一段进行引用，那么在func中将其切片修改后，那么底层的数组的相对位置的数值就会被改变，所以类似于引用传递的方式传递实参给函数，即使用数组的切片作为形参时，可以实现引用传递。 reSlice123456//reslice操作,每次的下标都是针对自己的slicearr := [...]int&#123;2,4,6,8,10&#125;a := arr[:]a = a[:3]a = a[1:]fmt.Println(a)//[4,6] reSlice理解起来并不难，但是要是想进一步理解Go语言的切片需要理解Extending Slice的概念。 Extending Slice下面的一段代码：1234567arr1 := [...]int&#123;0,1,2,3,4,5,6,7&#125;s1 := arr1[2:6]//很明显此时s1的长度是4，即下标是0-3，那么此时的s2会不会报错，答案是不会报错 s2 := s1[3:5]fmt.Println(s2)//[5 6]s3 := s1[3:]fmt.Println(s3)//[5],默认是看不到cap()的值的，直接取s1[4]会报错 compare:12345arr = [0, 1, 2, 3, 4, 5, 6, 7]s1 = arr[2:6] # [2, 3, 4, 5]s2 = s1[3:5] # [5]print(s1, s2) Go在s2切片的时候下标已经超出s1的索引范围了，但是结果不仅没有报错，而且还正确的切到了下一个正确值6. golang中的slice除了len()还有一个cap()长度。虽然此时的len(s1)是4，但是cap(s1)还是6，slice是一个视图，视图再切片时还是能知道cap()下面的数据（索引为4和5）的，所以只要不超过cap()长度，即使s1取不到4，5（超过len()长度），但是s2依然可以取到。 slice的实现slice同时维护了ptr(指向切片头部的指针)，len(切片的长度),cap(切片的容量)三个值，其中ptr是切片的起始位置，设计成指针方便了切片传递时可以作为引用传递。len的长度是切片的长度，取切片索引值的时候不得超过len的值所以上面的例子不能直接取到s1[4]，cap长度代表的是容量长度，在此范围内切片是运行扩展的。切片可以在cap允许范围内向后扩展，不能向前扩展。1fmt.Printf(&quot;s1=%v cap=%d,len=%d\n&quot;, s1, cap(s1), len(s1))//s1=[2 3 4 5] cap=6,len=4 扩展切片s1的cap和len的长度如上。 切片操作append12345678910111213141516171819202122232425func main() &#123; arr := [...]int&#123;2,4,6,8,10&#125; // extending slice arr1 := [...]int&#123;0,1,2,3,4,5,6,7&#125; s1 := arr1[2:6] fmt.Printf("s1=%v cap=%d,len=%d\n", s1, cap(s1), len(s1))//s1=[2 3 4 5] cap=6,len=4 //很明显此时s1的长度是4，即下标是0-3，那么此时的s2会不会报错，答案是不会报错 s2 := s1[3:5] fmt.Printf("s2=%v cap=%d,len=%d\n", s2, cap(s2), len(s2))//s2=[5 6] cap=3,len=2 s3 := s1[3:] fmt.Println(s3)//[5],默认是看不到cap()的值的 //此处修改了原数组arr1 s4:=append(s2,10) //此处view的数组i已经不是原始的arr1了，系统为我们分配了一个更加长的数组进行view s5 := append(s4,11) s6 :=append(s5,12) fmt.Println("s4",s4)// s4 [5 6 10] fmt.Println("s5",s5)// s5 [5 6 10 11] fmt.Println("s6",s6)// s6 [5 6 10 11 12] fmt.Println("arr1",arr1)//arr1 [0 1 2 3 4 5 6 10] fmt.Println(cap(s4))// 3 fmt.Println(cap(s5))// 6,此时已经是新的数组了 fmt.Println(cap(s6))// 6&#125; 我们使用append增加数据到切片，当append后切片长度仍然小于等于cap长度时，修改的时当前视图的切片。所以原数组最后一位会被改成10，但是当append后切片长度已经超出cap，golang会自动分配一个新的数组盛放我们的数据，并且后面的slice都是新数组的视图，之前数组如果不再被引用，则会被gc回收。 为什么slice是引用传递的数据类型，我们append后还需要一个切片去接收呢？因为append后可能会导致数组copy到一个容量更大的数组，原来的slice的ptr，cap，len都改变了，我们需要一个新的slice对新数组的视图。 创建slice的方式第一种创建slice的方式就是对数组的切片操作。另一种创建slice的操作：1var arr []int// 声明一个slice类型的变量，具有zero value，此时为nil 我们可以对这个空的切片进行append操作，将值传入到切片中。12345678910func printSlice(a []int) &#123; fmt.Printf(&quot;a=%v, len(a)=%d,cap(a)=%d\n&quot;, a, len(a), cap(a))&#125; var b []int for i:=1;i&lt;100;i++&#123; b = append(b, i) printSlice(b) &#125; fmt.Println(b) 通过输出的cap长度可以看出，当数组盛放不下当前数据时，数组就会扩容一个长度扩大一倍的新数组，将旧数组copy到新数组中（不是slice，slice只是数组上层的视图，底层不是真的数据结构，是一个逻辑的结构）。 1234567// 切片静态赋值s:=[]int&#123;2,3,4,5&#125;// 创建一个只知道长度但是不知道内容的slices1 :=make([]int, 16)// 创建一个长度为16的切片s2 := make([]int, 10, 32)// 创建长度为10，容量为32的切片 删除一个slice元素1234s := []int&#123;1,2,3,4,5,6,7,8,9&#125;// 删除第三个数s = append(s[:2], s[3:]...)fmt.Println(s)// [1 2 4 5 6 7 8 9] go中的切片没有delete删除某一个元素的方法，切片之间没有+操作，所以拼接只能使用append，append第二个参数也不能是切片只能是…[]int可变参数类型，切片…与python的*args异曲同工。 删除一个元素以后，len会减小，cap长度不会变。 删除头部或尾部的数据：1234567 // 头部head := ab[0]ab = ab[1:]// 尾部 tail := ab[len(ab)-1] ab = ab[:len(ab)-1] 总的来说，在golang中使用切片的次数要多于使用数组，实际中还要根据情况自行使用最适合的语言，框架，数据结构等解决实际问题。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序初始化的顺序（一）]]></title>
    <url>%2F2018%2F05%2F20%2FJava%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[今天在写构造器方法的时候，遇到了一个小问题，由这个问题引发了一连串的思考，在一个Java类中变量与类的初始化执行顺序是什么样的呢？ 发现问题1234567891011121314151617181920212223242526272829class Student&#123; private String name; void setName(String name)&#123; this.name = name; &#125; String getName()&#123; return name; &#125; Student()&#123; //this(this.name); this(name); System.out.println("题目要求写一个无参的构造器"); &#125; Student(String name)&#123; this.name = name; &#125; &#125;class TestStudent&#123; public static void main(String[] args)&#123; Student stu1 = new Student(); System.out.print(stu1.getName()); Student stu2 = new Student("老大"); System.out.println(stu2.getName()); &#125;&#125; 此时会报错：无法在调用超类型构造器之前引用name. 在使用构造器创建对象时，此时的成员变量name的值是否已经完成初始化，无参构造中调用它时报的这个错意味着什么。我们本篇博客就来讨论一下，一个类创建对象时到底做了哪些事？ 思考问题首先，对于一个类来说加载分为五个部分，分别是静态变量，静态代码块，非静态变量，非静态代码块以及构造器。 单个类成员加载顺序测试代码：123456789101112131415161718192021222324252627282930313233class Student&#123; // 静态变量 static String name; // 静态代码块 static&#123; System.out.println("刚运行到静态代码块时的静态变量值："+name); name = "静态name值"; System.out.println("静态代码块结束时的静态变量值："+name); &#125; //定义一个无参构造器 Student()&#123; System.out.println("刚运行到构造器时的静态变量值："+name); name = "这是一个无参的构造器"; System.out.println("构造器结束时的静态变量值："+name); &#125; //定义一个非静态变量 String name2; //定义一个非静态代码块 &#123; System.out.println("刚运行到非静态代码块时的非静态变量值："+name2); name2 = "非静态name值"; System.out.println("非静态代码块结束时的非静态变量值："+name2); &#125;&#125;class TestStudent&#123; public static void main(String[] args)&#123; Student stu = new Student(); &#125;&#125; 此时编译代码执行的结果是：123456刚运行到静态代码块时的静态变量值：null静态代码块结束时的静态变量值：静态name值刚运行到非静态代码块时的非静态变量值：null非静态代码块结束时的非静态变量值：非静态name值刚运行到构造器时的静态变量值：静态name值构造器结束时的静态变量值：这是一个无参的构造器 由此可以看出，当我们声明的类成员变量是一个静态成员变量的时候，在调用构造器之前，我们的静态成员变量已经生成并初始化成相应的数据类型的默认值(即此处String对象的默认值位null)。然后在静态代码块中，我们将静态变量赋值，然后程序跳转到非静态变量声明与赋值。再执行非静态代码块，最后直行到程序的无参构造器。 所以，通过此程序代码，我们得出结论：单个类的程序加载顺序是：静态变量–&gt;静态代码块–&gt;非静态变量–&gt;非静态代码块–&gt;构造器。 也就是说调用构造器时，静态与非静态的属性都已经完成初始化工作了，this(name)调用报错与name属性本身没有关系。 深入思考类加载顺序既然说到加载顺序，那么我们继续完成类成员的加载顺序。关于变量与代码块之间的关系，或者说根据我们上面的这段代码得出这个初步的结论我们还有待商榷，因为，我们的程序加载的顺序是自上而下的，也就是说，我们的得到的这个结论有可能是因为我们习惯性的排版导致的，我们声明各部分的顺序偶可能影响我们得出的结论。为了确定我们程序的严谨性，我们需要进一步的调整代码的顺序，来加强验证我们代码实验的逻辑严谨性。 12345678910111213141516171819202122232425262728293031323334public class Student2 &#123; // 静态代码块放到前面，此时name还未声明，所以会报错 static&#123; System.out.println("刚运行到静态代码块时的静态变量值："+name); name = "静态name值"; System.out.println("静态代码块结束时的静态变量值："+name); &#125; // 静态变量 static String name; //定义一个无参构造器 Student2()&#123; System.out.println("刚运行到构造器时的静态变量值："+name); name = "这是一个无参的构造器"; System.out.println("构造器结束时的静态变量值："+name); &#125; //定义一个非静态代码块 &#123; System.out.println("刚运行到非静态代码块时的非静态变量值："+name2); name2 = "非静态name值"; System.out.println("非静态代码块结束时的非静态变量值："+name2); &#125; //定义一个非静态变量 String name2;&#125;class TestStudent&#123; public static void main(String[] args)&#123; Student stu = new Student(); Student2 stu2 = new Student2(); &#125;&#125; 上面代码运行的结果：1Error:(6, 48) java: 非法前向引用 此时将代码块拿到变量声明的前面我们的代码出现了错误提示，这说明了我们一开始得到的结论并不严谨，我们这里可以得出代码块的执行是在变量声明之前的。所以，我们可以根据常识大胆的猜想，单个类程序加载的顺序是静态–&gt;非静态–&gt;构造器，其中变量声明与代码块的执行顺序与代码前后位置有关，并没有严格的前后之分，程序员将代码写在前边的的先执行。 验证猜想12345678910111213141516171819202122232425262728293031public class Student3 &#123; //定义一个无参构造器 Student3()&#123; System.out.println("刚运行到构造器时的静态变量值："+name); name = "这是一个无参的构造器"; System.out.println("构造器结束时的静态变量值："+name); &#125; //定义一个非静态代码块 &#123; name2 = "非静态name值"; System.out.println("非静态代码块结束时的静态变量值："+name); &#125; //定义一个非静态变量 String name2; // 静态代码块 static&#123; System.out.println("运行到静态代码块");// name = "静态代码块里赋的值"; &#125; // 静态变量 static String name;&#125;class TestStudent&#123; public static void main(String[] args)&#123; Student3 stu3 = new Student3(); &#125;&#125; 上面代码执行的结果：1234运行到静态代码块非静态代码块结束时的静态变量值：null刚运行到构造器时的静态变量值：null构造器结束时的静态变量值：这是一个无参的构造器 基本验证了我们的猜想是正确的，但是在结尾我又做了一个有趣的测试。 测试12345678910111213141516171819202122232425262728293031public class Student3 &#123; //定义一个无参构造器 Student3()&#123; System.out.println("刚运行到构造器时的静态变量值："+name); name = "这是一个无参的构造器"; System.out.println("构造器结束时的静态变量值："+name); &#125; //定义一个非静态代码块 &#123; name2 = "非静态name值"; System.out.println("非静态代码块结束时的静态变量值："+name); &#125; //定义一个非静态变量 String name2; // 静态代码块 static&#123; System.out.println("运行到静态代码块"); name = "静态代码块里赋的值";// 按道理说，我们这里没有声明就直接赋值操作了 &#125; // 静态变量 static String name;&#125;class TestStudent&#123; public static void main(String[] args)&#123; Student3 stu3 = new Student3(); &#125;&#125; 上面代码执行的结果：1234运行到静态代码块非静态代码块结束时的静态变量值：静态代码块里赋的值刚运行到构造器时的静态变量值：静态代码块里赋的值构造器结束时的静态变量值：这是一个无参的构造器 也就是说在静态代码块里，我们无法引用后面的静态变量，但是我们编译之前可以对他进行赋值，并且在后面的非静态代码块里我们还可以取到里面的值，再次做出假设，这是java虚拟机在编译时不让向前引用，此时的变量其实已经完成了声明初始化等一系列操作（都是存在方法区），只是通过不了编译而已。所以我认为，我们最早得到的结论应该才是正确的Java程序整个加载流程的顺序。 这中间也可能时JDK和IDE一起努力做了点什么，但是实际上也不影响，我们的代码块的存在本来就是为了完成变量的初始化工作的，所以将代码块放到属性声明之前是毫无意义的操作，所以这里只是遇到了测试一下而已，实际操作中毫无意义。 得出结论总结：在一个类中，初始化顺序为： 静态变量，静态变量初始化； 静态代码块； 非静态变量初始化； 非静态代码块； 构造器。 ##最后到这里，我们理清楚了单个类中的各部分的加载顺序，但是我们文章一开始提到的问题并没有解决，如果构造器执行是在静态和非静态属性及代码块之后的话，此时的成员变量应当已经有了初始化值了，再不济成员变量还有一个初始的null值，但是这里报了无法在调用超类型构造器之前引用name。这说明这里调用name关系到了这个类的父类构造器，所以我们后面继续探讨类加载在继承中的加载顺序，就可以解决这个问题了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
