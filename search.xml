<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[String StringBuffer和StringBiuld]]></title>
    <url>%2F2018%2F06%2F11%2FStringAndStringBufferAndStringBiuld%2F</url>
    <content type="text"><![CDATA[前言通过前面查看String的源码，对String也有一定的了解了，String是编程语言里时常会使用到的数据类型，虽然Java里的String不是基本数据类型，但是他的重要性绝对不亚于基本数据类型的。关于String类型的问题，最大的一点就是String本身是一个不可变的数据类型，在完成大量的字符串拼接的情况下，非常的低效，所以后来就衍生出了可变字符序列。 可变字符序列是怎样实现的对于可变字符序列，他的底层还是字符数组，只是通过控制创建字符数组的长度，来减少新数组创建的次数，从而使得字符序列修改增删变得非常的便捷快速。 代码细节(以StringBuffer为例)底层实现依然是字符数组：1private transient char[] toStringCache; 构造器1234567891011121314151617public StringBuffer() &#123; super(16);// 初始化底层的字符数组的长度就是16&#125;public StringBuffer(int capacity) &#123; super(capacity);// 可以指明初始化时的字符数组的长度&#125;public StringBuffer(String str) &#123; super(str.length() + 16); append(str);&#125;public StringBuffer(CharSequence seq) &#123; this(seq.length() + 16); append(seq);&#125; 后两个构造器，初始化的字符数组的长度，比传入的字符大16，就是为了方便字符数组的扩容而准备充足的空间。 方法1234@Overridepublic synchronized int length() &#123; return count;&#125; 字符数组的长度。 1234@Overridepublic synchronized int capacity() &#123; return value.length;&#125; 当前容器的容量。 123456@Overridepublic synchronized char charAt(int index) &#123; if ((index &lt; 0) || (index &gt;= count)) throw new StringIndexOutOfBoundsException(index); return value[index];&#125; 索引为index的字符。 123456public synchronized void setCharAt(int index, char ch) &#123; if ((index &lt; 0) || (index &gt;= count)) throw new StringIndexOutOfBoundsException(index); toStringCache = null; value[index] = ch;&#125; 修改索引为index的字符。 重载了很多序列增删改查的方法，具体实现都是继承的父类相应的方法。 父类的序列扩容策略：123456789101112131415161718private int newCapacity(int minCapacity) &#123; // overflow-conscious code int newCapacity = (value.length &lt;&lt; 1) + 2; if (newCapacity - minCapacity &lt; 0) &#123; newCapacity = minCapacity; &#125; return (newCapacity &lt;= 0 || MAX_ARRAY_SIZE - newCapacity &lt; 0) ? hugeCapacity(minCapacity) : newCapacity;&#125;private int hugeCapacity(int minCapacity) &#123; if (Integer.MAX_VALUE - minCapacity &lt; 0) &#123; // overflow throw new OutOfMemoryError(); &#125; return (minCapacity &gt; MAX_ARRAY_SIZE) ? minCapacity : MAX_ARRAY_SIZE;&#125; 最近看到有面试题将String，StringBuffer和StringBuilder拿来作比较，所以就看了一下这三种类型，并且将他们做一个比较。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ClassLoader]]></title>
    <url>%2F2018%2F06%2F10%2FClassLoader%2F</url>
    <content type="text"><![CDATA[类加载过程将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据（类的成员等）只能通过这个Class对象。类加载(ClassLoader)的过程需要类加载器来完成。 类加载器分类（1）引导类加载器（bootstrap class loader）用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容），这个引导类加载器是用C/C++开发的。（2）扩展类加载器（extensions class loader）加载Java的扩展库（JAVA_HOME/jre/lib/ext/*.jar或java.ext.dirs路径下的内容）。（3）应用程序类加载器（application class loader）根据Java应用的类路径（classpath,java.class.path）的类，通俗的讲就是自定义类型。（4）自定义类加载器例如tomcat就是用自定义类 加载器去加载它需要的class类型，一般来说就是第三方但不是我们实现的类型。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflect]]></title>
    <url>%2F2018%2F06%2F10%2FReflect%2F</url>
    <content type="text"><![CDATA[Reflect我们一般单人编写代码时，使用到某个类都是先声明再使用，即声明类，创建类对象，调用方法，也就是说，我们知道我们要使用的类的各种细节，往往Reflect并不适用于这种情况。在通用性强的框架设计的代码里，才是Reflect大放异彩的地方，框架设计者并不需要知道使用框架的人设计类的细节，所以，框架设计者需要将一个未知类创建对象，调用对象方法。（1）即类型编译期未知但是我们需要写“创建它的对象的代码”，或者还要在运行期间“获取这个类型的信息”，并且“调用它的方法等”。 （2）同样，我们有时希望在运行期间，可以随意指定创建接口的任意一个实现类的对象，而不是在编译期间确定下来。 以上两点也是Reflect机制产生的原因。 一句话来说反射机制就是：可以于运行时加载、探知、使用编译期间完全未知的类。这体现了Java语言的动态性(虽然Java是一门静态语言)。 类加载完成后吗，在堆内存的方法区就成生了一个Class的对象(一个类只又一个Class对象)，这个Class对象包含这个类完整的结构信息，我们通过这个对象看类的结构的过程，我们就叫它反射。 Reflect使用情景 动态的创建任意类型的对象； 获取任意类型的信息； 获取任意对象的属性并设置或获取它的属性值； 获取任意对象的方法并调用它。 Reflect的根源是java.lang.Class，Class 类的实例表示正在运行的 Java 应用程序中的类和接口(他认为枚举是一种类，注解是一种接口)。Class是反射的根源。 注意：除了类(class)以外，每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。Java运行程序时，每一种类型被加载到内存后，都会产生这个类型的唯一的一个Class对象。 获取某个类型的Class对象获取运行时的Class的对象方式有四种： 类型.class，要求是编译期间这个类型是已知的。 对象.getClass()，getClass()在java.lang.Object类声明，获取某个对象的运行时类型。 Class.forName(“类型的全名称”)，在运行期间获取某个类型的Class对象，这个对象编译时可能不存在，但是运行时必须要存在，否则会抛ClassNotFoundException。 ClassLoader对象.loadClass(“类型的全名称”)。类型.class123456789101112131415161718192021222324252627282930313233343536373839404142class TestReflect &#123; public static void main(String[] args) &#123; // 类型.class // 引用数据类型 Class c1 = String.class; System.out.println(c1);// class java.lang.String // 接口 Class c2 = Runnable.class; System.out.println(c2);// interface java.lang.Runnable // 枚举类型 Class c3 = ElementType.class; System.out.println(c3);// class java.lang.annotation.ElementType // 注解 Class c4 = Override.class; System.out.println(c4);// interface java.lang.Override // 基本数据类型 Class c5 = int.class; System.out.println(c5);// int // 数组 Class c6 = int[].class; System.out.println(c6);// class [I // void Class c7 = void.class; System.out.println(c7);// void Class c8 = int.class; System.out.println(c5 == c8);// true Class c10 = int[][].class; System.out.println(c6 == c10);//维度不一样,不是同一个Class类 false Class c11 = double[].class; System.out.println(c6 == c11);//元素的数据类型不同，也不是同一个Class， false &#125;&#125; 特点： 在使用前已经知道确切的类型； 所有的Java在运行时都有确定的Class类型； Java运行程序时，每一种类型被加载到内存后，都会产生这个类型的唯一的一个Class对象，所以两个int.class是同一个Class对象； 关于数组，相同的数组对象必须是类型，维度都一样才是相同的Class对象。对象.getClass()1234567891011121314151617181920212223242526272829303132class TestReflect &#123; public static void main(String[] args) &#123; // 对象.getClass() // 引用数据类型 Class c1 = new String("jefflike").getClass(); System.out.println(c1);// class java.lang.String // 接口 Class c2 = new Runnable()&#123; @Override public void run() &#123; &#125; &#125;.getClass(); System.out.println(c2);// class com.jeff.TestReflect$1 // 基本数据类型// Class c5 = 1.getClass();// System.out.println(c5);// 静态数据类型没有.class // 数组 Class c6 = new int[2].getClass(); System.out.println(c6);// class [I Class c12 = new Student().getClass(); System.out.println(c12); // class com.atguigu.Student &#125;&#125;class Student&#123;&#125; 结论： java.lang.Object实现了getClass()，且底层实现是非java实现的，所以基本数据类型是不具有getClass()方法的。 调用getClass()的是运行时的实例对象，所以使用这种方法必须要有一个instance。 Class.forName(“类型的全名称”)12345678910111213public class Main &#123; public static void main(String[] args) throws Exception &#123; Class c = Class.forName("com.jeff.Test"); System.out.println(c);// class com.jeff.Test Class c1 = Class.forName("java.util.Scanner"); System.out.println(c1);// class java.util.Scanner &#125; public class Test &#123; &#125;&#125; 结论： 因为文件可能不存在，所以需要处理ClassNotFoundException异常； 即使类在编译时不存在，在编译过程中也不会报错； 在运行时如果类型还是不存在，那么会抛出异常。ClassLoader对象.loadClass(“类型的全名称”)1234567public class Main &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Class c2 = ClassLoader.getSystemClassLoader().loadClass("com.jeff.Test"); System.out.println(c2);// class com.jeff.Test &#125;&#125; 结论：与使用Class.forName(“类型的全名称”)基本上类似。 反射的作用No.1 在运行期间创建任意类型的对象Object newInstance()1234Class c2 = ClassLoader.getSystemClassLoader().loadClass(&quot;com.jeff.Test&quot;);System.out.println(c2);// class com.jeff.TestObject instance1 = c2.newInstance();System.out.println(instance1);// com.jeff.Test@4554617c 注意：使用此方法的类型必须包含无参构造，而且还不能是私有的无参构造器； 构造器对象.newInstance([形参列表])要点：用Class对象，获取到这个类型的构造器对象，然后在调用构造器对象.newInstance([形参列表])。既可以获取无参构造，也可以获取有参构造，还可以获取私有的构造器，有了构造器，就可以创建它的对象。因为构造器可能被重载，一个类型可能存在多个构造器，需要通过形参列表来确定用哪一个构造器，关注的是构造器的形参的类型以及个数，顺序，对于形参名不关心。1234567891011121314public class Main &#123; public static void main(String[] args) throws Exception &#123; Properties pro = new Properties(); pro.load(new FileInputStream("setting.properties")); // 配置文件在项目内src外 String s = pro.getProperty("key"); Class c3 = ClassLoader.getSystemClassLoader().loadClass(s); System.out.println(c3);//class com.atguigu.Test Constructor cs = c3.getConstructor();//获取无参构造,构造器可以不是public，但是不可以时私有 Object instance2 = cs.newInstance(); System.out.println(instance2);// com.atguigu.Test@74a14482 &#125;&#125; 12345678Properties pro = new Properties();pro.load(new FileInputStream(&quot;setting.properties&quot;)); // 配置文件在项目内src外String s = pro.getProperty(&quot;key&quot;);Class c3 = ClassLoader.getSystemClassLoader().loadClass(s);Constructor cs = c3.getConstructor(String.class, int.class);//获取形参列表是(String, int)的构造器,只返回制定参数类型访问权限是public的构造器Object instance3 = cs.newInstance(&quot;jeff&quot;, 25);System.out.println(instance3);// com.atguigu.Test@4554617c 1234Constructor cs = c3.getDeclaredConstructor(String.class, int.class);//获取形参列表是(String, int)的构造器,只返回制定参数类型访问权限是public的构造器cs.setAccessible(true);Object instance3 = cs.newInstance(&quot;jeff&quot;, 25);System.out.println(instance3);// com.atguigu.Test@4554617c 结论： Class对象获取它的构造器方法是getConstructor()； 获取无参构造器时方法内不需要传参数，但是无参构造器修饰符必须是public； 获取有参构造器时方法内需要传递相应的实参，构造器的修饰符也必须是public； getDeclaredConstructor()可以获取任意修饰符的构造器，要取得构造器使用权限需设置构造器对象.setAccessible(true)； 向构造器提供相应参数即可创建对象。 如此便可在运行过程中创建类的对象。 No.2 获取Class各类型对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Main &#123; public static void main(String[] args) &#123; //以String类型为例 Class clazz = String.class; //(1)获取类型全名称 System.out.println("类型全名称：" + clazz.getName());// 类型全名称：java.lang.String //(2)获取包名 Package p = clazz.getPackage(); System.out.println("包名：" + p.getName());//(3)获取类型的修饰符 int mod = clazz.getModifiers(); System.out.println("修饰符：" + mod);//修饰符：17 //修饰符类型Modifier System.out.println("修饰符：" + Modifier.toString(mod)); //(4)获取直接父类 Class c = clazz.getSuperclass(); System.out.println("父类：" + c.getName()); //(5)获取父接口们 System.out.println("父接口们："); Class[] interfaces = clazz.getInterfaces(); for (Class class1 : interfaces) &#123; System.out.println(class1); &#125; System.out.println("属性们："); //(6)获取属性们// clazz.getField(name)//获取具体的一个属性，而且是公共的// clazz.getDeclaredField(name)//获取具体的一个属性，只有是它声明的// clazz.getFields()//获取多个，都是公共的 Field[] fields = clazz.getDeclaredFields();//获取所有，只有是它声明的 //为什么要把属性抽象为Field类型，因为所有的属性都有修饰符，数据类型，属性名，都有set,get的行为 for (Field field : fields) &#123; System.out.println(field); &#125; //(7)获取构造器们 System.out.println("构造器们："); Constructor[] constructors = clazz.getDeclaredConstructors(); //构造器的共同特征：（1）修饰符（2）构造器名（3）形参列表（4）行为：创建对象newInstance() for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; //(8)获取方法们 System.out.println("方法们："); Method[] methods = clazz.getDeclaredMethods(); //方法的共同特征：（1）修饰符（2）返回值类型（3）方法名（4）形参列表（5）抛出的异常列表（6）行为：被调用 invoke for (Method method : methods) &#123; System.out.println(method); &#125; &#125;&#125; No.3 动态获取，设置对象属性与属性值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Main &#123; public static void main(String[] args) &#123; //以String类型为例 Class clazz = String.class; //(1)获取类型全名称 System.out.println("类型全名称：" + clazz.getName());// 类型全名称：java.lang.String //(2)获取包名 Package p = clazz.getPackage(); System.out.println("包名：" + p.getName());//(3)获取类型的修饰符 int mod = clazz.getModifiers(); System.out.println("修饰符：" + mod);//修饰符：17 //修饰符类型Modifier System.out.println("修饰符：" + Modifier.toString(mod)); //(4)获取直接父类 Class c = clazz.getSuperclass(); System.out.println("父类：" + c.getName()); //(5)获取父接口们 System.out.println("父接口们："); Class[] interfaces = clazz.getInterfaces(); for (Class class1 : interfaces) &#123; System.out.println(class1); &#125; System.out.println("属性们："); //(6)获取属性们// clazz.getField(name)//获取具体的一个属性，而且是公共的// clazz.getDeclaredField(name)//获取具体的一个属性，只有是它声明的// clazz.getFields()//获取多个，都是公共的 Field[] fields = clazz.getDeclaredFields();//获取所有，只有是它声明的 //为什么要把属性抽象为Field类型，因为所有的属性都有修饰符，数据类型，属性名，都有set,get的行为 for (Field field : fields) &#123; System.out.println(field); &#125; //(7)获取构造器们 System.out.println("构造器们："); Constructor[] constructors = clazz.getDeclaredConstructors(); //构造器的共同特征：（1）修饰符（2）构造器名（3）形参列表（4）行为：创建对象newInstance() for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; //(8)获取方法们 System.out.println("方法们："); Method[] methods = clazz.getDeclaredMethods(); //方法的共同特征：（1）修饰符（2）返回值类型（3）方法名（4）形参列表（5）抛出的异常列表（6）行为：被调用 invoke for (Method method : methods) &#123; System.out.println(method); &#125; &#125;&#125; 结论： Java面向对象的应用非常广泛； 类中的所有成员都可以被抽象出来，成为一类； 当一个类可以有多个XX时，返回的往往是一个数组；动态获取对象的属性123456Properties pro = new Properties();pro.load(new FileInputStream(&quot;setting.properties&quot;)); // 配置文件在项目内src外String s = pro.getProperty(&quot;key&quot;);Class c3 = ClassLoader.getSystemClassLoader().loadClass(s);Field f = c3.getDeclaredField(&quot;id&quot;);System.out.println(f);// private int com.atguigu.Test.id 获取运行Class对象，并获取属性。 动态设置对象的属性123456Constructor cc = c3.getConstructor();//获取无参构造Object instance2 = cc.newInstance();Field f = c3.getDeclaredField(&quot;id&quot;);System.out.println(f);// private int com.atguigu.Test.idf.setAccessible(true);f.set(instance2, 25); id属性是私有的，需要设置它可访问的权限,set设置此对象的值。 动态获取对象的属性值1234567891011121314Properties pro = new Properties();pro.load(new FileInputStream(&quot;setting.properties&quot;)); // 配置文件在项目内src外String s = pro.getProperty(&quot;key&quot;);Class c3 = ClassLoader.getSystemClassLoader().loadClass(s);Constructor cc = c3.getConstructor();//获取无参构造Object instance2 = cc.newInstance();Field f = c3.getDeclaredField(&quot;id&quot;);System.out.println(f);// private int com.atguigu.Test.idf.setAccessible(true);f.set(instance2, 25);Object a = f.get(instance2);System.out.println(a);// 25System.out.println(a instanceof Integer);// true 总结： 先得到运行的Class对象； 获得此对象的实例对象newInstance()； 获得属性对象Field； 操作属性对象set，get； 属性若是私有，需Class对象.getDeclaredField(属性名)获取属性对象； 操作它（set，get）需要设置它可访问的权限：属性对象.setAccessible(true)。No.4 动态调用对象的方法1234567891011121314151617181920class Test &#123; private int id; public Test()&#123;&#125; public Test(String a, int b)&#123; System.out.println(a + b); &#125; public void test(int id)&#123; this.id = id; System.out.println(this.id); &#125;&#125; Properties pro = new Properties(); pro.load(new FileInputStream(&quot;setting.properties&quot;)); // 配置文件在项目内src外 String s = pro.getProperty(&quot;key&quot;); Class c4 = ClassLoader.getSystemClassLoader().loadClass(s); Object obj = c4.newInstance(); Method m = c4.getDeclaredMethod(&quot;test&quot;, int.class); m.invoke(obj, 25); No.5 动态读取类与方法上的注解信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Main &#123; public static void main(String[] args) throws Exception&#123; // 动态读取自定义注解 //(1)获取类型的Class对象 Class clazz = MyClass.class; //(2)获取类上面的注解 //获取指定的注解类型对象，返回的对象是Annotation对象 Annotation a = clazz.getDeclaredAnnotation(MyAnnotation.class); //(3)获取注解的配置参数值 MyAnnotation m = (MyAnnotation) a; String value = m.value(); System.out.println(value);// jeff //(4)获取方法对象 Method m1 = clazz.getDeclaredMethod("test"); //(5)获取方法上的注解 Annotation a1 = m1.getDeclaredAnnotation(MyAnnotation.class); //(6)获取注解的配置参数值 MyAnnotation m2 = (MyAnnotation) a1; String value2 = m2.value(); System.out.println(value2);// jefflike &#125;&#125;// 使用自定义注解@MyAnnotation("jeff")class MyClass&#123; @MyAnnotation public void test()&#123;&#125;&#125;// 自定义注解//@Target指明这个注解只能用在类上和方法上//@Retention指明注解的生命周期，RUNTIME才能被反射读取到@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation&#123; String value() default "jefflike";&#125; 总结： 要能读取到注解信息，注解生命周期一定是RUNTIME。 getDeclaredAnnotation()方法得到的是Annotation类型，读取value值需要转化为MyAnnotation类型，Annotation没有value()。 自定义注解的value是一个方法，而不是属性。No.6 动态获取泛型父类的泛型实参123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TestGenericType &#123; public static void main(String[] args) &#123; Son s = new Son(); &#125;&#125;//1、声明泛型类,T是泛型形参//这个T什么时候指定（1）创建它的对象（2）继承时abstract class Father&lt;T,U&gt;&#123; private Class type;//希望存储的是T的泛型的实参的类型 //父类的构造器，无参构造 //子类继承时一定会调用父类的无参构造 Father()&#123; //因为Father是抽象类，不能直接创建对象，当子类创建对象时，会调用父类的无参构造， //那么这个this代表的是正在创建的子类的对象 //this.getClass()获取的是运行时的子类的类型 //(1)获取子类的类型 Class ziType = this.getClass(); System.out.println(ziType); //(2)获取子类的泛型父类的类型// Class fuType = ziType.getSuperclass();//这个方法可以获取父类的类型，但是不能包括泛型实参// System.out.println(fuType); //返回值类型是Type，而不是Class，因为我们的泛型的父类的&lt;&gt;中可能还是T等各种情况，不是百分百是具体的类型 Type type = ziType.getGenericSuperclass(); //因为这里的子类是Father&lt;String&gt;，那么它是属于ParameterizedType //(3)把泛型父类强制成ParameterizedType ParameterizedType p = (ParameterizedType) type; //(4)获取泛型父类的泛型实参的类型 Type[] arr = p.getActualTypeArguments(); type = arr[0]; System.out.println("T的泛型实参的类型是：" + type); &#125; public void test()&#123; //例如：在这里我想要获取T的泛型实参的类型 //转换为获取T的泛型实参的Class对象// System.out.println("泛型实参的类型是：" + T.class);//错误的 System.out.println("泛型实参的类型是：" + type); &#125;&#125;//2、声明子类，继承泛型父类，String是泛型实参class Son extends Father&lt;String,Integer&gt;&#123; &#125; 总结： 泛型形参直接.class是不能获取当前泛型实参类型的； 获取当前对象泛型实参的方式是创建子类对象时会调用父类的无参构造，父类无参构造的this就是子类的对象；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的设计模式]]></title>
    <url>%2F2018%2F06%2F06%2F%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[首先设计模式并不是那一种编程语言所特有的。设计模式是所有编程语言的从业人员，在实际的编写代码过程中，对于解决某种，某些特定问题比较优质的解决方案，设计模式代表的是一种种的思想，值得我们去学习和了解他。 本篇博客简单介绍一些简单的设计模式的思想及代码的简单实现。 模板设计模式说明这里的模板指的不是那种一成不变的模板，而是主体部分和格式是确定的（整体流程固定不变），少量的变化的部分由使用者修改（具体细节实现暂不确定），不同的人实现的不尽相同。类似于请假条模板，整个模板的功能就是书面表达请假信息，格式固定，一般公司的请假条模板，会空出姓名和时间由具体使用请假条对象的员工来填写。即当某个功能它的实现的算法结构（解题的思路，步骤）是固定的，但是其中某一小步，或几步的具体实现代码是不确定的，是变化的，应该有使用者来决定。 实现思路在父类中编写这个功能，把能确定的部分先实现，把不能确定的部分，通过抽象方法暴露出来，给子类（使用者）来实现它。 代码实现请假条模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 请假条的父模板abstract public class Tips &#123; // 所有人的请假条都是这个格式的 public String write()&#123; return "姓名：" + getName() + ",请假时间：" + getTime(); &#125; abstract String getName(); abstract void settName(String n); abstract String getTime(); abstract void setTime(String t);&#125;// 子类实现请假条提供方法public class MyTips extends Tips &#123; private String name; private String time; @Override void settName(String n) &#123; name = n; &#125; @Override String getName() &#123; return name; &#125; @Override void setTime(String t) &#123; time = t; &#125; @Override String getTime() &#123; return time; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Tips m = new MyTips(); m.settName("jefflike"); m.setTime("7:00-9:00"); System.out.println(m.write()); &#125;&#125; 请假条格式固定，将填写姓名和时间的方法抽象给子类（也就是填写请假条的人）来实现。这样每个人拿到这个请假条模板直接就可以修改自己的信息直接使用，就十分的方便。 实现程序运行时间模板123456789101112131415161718192021222324252627282930313233abstract class RunTime &#123; public final long getTime()&#123; long startTime = System.currentTimeMillis(); // 我们不知道运行那段代码 RunCoding(); long stopTime = System.currentTimeMillis(); return stopTime - startTime; &#125; protected abstract void RunCoding();&#125;public class SubRunTime extends RunTime &#123; public void RunCoding()&#123; long sum = 0; for(int i =0; i&lt;100000000; i++)&#123; sum += i; &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; SubRunTime s = new SubRunTime(); System.out.println(s.getTime()); &#125;&#125; 我们不需要知道子类到底进行测试时间的代码块是什么，我们将代码实现的整个过程固定下来，子类实现的代码块抽象成方法，让子类自行决定，这样我们的功能固定，就是一个测试时间的功能，但是不论子类实现什么样的代码，只要想看运行时间，都可以继承我这个模板。这与python的闭包装饰器的实现很相似，这就是模板设计模式。 简单工厂模式说明我们一般会在使用一个对象的时候new一个对象，工厂模式的目的是将创建对象与使用对象的操作分离开。 代码实现一个简单的汽车工厂123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TestSimpleFactory &#123; public static void main(String[] args) &#123; //(1)无工厂 BMW b = new BMW(); b.run(); //(2)通过工厂 //与BMW被使用者解耦合 Car car = SimpleFactory.getCar(1); car.run(); &#125;&#125;class SimpleFactory&#123; public static final int BMW = 1; public static final int AUDI = 2; public static Car getCar(int type)&#123; switch(type)&#123; case BMW: return new BMW(); case AUDI: return new Audi(); default: return null; &#125; &#125;&#125;interface Car&#123; void run();&#125;class BMW implements Car&#123; @Override public void run() &#123; System.out.println("宝马跑。。。。"); &#125;&#125;class Audi implements Car&#123; @Override public void run() &#123; System.out.println("奥迪跑..."); &#125;&#125; 使用工厂造车，我们除了解耦了使用与生产的过程，同时我们隐藏了造车的具体细节，我们只需要知道自己想要一个什么车，我们就能得到一个这个车的实例对象，而使用者并不需要知道怎么去造车。 一般工厂模式说明在简单工厂模式中，只存在一个工厂类，即汽车工厂。这算是简单工厂模式的一个弊端，他的工厂功能单一，难以扩展。即现在我的工厂只能生成奥迪或者宝马，我想再增加新的产品就必须修改我们的工厂类，这违背了面向对象设计模式的原则：对修改关闭，对扩展开放。所以简单工厂的扩展性限制了他的使用范围。而一般工厂模式可以做到当增加一个新产品，不会涉及到修改原来的代码，只要扩展新的产品类和对应工厂类即可。 实现思路建立多个工厂类，每个工厂只生产自己的单个商品，增加新商品就增加新的工厂类，而不需要修改原来的工厂代码。 代码实现新工厂1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class TestFactoryMethod &#123; public static void main(String[] args) &#123; Factory f = new BMWFactory(); Car car = f.getCar(); car.run(); &#125;&#125;//(1)接口：产品的的标准interface Car&#123; void run();&#125;//(2)接口的实现类们：产品class BMW implements Car&#123; public void run()&#123; System.out.println("宝马"); &#125;&#125;class Audi implements Car&#123; public void run()&#123; System.out.println("奥迪"); &#125;&#125;class QQ implements Car&#123; public void run()&#123; System.out.println("qq"); &#125;&#125;//（3）多个工厂：每一个工厂只生产一种产品interface Factory&#123; Car getCar();&#125;class BMWFactory implements Factory&#123; public BMW getCar()&#123; return new BMW(); &#125;&#125;class AudiFactory implements Factory&#123; public Audi getCar()&#123; return new Audi(); &#125;&#125;class QQFactory implements Factory&#123; public QQ getCar()&#123; return new QQ(); &#125;&#125; 一般工厂模式创建太多的代码，但是更符合面向对象的设计原则。 代理者模式说明代理者在我们生活中也有很多实例，比如中介就是代理的一员，我们的业务类只关注核心的，不易变的业务逻辑，而把一些复杂，多变的辅助功能交给代理完成。我们买房子关注的就是交钱和入住的环节，剩下由中介完成即可，所以这就是代理。 实现思路将被代理者作为实参传入代理者的代理方法中。 代码实现中介1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class TestProxy &#123; public static void main(String[] args) &#123; Buy b = new Proxy(new Customer()); b.buy(); &#125;&#125;//主题：联系代理者和被代理者的主题interface Buy&#123; void buy();&#125;//被代理者class Customer implements Buy&#123; @Override public void buy() &#123; System.out.println("付钱，拿钥匙入住，拿房本..."); &#125; &#125;//代理者class Proxy implements Buy&#123; private Buy target;//被代理者的目标 public Proxy(Buy target) &#123; super(); this.target = target; &#125; @Override public void buy() &#123; doBefore(); //核心业务功能，由被代理者自己完成 target.buy(); doAfter(); &#125; public void doBefore()&#123; System.out.println("寻找房源，甄别房源的真实性，是否是有抵押，是否是凶宅..."); &#125; public void doAfter()&#123; System.out.println("尾款的交付，物业的交割..."); &#125; &#125; 单例模式说明单例模式就是某个类型在整个系统运行期间，有且只有唯一的一个对象。单例模式在代码中使用的还是非常广泛的。比如再flask框架中，request对象时多个，并且每个用户的request对象都不一样，但是核心app对象（处理request等）就只有一个，处理不同request对象的都是唯一一个app核心对象。 实现思路单例的实现就是不想让使用者自己随意的创造实例对象，而是调用类已经创建好的对象。所以，我们需要暴露得到对象的方法，但是又隐藏构造器（没法直接new新的对象）。 coding实现单例模式最简洁的单例模式（饿汉式）：123enum Singleton&#123; INSTANCE&#125; enum的枚举对象就是隐藏了私有的构造器，当我们只有一个枚举对象的时候，就实现了单例模式。 饿汉式之二12345class Hungry&#123; public static final Hungry INSTANCE = new Hungry(); private Hungry()&#123; &#125;&#125; JDK1.5之前枚举类型的实现，这也是单例模式。 饿汉式之三12345678910class E&#123; private static final E INSTANCE = new E(); private E()&#123; &#125; public static E getInstance()&#123; return INSTANCE; &#125;&#125; 直接将获取实例的操作也私有化。 饿汉式的单例模式的问题是在创建类的时候就已经创建对象了，与之不同的是懒汉式，懒汉的特点就是用的时候在创建，未调用时实例并未创建。12345678910111213class Lazy&#123; private static Lazy instance; private Lazy()&#123; &#125; //当用户调用这个方法时，说明需要这个对象 public static Lazy getInstance()&#123; if(instance == null)&#123; instance = new Lazy(); &#125; return instance; &#125;&#125; 这样的懒汉式单例模式存在问题，在并发的调用时会存在多个线程同时抢夺到公共资源instance，此时instance的值为null那么这些线程每个人都有一个Lazy的对象，这就不是一个单例模式了。 所以改良一下这个单例模式。123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args) &#123; SingleTon s = SingleTon.getInstance(); SingleTon s1 = SingleTon.getInstance(); SingleTon s2 = SingleTon.getInstance(); System.out.println(s == s1); System.out.println(s2 == s1); &#125;&#125;class SingleTon extends Thread&#123; private static SingleTon instance; private SingleTon()&#123;&#125; public static SingleTon getInstance() &#123; if (instance == null) &#123; synchronized (SingleTon.class) &#123; if (instance == null) &#123; instance = new SingleTon(); &#125; &#125; &#125; return instance; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-String类型(三)]]></title>
    <url>%2F2018%2F06%2F05%2FJava-String%E7%B1%BB%E5%9E%8B-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[继续接着上一篇博客内容继续讲，看到源码的1925行，里面很多一部分都是注释，大部分的方法介绍的都很全面，基本上读完注释，使用起来没什么难度。这说明了，写代码多写注释确实是一个很好的习惯。 substring12345678910public String substring(int beginIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; int subLen = value.length - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);&#125; 只传一个数值参数，如果是0则返回整个string对象，否则要创建新的字符串，从beginIndex一直复制到末尾的位置。1234567891011121314public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; int subLen = endIndex - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen);&#125; 这个是重载的加强版，new String(value, beginIndex, subLen)，创建一个从index到end的新字符串。 subSequence123public CharSequence subSequence(int beginIndex, int endIndex) &#123; return this.substring(beginIndex, endIndex);// 底层的实现是substring方法&#125; 12345678910public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123;// 如果拼接的是空串 return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len);// 就是这个地方实现的拼接，这个方法用于拼接 return new String(buf, true);&#125; concat虽然实现了+=一样的效果，但是底层并不是用+=实现的。使用了str.getChars(buf, len)。 replace1234567891011121314151617181920212223242526public String replace(char oldChar, char newChar) &#123; if (oldChar != newChar) &#123; int len = value.length; int i = -1; char[] val = value; /* avoid getfield opcode */ while (++i &lt; len) &#123; if (val[i] == oldChar) &#123;//遍历找到i break; &#125; &#125; if (i &lt; len) &#123; char buf[] = new char[len]; for (int j = 0; j &lt; i; j++) &#123; buf[j] = val[j];// 新的字符数组 &#125; while (i &lt; len) &#123; char c = val[i];//并换掉之前的字符 buf[i] = (c == oldChar) ? newChar : c; i++; &#125; return new String(buf, true);// 同理返回的是一个新的字符串 &#125; &#125; return this;&#125; matches123public boolean matches(String regex) &#123; return Pattern.matches(regex, this);//与正则是否匹配&#125; contains123public boolean contains(CharSequence s) &#123; return indexOf(s.toString()) &gt; -1;&#125; contains的实现就是查看这个序列的字符串能不能索引的到，能索引的到肯定是有这个子串的。 replaceFirst1234// 正则匹配到的第一个，将其替换 public String replaceFirst(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceFirst(replacement); &#125; replaceAll1234// 先是匹配到所有的正则的字符串，然后都替换成新的str public String replaceAll(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceAll(replacement); &#125; replace1234public String replace(CharSequence target, CharSequence replacement) &#123; return Pattern.compile(target.toString(), Pattern.LITERAL).matcher( this).replaceAll(Matcher.quoteReplacement(replacement.toString()));&#125; replace也是全部替换，但是他不可以使用正则匹配，虽然他的底层使用了正则。 split12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public String[] split(String regex, int limit) &#123; /* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx&apos;s meta characters &quot;.$|()[&#123;^?*+\\&quot;, or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */ char ch = 0; // 验证正则 if (((regex.value.length == 1 &amp;&amp; &quot;.$|()[&#123;^?*+\\&quot;.indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == &apos;\\&apos; &amp;&amp; (((ch = regex.charAt(1))-&apos;0&apos;)|(&apos;9&apos;-ch)) &lt; 0 &amp;&amp; ((ch-&apos;a&apos;)|(&apos;z&apos;-ch)) &lt; 0 &amp;&amp; ((ch-&apos;A&apos;)|(&apos;Z&apos;-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) &#123; int off = 0; int next = 0; boolean limited = limit &gt; 0; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); while ((next = indexOf(ch, off)) != -1) &#123; if (!limited || list.size() &lt; limit - 1) &#123; list.add(substring(off, next)); off = next + 1; &#125; else &#123; // last one //assert (list.size() == limit - 1); list.add(substring(off, value.length)); off = value.length; break; &#125; &#125; // If no match was found, return this if (off == 0) return new String[]&#123;this&#125;; // Add remaining segment if (!limited || list.size() &lt; limit) list.add(substring(off, value.length)); // Construct result int resultSize = list.size(); if (limit == 0) &#123; while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) &#123; resultSize--; &#125; &#125; String[] result = new String[resultSize]; return list.subList(0, resultSize).toArray(result); &#125; return Pattern.compile(regex).split(this, limit);&#125;public String[] split(String regex) &#123; return split(regex, 0);&#125; 也是可以根据正则切割。 join123456789101112131415161718192021222324252627282930313233343536373839public static String join(CharSequence delimiter, CharSequence... elements) &#123; Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); // Number of elements not likely worth Arrays.stream overhead. StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) &#123; joiner.add(cs); &#125; return joiner.toString();&#125;public StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix) &#123; Objects.requireNonNull(prefix, &quot;The prefix must not be null&quot;); Objects.requireNonNull(delimiter, &quot;The delimiter must not be null&quot;); Objects.requireNonNull(suffix, &quot;The suffix must not be null&quot;); // make defensive copies of arguments this.prefix = prefix.toString(); this.delimiter = delimiter.toString(); this.suffix = suffix.toString(); this.emptyValue = this.prefix + this.suffix;&#125;public StringJoiner add(CharSequence newElement) &#123; prepareBuilder().append(newElement); return this;&#125;public static String join(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements) &#123; Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) &#123; joiner.add(cs); &#125; return joiner.toString();&#125; @since 1.8才有的这个方法。123456789class jie&#123;public static void main(String[] args)&#123; String c = "丁"; String d = "杰"; System.out.println(String.join(",", c, d, "是大帅哥"));// 丁,杰,是大帅哥 System.out.println("dingjie@123.com".replaceFirst("\\w+", "jefflike"));//jefflike@123.com&#125; &#125; 这个join是一个静态的方法，实现的功能类似于python的join效果。将字符串Sequence放到StringJoiner中，StringJoiner实现这个效果。 toLowerCase与toUpperCaseJava在实现这两个方法的过程上花了很大的篇幅，主要是考虑到实现的过程中保证线程安全。 trim123456789101112131415161718public String trim() &#123; int len = value.length; int st = 0; char[] val = value; /* avoid getfield opcode */ while ((st &lt; len) &amp;&amp; (val[st] &lt;= &apos; &apos;)) &#123; //找出前面空串的长度 &#125; st++; &#125; while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= &apos; &apos;)) &#123; //找出后面空串的长度 &#125; len--; &#125; // 通过字串截除有效的长度 return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;&#125; toCharArray123456public char[] toCharArray() &#123; // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result;&#125; 因为底层就是String的字符数组，所以直接copy过来返回就可以了。 format1234567public static String format(String format, Object... args) &#123; return new Formatter().format(format, args).toString();&#125;public static String format(Locale l, String format, Object... args) &#123; return new Formatter(l).format(format, args).toString();&#125; 静态的format方法1.5以后有的，调用Formatter实例对象实现。 valueOf12345678910111213141516public static String valueOf(Object obj) &#123; return (obj == null) ? &quot;null&quot; : obj.toString();&#125;public static String valueOf(char data[]) &#123; return new String(data);&#125;public static String valueOf(char data[], int offset, int count) &#123; return new String(data, offset, count);&#125;//可以看bollean的valueOfpublic static String valueOf(boolean b) &#123; return b ? &quot;true&quot; : &quot;false&quot;;&#125; 对于传入一个非null的对象，结果就是此对象的toString()方法。 copyValueOf12345678910111213public static String copyValueOf(char data[], int offset, int count) &#123; return new String(data, offset, count);&#125;public static String copyValueOf(char data[]) &#123; return new String(data);&#125;// 各种基本数据类型都可以作为此方法的参数public static String valueOf(char c) &#123; char data[] = &#123;c&#125;; return new String(data, true);&#125; 与上面的方法基本一致，只是返回的是一个新的字符串对象。 intern1public native String intern(); 这个方法的功能是将堆中的字符串数据作为常量存放到方法区的常量区，底层的代码实现不是用Java实现的，所以修饰符是native。 以上就是String的所有方法了，在实现String的代码过程中： String的底层都是使用字符数组完成各项操作； 大量使用注释，方便学习阅读各个方法的使用细节； 面向对象编程，大量使用重载和封装，减少代码冗余； 大量封装代码，减少代码复用； 在代码实现的细节上，首先会进行特殊值判断，null，length的特殊值，临界值等。 非常浅显的整理了一下String的源码，有些代码写得很精妙，但是还无法彻底领会，随着后面深入理解Java还会再次修改这里面的一些内容。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类型源码解析(二)]]></title>
    <url>%2F2018%2F06%2F04%2FJava-String%E7%B1%BB%E5%9E%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[本篇继续介绍String类的源码，从常用的类方法开始介绍。 String的长度123public int length() &#123; return value.length;&#125; 因为字符串的底层是由字符数组存放的就是char[] value，所以这个字符数组的长度就是有效的String对象的长度。 String是否为空123public boolean isEmpty() &#123; return value.length == 0;&#125; 同理，判断字符串对象是否为空就是判断底层字符数组是否长度为0. charAt()取出字符串中索引为index的字符。123456public char charAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125;// 不在合理返回会抛出异常 return value[index];&#125; 同理，返回的就是字符数组的相应索引的值。 codePointAt()123456public int codePointAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointAtImpl(value, index, value.length);&#125; 12345System.out.println(new String(new char[]&#123;&apos;\u1234&apos;,&apos;\u4e01&apos;, &apos;\u6607&apos;&#125;, 0, 1).codePointAt(0));//4660System.out.println(new String(new char[]&#123;&apos;\u4e01&apos;, &apos;\u6607&apos;&#125;, 0, 1).codePointAt(0));//19969 System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;, 4, 4).codePointAt(1));//105 System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;, 4, 4).codePointAt(2));//107 System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;, 4, 4).codePointAt(3));//102 index索引的char转化为十进制的值（其实就是Unicode编码值，体现为十进制数字），底层是字符的codePointAtImpl方法实现的。 codePointBefore1234567public int codePointBefore(int index) &#123; int i = index - 1; if ((i &lt; 0) || (i &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointBeforeImpl(value, index, 0);&#125; 123System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;, 4, 4).codePointBefore(1));//108System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;, 4, 4).codePointBefore(2));//105System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;, 4, 4).codePointBefore(3));//107 作用是：index索引前一个字符转化为十进制的值。实现方式与上面完全一致。完全可以调用上面的方法，传入index-1实现。 codePointCount()123456public int codePointCount(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0 || endIndex &gt; value.length || beginIndex &gt; endIndex) &#123; throw new IndexOutOfBoundsException(); &#125; return Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex);&#125; 1System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;).codePointCount(1,7));//6 统计区间中的字符数，半闭半开区间。 offsetByCodePoints1234567public int offsetByCodePoints(int index, int codePointOffset) &#123; if (index &lt; 0 || index &gt; value.length) &#123; throw new IndexOutOfBoundsException(); &#125; return Character.offsetByCodePointsImpl(value, 0, value.length, index, codePointOffset);&#125; 个人觉得这个方法貌似没什么用，value从index到codePointOffset的长度。12System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;).offsetByCodePoints(1,7));//8System.out.println(new String(new char[]&#123;&apos;j&apos;, &apos;e&apos;, &apos;f&apos;, &apos;f&apos;, &apos;l&apos;, &apos;i&apos;, &apos;k&apos;, &apos;e&apos;&#125;).offsetByCodePoints(1,1));//2 getChars12345678910111213141516void getChars(char dst[], int dstBegin) &#123; System.arraycopy(value, 0, dst, dstBegin, value.length);&#125;public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123; if (srcBegin &lt; 0) &#123; throw new StringIndexOutOfBoundsException(srcBegin); &#125; if (srcEnd &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(srcEnd); &#125; if (srcBegin &gt; srcEnd) &#123; throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); &#125; System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);&#125; 暂时不知道会用在哪里，没有返回值，但是会从原字符串切一段。 getBytes()12345678910111213141516171819202122@Deprecatedpublic void getBytes(int srcBegin, int srcEnd, byte dst[], int dstBegin) &#123; if (srcBegin &lt; 0) &#123; throw new StringIndexOutOfBoundsException(srcBegin); &#125; if (srcEnd &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(srcEnd); &#125; if (srcBegin &gt; srcEnd) &#123; throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); &#125; Objects.requireNonNull(dst); int j = dstBegin; int n = srcEnd; int i = srcBegin; char[] val = value; /* avoid getfield opcode */ while (i &lt; n) &#123; dst[j++] = (byte)val[i++]; &#125;&#125; 上面的无返回值的getBytes()已经不使用的12345public byte[] getBytes(String charsetName) throws UnsupportedEncodingException &#123; if (charsetName == null) throw new NullPointerException(); return StringCoding.encode(charsetName, value, 0, value.length);&#125; 将整段字符串的每个字节按照相应的编码转换成二进制存放到byte[]。123456789101112131415161718import java.io.UnsupportedEncodingException;class Test&#123; public static void main(String[] args)&#123; try&#123; byte[] str = "丁杰".getBytes("utf-8");//utf8每个汉字是三个字节， System.out.println(str[0]);//-28 System.out.println(str[1]);//-72 System.out.println(str[2]);//-127 System.out.println(str[3]);//-26 System.out.println(str[4]);//-99 System.out.println(str[5]);//-80 System.out.println(str[6]);//异常 &#125;catch(UnsupportedEncodingException e)&#123; System.out.println(e); &#125; &#125;&#125; equals123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123;// 首先，比较的两者都是同一个对象，那么返回ture return true; &#125; if (anObject instanceof String) &#123;// 如果传进来进行比较的也是String类型的对象 String anotherString = (String)anObject;//强制类型转换 int n = value.length; if (n == anotherString.value.length) &#123;//首先两者的字符的长度一定是相等的 char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123;//长度等于零的时候停止循环，整个遍历的过程只要出现两者的字符不相等情况就返回false停止循环 if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; String继承了超级父类Object，所以他也有equals方法，并且String重写了父类的equals方法。先进行了一系列的操作，然后遍历底层的两个字符数组，判断两者的字符是否完全一致，只有两者完全一致的情况下才会返回true。 contentEquals1234567891011121314151617181920212223242526272829303132public boolean contentEquals(StringBuffer sb) &#123; return contentEquals((CharSequence)sb); &#125; public boolean contentEquals(CharSequence cs) &#123; // Argument is a StringBuffer, StringBuilder if (cs instanceof AbstractStringBuilder) &#123; if (cs instanceof StringBuffer) &#123; synchronized(cs) &#123; return nonSyncContentEquals((AbstractStringBuilder)cs); &#125; &#125; else &#123; return nonSyncContentEquals((AbstractStringBuilder)cs); &#125; &#125; // Argument is a String if (cs instanceof String) &#123; return equals(cs); &#125; // Argument is a generic CharSequence char v1[] = value; int n = v1.length; if (n != cs.length()) &#123; return false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (v1[i] != cs.charAt(i)) &#123; return false; &#125; &#125; return true;&#125; 配合下面的方法，判断出String与StringBuffer对象内容完全相等。 nonSyncContentEquals1234567891011121314private boolean nonSyncContentEquals(AbstractStringBuilder sb) &#123; char v1[] = value; char v2[] = sb.getValue(); int n = v1.length; if (n != sb.length()) &#123; return false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (v1[i] != v2[i]) &#123; return false; &#125; &#125; return true;&#125; 判断字符串与AbstractStringBuilder对象的值（内容也是字符串类似的）是否完全相等。也是遍历比较的方式。 equalsIgnoreCase1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public boolean equalsIgnoreCase(String anotherString) &#123; return (this == anotherString) ? true : (anotherString != null) &amp;&amp; (anotherString.value.length == value.length) &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length);&#125;public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) &#123; char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1. if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) &#123; return false; &#125; while (len-- &gt; 0) &#123; char c1 = ta[to++]; char c2 = pa[po++]; if (c1 == c2) &#123;//两个都一样继续 continue; &#125; if (ignoreCase) &#123; // If characters don&apos;t match but case may be ignored, // try converting both characters to uppercase. // If the results match, then the comparison scan should // continue. char u1 = Character.toUpperCase(c1);// 开启了大小写忽略，两个字符不一样会进行比较 char u2 = Character.toUpperCase(c2); if (u1 == u2) &#123; continue; &#125; // Unfortunately, conversion to uppercase does not work properly // for the Georgian alphabet, which has strange rules about case // conversion. So we need to make one last check before // exiting. if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123; continue;// 好像是为了重新验证（last check before exiting）一下，转为小写是不是能走到这个分支。 &#125; &#125; return false;//出现不匹配就false &#125; return true;&#125; 比较并忽略大小写。返回的是一个三元表达式，比较的两个字符串是同一个对象会返回true，否则则要判断两者的内容了，对象不能是null，长度要相等，并且每一个字符还要匹配（regionMatches）。 startsWith123456789101112131415161718192021public boolean startsWith(String prefix, int toffset) &#123;// 字符串prefix用于查找 char ta[] = value;//原字符串的字符数组 int to = toffset; char pa[] = prefix.value;开始的字符串的字符数组 int po = 0;//从索引0开始比较 int pc = prefix.value.length;//字符串prefix长度 // Note: toffset might be near -1&gt;&gt;&gt;1. if ((toffset &lt; 0) || (toffset &gt; value.length - pc)) &#123; return false; &#125; while (--pc &gt;= 0) &#123;// 逐位比较 if (ta[to++] != pa[po++]) &#123; return false; &#125; &#125; return true;&#125;public boolean startsWith(String prefix) &#123;// 是不是某个字符串开头 return startsWith(prefix, 0);&#125; endsWith1234public boolean endsWith(String suffix) &#123;// 调用的还是startsWith的那个方法 return startsWith(suffix, value.length - suffix.value.length);&#125; hashCode123456789101112public int hashCode() &#123; int h = hash;// 默认的hash是0 if (h == 0 &amp;&amp; value.length &gt; 0) &#123;//初始的hash并且str是有值的 char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123;// 计算hash值 h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 将hash的字符串的char数组逐个遍历hash = 31 * hash + val[i]，就实现了hash的计算。 indexOf12345678910111213141516171819202122232425262728293031323334353637383940414243public int indexOf(int ch) &#123;//调用下面的方法 return indexOf(ch, 0);&#125;public int indexOf(int ch, int fromIndex) &#123; final int max = value.length;//最长遍历长度 if (fromIndex &lt; 0) &#123;// 范围不对的fromIndex会被默认为0或者不存在 fromIndex = 0; &#125; else if (fromIndex &gt;= max) &#123; // Note: fromIndex might be near -1&gt;&gt;&gt;1. return -1; &#125; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123;// 0x010000即65535，也就是有效输入 // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value;//从前往后找到第一个相同char的下标 for (int i = fromIndex; i &lt; max; i++) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1;//找不到就返回-1 &#125; else &#123; return indexOfSupplementary(ch, fromIndex); &#125;&#125;// Handles (rare) calls of indexOf with a supplementary(追加的) characterprivate int indexOfSupplementary(int ch, int fromIndex) &#123; if (Character.isValidCodePoint(ch)) &#123; final char[] value = this.value; final char hi = Character.highSurrogate(ch); final char lo = Character.lowSurrogate(ch); final int max = value.length - 1; for (int i = fromIndex; i &lt; max; i++) &#123; if (value[i] == hi &amp;&amp; value[i + 1] == lo) &#123; return i; &#125; &#125; &#125; return -1;&#125; lastIndexOf1234567891011121314151617181920212223242526272829303132333435public int lastIndexOf(int ch) &#123; return lastIndexOf(ch, value.length - 1);&#125;public int lastIndexOf(int ch, int fromIndex) &#123; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; int i = Math.min(fromIndex, value.length - 1);//等于遍历时从大到小，从后遍历到前面 for (; i &gt;= 0; i--) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return lastIndexOfSupplementary(ch, fromIndex); &#125;&#125;private int lastIndexOfSupplementary(int ch, int fromIndex) &#123; if (Character.isValidCodePoint(ch)) &#123; final char[] value = this.value; char hi = Character.highSurrogate(ch); char lo = Character.lowSurrogate(ch); int i = Math.min(fromIndex, value.length - 2); for (; i &gt;= 0; i--) &#123; if (value[i] == hi &amp;&amp; value[i + 1] == lo) &#123; return i; &#125; &#125; &#125; return -1;&#125; lastIndexOf与IndexOf的实现基本上差不多，lastIndexOf的实现就是从后往前找到第一个匹配的并返回索引。两者的差别就是遍历，一个从零往后++,另一个从后往前从length往前–。 重载indexOf方法，传入一个字符串对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public int indexOf(String str) &#123; return indexOf(str, 0);&#125;public int indexOf(String str, int fromIndex) &#123; return indexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex);&#125;static int indexOf(char[] source, int sourceOffset, int sourceCount, String target, int fromIndex) &#123; return indexOf(source, sourceOffset, sourceCount, target.value, 0, target.value.length, fromIndex);&#125;// 传入一个字符串，到了这里，参数的意义分别是source是原string的字符数组，sourceOffset，sourceCount是这个字符数组从0到str的总长度// target是查找的数组的字符数组，targetOffset，targetCount是它从0到总长度，fromIndex是查找的起始的位置。static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; // 排除特殊值 if (fromIndex &gt;= sourceCount) &#123; return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount);//执行循环的次数 for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first);//一直找到两个str首字符相同再比较 &#125; /* Found first character, now look at the rest of v2 */ if (i &lt;= max) &#123;//i要是&gt;max查找的str的长度肯定就比i后面的str部分长，没有必要比较了 int j = i + 1; int end = j + targetCount - 1; // 两个str要是不相等中途就break了，j的长度&lt;end for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); //j的长度&lt;end，进不了这个判断的分支 if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public int lastIndexOf(String str) &#123; return lastIndexOf(str, value.length);&#125;public int lastIndexOf(String str, int fromIndex) &#123; return lastIndexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex);&#125;static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, String target, int fromIndex) &#123; return lastIndexOf(source, sourceOffset, sourceCount, target.value, 0, target.value.length, fromIndex);&#125;static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; /* * Check arguments; return immediately where possible. For * consistency, don&apos;t check for null str. */ int rightIndex = sourceCount - targetCount; if (fromIndex &lt; 0) &#123; return -1; &#125; if (fromIndex &gt; rightIndex) &#123; fromIndex = rightIndex; &#125; /* Empty string always matches. */ if (targetCount == 0) &#123; return fromIndex; &#125; int strLastIndex = targetOffset + targetCount - 1; char strLastChar = target[strLastIndex]; int min = sourceOffset + targetCount - 1; int i = min + fromIndex;startSearchForLastChar:// 这个语法用于循环的跳转，类似于goto while (true) &#123; while (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123; i--; &#125; if (i &lt; min) &#123; return -1; &#125; int j = i - 1; int start = j - (targetCount - 1); int k = strLastIndex - 1; while (j &gt; start) &#123; if (source[j--] != target[k--]) &#123; i--; continue startSearchForLastChar; &#125; &#125; return start - sourceOffset + 1; &#125;&#125; last的实现也是类似于从右到左的实现了indexOf。 看了这么多的方法，可以得到一个结论，String在底层的实现都是字符数组的操作。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类型源码解析（一）]]></title>
    <url>%2F2018%2F06%2F03%2FJava-String%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[要讲Java的String类型，我们需要结合他的代码来看，根据源码的解读可以更好的理解Java底层实现的具体细节，所以这次的博客篇幅会比较的长，所以我会分成几个部分来写，希望通过源码的解读，学习到优秀的Java代码该如何实现。 本篇博客介绍String类的基本属性和众多的构造器，构造器的重载，体现出Java的多态性。 java.lang.String简介1.8版本String12* Copyright (c) 1994, 2013, Oracle and/or its affiliates. All rights reserved.* ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. String包声明在java.lang下。1package java.lang; String包简介：123456789* @author Lee Boynton//作者们* @author Arthur van Hoff* @author Martin Buchholz* @author Ulf Zibis* @see java.lang.Object#toString()// 另请参阅* @see java.lang.StringBuffer* @see java.lang.StringBuilder* @see java.nio.charset.Charset* @since JDK1.0//版本号 String类声明属性String类声明1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;&#125; final表示String类是不可被继承的，String实现了Serializable（可序列化）接口，Comparable（可比较）接口，CharSequence（字符序列）接口。 value属性12/** The value is used for character storage. */private final char value[]; The value is used for character storage.就是说这个声明的value数组用于存储字符，这个value非常的重要，String的底层实现都靠它来是实现。 并且声明的char类型的value数组使用final修饰，说明底层存储String对象是将String中的每一个字符存放到一个不可变的char类型的数组中。 hash属性12/** Cache the hash code for the string */private int hash; // Default to 0 默认缓存一个String的hash值，空列表（空字符串）的hash值默认是成员变量的初始默认值，这里是int类型，所以是0. serialVersionUID属性12/** use serialVersionUID from JDK 1.0.2 for interoperability */private static final long serialVersionUID = -6849794470754667710L; 定义了一个静态的serialVersionUID常量。作为IO时对象存入文件时使用。 String构造器们无参构造器12345678/** * Initializes a newly created &#123;@code String&#125; object so that it represents * an empty character sequence. Note that use of this constructor is * unnecessary since Strings are immutable. */public String() &#123; this.value = &quot;&quot;.value;&#125; 第一个构造器：无参构造器使用String的无参构造器生成的对象默认是一个空字符串。我们可以使用代码验证一下。123456class Test&#123; public static void main(String[] args)&#123; System.out.println(new String());// 调用字符串的无参构造器，会生成一个空字符串对象 System.out.println(1+new String()+2);//12 这里生成的是一个字符串拼接的结果 &#125;&#125; 传入String对象构造器1234567891011121314/** * Initializes a newly created &#123;@code String&#125; object so that it represents * the same sequence of characters as the argument; in other words, the * newly created string is a copy of the argument string. Unless an * explicit(明确的) copy of &#123;@code original&#125; is needed, use of this constructor is * unnecessary since Strings are immutable(不可变的). * * @param original * A &#123;@code String&#125; */public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; 第二个构造器：传入String对象String的有参构造器中可以传入一个字符串类型的对象，此构造器初始化字符串类型的value数组与hash值。in other words, the newly created string is a copy of the argument string.意思是换句话说，新创建的字符串复制了参数的字符串。 传入字符数组构造器123456789101112/** * Allocates a new &#123;@code String&#125; so that it represents the sequence of * characters currently contained in the character array argument. The * contents of the character array are copied; subsequent modification of * the character array does not affect the newly created string. * * @param value * The initial value of the string */public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125; 第三个构造器：传入一个字符数组很明显你还可以传入一个字符数组，当然你得到的还是一个新的字符串，字符数组的值赋给了String的value数组了。12345class Test&#123; public static void main(String[] args)&#123; System.out.println(new String(new char[]&#123;'j', 'e', 'f', 'f'&#125;));//jeff &#125;&#125; 传入下标字符数组构造器12345678910111213141516171819public String(char value[], int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= value.length) &#123; this.value = &quot;&quot;.value;//count=0，返回一个空串 return; &#125; &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; value.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125;//offset+count&gt;len,此时会报错 this.value = Arrays.copyOfRange(value, offset, offset+count);&#125; 第四个构造器：传入一个字符数组的起始下标与传入的个数。这种传入街截取下表索引的方式，一般的判断方式是：判断这两者都不能小于0，count=0则返回一个空串。offset+count超过总长也会报错。1234567class Test&#123; public static void main(String[] args)&#123; System.out.println(new String(new char[]&#123;'j', 'e', 'f', 'f', 'l', 'i', 'k', 'e'&#125;, 4, 4));//like System.out.println(new String(new char[]&#123;'j', 'e', 'f', 'f', 'l', 'i', 'k', 'e'&#125;, 4, 0));//还是一个空串 // System.out.println(new String(new char[]&#123;'j', 'e', 'f', 'f', 'l', 'i', 'k', 'e'&#125;, 4, 5));//java.lang.StringIndexOutOfBoundsException: String index out of range: 9 &#125;&#125; 传入Unicode数组的构造器1234567891011121314151617181920212223242526272829303132333435363738394041424344public String(int[] codePoints, int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= codePoints.length) &#123; this.value = &quot;&quot;.value; return; &#125; &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; codePoints.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; final int end = offset + count; // 到这里end的值已经不可能大于这个传入数组的总长了，上面进行了一系列的判断已经排除超出总长的可能性了 // Pass 1: Compute precise size of char[] int n = count; for (int i = offset; i &lt; end; i++) &#123;//遍历codePoints int c = codePoints[i]; if (Character.isBmpCodePoint(c))//Determines whether the specified character，这个功能貌似是判断这个字符是不是一个specified的字符 continue; else if (Character.isValidCodePoint(c))//whether the specified code point is a valid，这个字符是不是合法 n++; else throw new IllegalArgumentException(Integer.toString(c)); &#125; // Pass 2: Allocate and fill in char[] 填充这个char[] final char[] v = new char[n]; for (int i = offset, j = 0; i &lt; end; i++, j++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) v[j] = (char)c; else Character.toSurrogates(c, v, j++);//c是当前遍历到的字符，v是当前数组里所有的数值组成的数组，这个方法类似于将超长的非法的字符，转换成一个可以存储的字符 &#125; this.value = v;//将字符存到数组中，用于生成新的字符串&#125; 第五个构造器：参数int[] codePoints，Array that is the source of Unicode code points。传入的构造器实参可以是一个Unicode的数组。 1System.out.println(new String(new char[]&#123;&apos;\u4e01&apos;, &apos;\u6607&apos;&#125;, 0, 1));//丁 废弃了的构造器12345678910111213141516171819202122@Deprecatedpublic String(byte ascii[], int hibyte, int offset, int count) &#123; checkBounds(ascii, offset, count); char value[] = new char[count]; if (hibyte == 0) &#123; for (int i = count; i-- &gt; 0;) &#123; value[i] = (char)(ascii[i + offset] &amp; 0xff); &#125; &#125; else &#123; hibyte &lt;&lt;= 8; for (int i = count; i-- &gt; 0;) &#123; value[i] = (char)(hibyte | (ascii[i + offset] &amp; 0xff)); &#125; &#125; this.value = value;&#125;@Deprecatedpublic String(byte ascii[], int hibyte) &#123; this(ascii, hibyte, 0, ascii.length);&#125; 这两个构造器被声明为过时的希望不被再使用了。 传入字节数组及索引的构造器1234567891011121314151617public String(byte bytes[], int offset, int length, String charsetName)//传入字符编码charset throws UnsupportedEncodingException &#123; if (charsetName == null)// 还必须要传入一个charset throw new NullPointerException(&quot;charsetName&quot;); checkBounds(bytes, offset, length);//调用底下的检查，传入的数据是否合理 this.value = StringCoding.decode(charsetName, bytes, offset, length);&#125;// 判断传进来的参数与数组的关系private static void checkBounds(byte[] bytes, int offset, int length) &#123; if (length &lt; 0) throw new StringIndexOutOfBoundsException(length); if (offset &lt; 0) throw new StringIndexOutOfBoundsException(offset); if (offset &gt; bytes.length - length) throw new StringIndexOutOfBoundsException(offset + length);&#125; 第八个构造器：直接传进来一个byte的数组，起始和长度（类似于count）位置，最后还设置一个字符编码的格式。1234public String(byte bytes[], int offset, int length) &#123; checkBounds(bytes, offset, length); this.value = StringCoding.decode(bytes, offset, length);&#125; 传入参数不为null就调用的这个构造器。 传入字节数组的构造器1234public String(byte bytes[], String charsetName) throws UnsupportedEncodingException &#123; this(bytes, 0, bytes.length, charsetName);//调用上面的构造器&#125; 此构造器实际上就是调用了上面的构造器。并传入整个数组不进行切片。 1234 * @since 1.6public String(byte bytes[], Charset charset) &#123; this(bytes, 0, bytes.length, charset);&#125; 上面构造器1.6改写后的构造器，只是字符集条件不是String而是Charset类型。 接收StringBuffer作为参数的构造器12345public String(StringBuffer buffer) &#123; synchronized(buffer) &#123; this.value = Arrays.copyOf(buffer.getValue(), buffer.length()); &#125;&#125; 接收StringBuilder作为参数的构造器123public String(StringBuilder builder) &#123; this.value = Arrays.copyOf(builder.getValue(), builder.length());&#125; 结语： String类中有十几种构造器方法，构造器之间的重载，体现出Java的多态性。 构造器里可以传哪些东西：空参；String对象；字符数组；字符数组+offset+count；Unicode code points+offset+count；bytes数组+offset+count+charset；StringBuffer对象；StringBuilder对象。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java包装类]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[包装类的由来Java发明时正遇上C语言盛行的时候，因此Java保留/延续/借鉴了C语言中八种基本数据类型。但是Java是一门面向对象的语言，而八种基本数据类型不属于面向对象的范畴，但是基本数据类型有它的优势：（1）长度确定（2）计算效率高。所以Java还是选择保留了基本数据类型。所以Java和python不同的是，Java里并不是“一切皆对象”的。Java绝大部分的特性是为对象而设计的，例如：泛型，集合等，这些特性是不支持基本数据类型的。为了解决这样的矛盾，Java为八种基本数据类型设计了对应的包装类型。 基本数据类型与其对应的包装类 byte：Byte short：Short int：Integer long：Long float：Float double：Double char：Character boolean：Boolean 这些包装类型定义在java.lang包下，所以我们可以直接调用。 装箱与拆箱装箱就是把基本数据类型的数据装箱为包装类的对象。 Integer num = new Integer(int的变量或值);拆箱反过来把包装类型的对象，拆箱为基本数据类型的数据。 int m = Integer的对象.intValue(); JDK1.5之前，只能用刚才的形式进行手动装箱和手动拆箱。 JDK1.5之后，开始支持自动装箱与自动拆箱.JDK之前的手动装箱拆箱的操作：123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; //1、创建一个包装类的对象 Integer i = new Integer(12); //2、手动装箱操作 int a = 10; //需要把变量a的值存储到集合，或传给引用数据类型的形参时，那么就需要把a变成包装类对象 Integer num = new Integer(a); //3、手动拆箱操作 Integer n1 = new Integer(10); Integer n2 = new Integer(20); //例如：求和，对象不能直接相加,拆箱成基本数据类型 int m1 = n1.intValue(); int m2 = n2.intValue(); System.out.println(m1 + m2); &#125;&#125; JDK1.5之后，自动拆箱，装箱1234567891011121314151617public class TestWrapper &#123; public static void main(String[] args) &#123; //自动装箱，自动拆箱 int b = 10; Integer bNum = b;//自动装箱//等价于 Integer bNum = new Integer(b); Integer cNum = new Integer(23); int c = cNum;//自动拆箱//等价于 int c = cNum.intValue(); //5、演示错误 double d = 12;//整型的值是可以赋值给double型的变量，自动类型转换// Double dNUm = 12;//错误的 int类型的值和变量只能自动装箱为Integer// Double dNUm = 12.0F;//错误的，12.0F只能自动装箱为Float Double dNum = 12.0;//可以 &#125;&#125; 注意：装箱与拆箱的操作，只能与自己对应的基本数据类型和包装类进行。 数据类型转换字符串转成包装类对象各个包装类除了Character类型，其他7中类型都有1个构造方法，其参数是字符串类型。12Integer t2=new Integer(&quot;500&quot;);//参数是字符串，字符串的值是必须对应的数值Integer t3=new Integer(&quot;abc&quot;);// java.lang.NumberFormatException: For input string: &quot;abc&quot; 除此之外包装类的valueOf方法也可以做到。1Integer i=Integer.valueOf(&quot;500&quot;); 字符串转成基本数据类型通过包装类的parseXxx(String s)静态方法:123int i=Integer.parseInt(&quot;500&quot;);int i = Integer.valueOf(str1);//隐含了自动拆箱int j = new Integer(str1);//隐含了自动拆箱 缓存的常量对象在python中也存在着一个维持的小数池，对于-128到127的值，引用的是同一个对象，按道理说，每new一个包装类的对象，那他就会在堆中创建一个新的包装类对象，但是：123456789101112131415161718192021222324252627282930313233343536373839404142public class Main &#123; public static void main(String[] args) &#123; //1. 在堆中创建了两个Integer包装类对象，那么他们的地址肯定不同，比较一定是false Integer i1 = new Integer(1); Integer i2 = new Integer(1); System.out.println(i1 == i2);//false // 2.比较的是基本数据类型的大小，不是比较内存地址了，大小相等 int i3 = 128; int i4 = 128; System.out.println(i3 == i4);//true // 3. 不过是基本数据类型进行了自动装箱，本质上还是创建了两个包装类的对象，地址不同 Integer i5 = 128; Integer i6 = 128; System.out.println(i5 == i6);//false // 小于128的整型在方法区（暂且这么说）有一个常量池，都指向的是这个常量池对象，所以是同一个对象 int i7 = 1; int i8 = 1; System.out.println(i7 == i8);//true // 由于浮点数的存储机制不同，没有那么大的空间可以存常量，也不精确，所以覅浮点型是没有常量池的 Double d1 = 2.0; Double d2 = 2.0; System.out.println(d1 == d2);//false Boolean b1 = true; Boolean b2 = true; System.out.println(b1 == b2);//true Character c1 = 'a'; Character c2 = 'a'; System.out.println(c1 == c2);//true // 中文字符也是没有常量池的，字数太多了 Character c3 = '中'; Character c4 = '中'; System.out.println(c3 == c4);//false &#125;&#125; 包装类对象可能存储缓存的常量对象： Byte,Short,Integer,Long：-128~127 float，double：不缓存 Character：0~127 Boolean：true,false 附：包装类还提供了处理 类型时非常有用的其他一些常量：(1)Integer Integer.MAX_VALUE Integer.MIN_VALUE(2)Double Double.MAX_VALUE Double.MIN_VALUE等]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常处理]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常处理机制的目的是为了当程序发生异常时，使得程序不崩溃继续运行，同时通过提示用户等方式解决。 注意：语法错误不属于异常，这种情况编译不通过，无法运行；逻辑错误不属于异常，这种情况属于BUG，必须修正；异常本身是指不可预知的非正常的情况。在Java中异常也被封装成对象操作。不同的异常对象中封装了相应的错误信息。Java是采用面向对象的方式来处理异常的。 Java的异常处理机制的过程，原理：Java程序当某一句代码发生异常时，JVM会在该句代码的位置暂停下来，然后会根据异常的情况，创建一个相应的异常对象，这个对象会包含异常的类型、错误的信息等，并把异常对象提交给JRE。JVM会在这句代码的外围搜索有没有异常的处理的代码（例如：try…catch），如果有对应的catch可以捕获这个异常的对象，那么就相当于这个异常被处理了。程序继续从try..catch下面继续运行。如果没有对应的catch可以捕获它，那么当前代码的方法就会把这个异常对象，抛给上级（调用者），上级继续按照刚才的逻辑，先找是否有catch，如果有就捕获，从catch后继续运行，如果没有，继续往上级抛异常直到main都没有能够catch它，那么程序就崩溃了。 异常的超级父类异常的超级父类是java.lang.Throwable。Throwable类是Java语言中所有错误或异常的超类。只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。只有此类或其子类之一才可以是 catch 子句中的参数类型。 异常的分类Error重大错误：此类错误，不建议用try..catch等代码处理的，而是应该停下来，重新修正代码。 比较常见的有：VirtualMachineError(OutOfMemoryError堆内存溢出, StackOverflowError栈内存溢出) OOM错误12345678public class Main &#123; public static void main(String[] args) &#123; // 创建一个内存特别大的数组，此时数组所占内存的长度就大于内存会报超出内存的错误 // Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit int[] arr = new int[Integer.MAX_VALUE]; &#125;&#125; 栈溢出错误123456789101112public class Main &#123; public static void main(String[] args) &#123; // Exception in thread "main" java.lang.StackOverflowError test(); &#125; public static void test()&#123; test(); &#125;&#125; Exception异常，它指出了合理的应用程序想要捕获的条件。 异常也分为两种： (1) 受检异常，也称为编译时异常 即在编译时必须throws或者try..catch处理，否则编译不通过。 (2) 非受检异常，也称为运行时异常 编译时不提示，运行过程中可能发生的异常，例如：NullPointerException、ArrayIndexOutOfBoundsException，ClassCastException等。 异常处理异常处理的两个动作：抓（try…catch），抛（throws）。 try…catch1234567891011try&#123; 可能发生异常的代码&#125;catch(异常的类型1 异常名e)&#123; 抓住该异常后处理的代码&#125;catch(异常的类型2 异常名e)&#123; 抓住该异常后处理的代码&#125; ...finally&#123; 无论是否发生异常，都要执行的代码&#125; (1) 如果try中没有异常，那么catch中的不会执行; (2) 如果try中有异常，在发生异常的那句代码停下来，JVM会自动new一个异常的对象，抛出来，从上到下找对应的catch，如果类型匹配，就进入到catch中，如果所有catch的类都不匹配，就相当于没有抓住异常，默认抛出上一级。其中catch的关系应该是一层大于一层的，否则父类在前，子类在后，那么父类总会把子类的异常处理掉，那么默认子类异常毫无意义。 (3) finally块中的代码是不管try中是否发生异常，而且不管异常是否被catch，都要执行的代码。 注意：当异常处理的代码执行结束以后，是不会回到try语句块去执行尚未执行的代码的。只会执行try…catch…finally后面的代码。 关于finally不论什么情况都会在最后执行，相关练习：练习1：1234567891011121314151617181920212223242526public class Test&#123; public static void main(String[] args) &#123; int result = test(4,2); System.out.println(result); &#125; public static int test(int a, int b)&#123; int result = 0; try&#123; if(a&lt;0 || b&lt;0)&#123; result = -1; return result; &#125; result = a/b; return result; &#125;catch(Exception e)&#123; result = a + b; return result; &#125;finally&#123; result ++; return result;// 3 &#125; &#125;&#125; 一般函数在return后就结束了，但是在这里即使try中没有发生异常，并且执行到return，但是依然要执行完finally的内容才可以return，reuturn的是finally返回的result值。 1234567891011121314151617181920212223242526public class Test&#123; public static void main(String[] args) &#123; int result = test(4,0); System.out.println(result); &#125; public static int test(int a, int b)&#123; int result = 0; try&#123; if(a&lt;0 || b&lt;0)&#123; result = -1; return result; &#125; result = a/b; return result; &#125;catch(Exception e)&#123; result = a + b; return result; &#125;finally&#123; result ++; return result;// 5 &#125; &#125;&#125; 同理，在catch中有return但是实际的return的结果还是会返回finally的result结果。 123456789101112131415161718192021222324public class Test&#123; public static void main(String[] args) &#123; int result = test(4,0); System.out.println(result); &#125; public static int test(int a, int b)&#123; int result = 0; try&#123; if(a&lt;0 || b&lt;0)&#123; result = -1; return result; &#125; result = a/b; return result; &#125;catch(Exception e)&#123; result = a + b; return result; &#125;finally&#123; result ++; &#125; &#125;&#125; 如果finally中没有return的值，那么返回的result要看有没有异常被捕获了。即使如此finnaly的值还是被执行了的，只是在执行++之前，return的值已经在catch中返回了catch中的result的值了。 throws与try…catch不同，try…catch相当于捕获到异常自己就处理了，类比一些编程学习人员，遇到问题自己就解决了。而throws则是发现问题即时上报，相应的一部分人在学习编程时，只要一遇到任何问题，第一时间就抛出问题，不假思索的在学习群，社区或是论坛发出问题。一般的底层的也就是小白可以拥有throws的权利，但是到了最上层的大佬（main）他必须要使用try…catch方法解决问题。大佬也解决不了的问题，那一定是大问题，系统就崩了。 throws的语法12345【修饰符】 abstract 返回值类型 方法名（【形参列表】）【throws 异常列表】;【修饰符】 返回值类型 方法名（【形参列表】）【throws 异常列表】&#123; 方法体&#125; 其中RuntimeException及其子类可以不写【throws 异常列表】。其他类需要写【throws 异常列表】，异常列表可以是多个，顺序没有影响。 注意：在方法重写的时候，子类的重写的方法throws异常的类型 &lt;= 父类被重写的方法throws的异常类型。123456789101112class Father&#123; public void test()throws Exception&#123; &#125;&#125;class Son extends Father&#123; @Override public void test() throws RuntimeException &#123; &#125; &#125; 如果子类的异常类型大于父类的异常类型，那么子类可能会抛出一个异常，这个异常的类型大于父类的异常的类型，父类则无法接受此异常，就是类型转换异常了。 throw除了jvm会抛异常以外，程序员也可以在代码中手动抛异常。抛异常的工具就是throw。123456789101112131415161718192021222324public class TestThrow &#123; public static void main(String[] args) &#123; try &#123; Scanner input = new Scanner(System.in); System.out.println("请输入被除数："); int a = input.nextInt(); System.out.println("请输入除数："); int b = input.nextInt(); if(b==0)&#123; throw new Exception("除数不能为0"); &#125; &#125; catch (Exception e) &#123;// e.printStackTrace();//标准的异常信息打印形式，包含异常类型、异常的错误信息，堆栈跟踪信息等，底层其实用的是System.err打印 System.out.println(e);//把异常对象当做普通对象打印，只包含异常类型、异常的错误信息。 System.err.println(e);//把异常对象红色打印，包含异常的类型和错误信息 System.out.println(e.getMessage()); // System.out和System.err两个线程负责的，因此谁先出来，不一定。 &#125; &#125;&#125; 自定义ExceptionJava核心类库中无法涵盖所有的异常情况。某些异常情况，我也想要通过类型去说明问题，那么这个时候就可以自定义异常。 （1）必须继承Throwable或它的子类，我们写的一般是继承Exception或RuntimeException比较多。 （2）一般自定义异常需要实现java.io.Serializble接口（IO用），因为异常对象可能被记录日志中。 （3）自定义异常类型保留两个构造器：无参构造，另一个是为父类的message赋值的构造器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TestException &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println("用户名："); String user = input.next(); System.out.println("密码："); String pwd = input.next(); try &#123; boolean flag = login(user,pwd); System.out.println("登录成功"); &#125; catch (Exception e) &#123; System.out.println("登录失败，原因是：" + e.getMessage()); &#125; &#125; public static boolean login(String user, String pwd) throws Exception &#123; if ("jefflike".equals(user) &amp;&amp; "123".equals(pwd)) &#123; return true; &#125; else &#123; //用户名不存在，用户名和密码错误，服务器的问题等// return false; //用throw语句代替return 语句 if(!"jefflike".equals(user))&#123; throw new UsernameNotExistException("用户名不存在"); &#125;else&#123; throw new UsernameOrPasswordErrorException("用户名或密码错误"); &#125; &#125; &#125;&#125;class UsernameNotExistException extends Exception &#123; public UsernameNotExistException() &#123; super(); &#125; public UsernameNotExistException(String message) &#123; super(message); &#125; &#125;class UsernameOrPasswordErrorException extends Exception &#123; public UsernameOrPasswordErrorException() &#123; super(); &#125; public UsernameOrPasswordErrorException(String message) &#123; super(message); &#125;&#125; 注意： 要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下。 不要进行小粒度的异常处理——应该将整个任务包装在一个try语句块中。 异常往往在高层处理。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解]]></title>
    <url>%2F2018%2F05%2F29%2FJava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[上一篇博客提到了Java的枚举类型，Java的枚举类型从本质上实现是Java的类，所以可以看作是一个特殊的Java类。本篇博客要说的是Java里的注解（Annotation），此处说的注解与我们之前所说的单行注释，多行注释不是一类对象，单行注释，多行注释是编程人员将代码结构进行注释方便日后代码维护所添加的对机器无用的代码块，而Annotation会在代码中起到非常重要的作用，同时它可以被其他的程序读取，下面我们来详细的介绍。 注解三要素 声明（一般是框架或者核心类库等声明了注解，我们自己也可以自定义声明注解）； 使用注解（在程序的相应位置，按照一定的格式声明注解）； 读取注解（读取注解的程序一般声明注解的人写好的，我们不需要重复操作）。最基本的三个注解一、 @Override 声明：系统预定义的，JRE核心类库已经声明好了。在java.lang.Override中； 使用：在重写的方法上加注解，表示这个方法是重写的方法，并且检查重写的格式是否正确； 读取它：javac.exe读取它。 作用：编译时会对这个方法进行格式检查，看这个方法是否复合重写的要求。 二、@SuppressWarnings 声明：系统预定义的，JRE核心类库已经声明好了。在java.lang.SuppressWarnings中； 使用：在相应位置表示抑制xx警告； 读取：javac.exe读取它。 三、@Deprecated 声明：系统预定义的，JRE核心类库已经声明好了。在java.lang.Deprecated中； 使用：在相应位置使用，表示这个类、方法、属性（看使用的位置在哪）已经过时了，不再建议程序员使用它，以弹出警告的方式告知程序员这个xx已经过时了。 读取：javac.exe读取它。 注意：已过时的一般来说，就是设计有问题，或者有重大bug，不建议程序员使用的。 文档注解 声明：JRE核心类库已经声明好了。 使用：通用：123456/** * @author 作者 * @see 另请参阅 * @since 从xx版本开始 * @version 当前版本*/ 方法上：12345678910/** * 这是一个求两个整数的商的方法 * @param a int 被除数 * @param b int 除数 * @return int 返回a/b的商，只保留整数部分 * @throws ArithmeticException 当b=0时，会报算术异常 */public static int divide(int a, int b)throws ArithmeticException&#123; return a/b;&#125; 读取：javadoc.exe读取。 跟踪代码依赖性，替代原来.xml配置文件跟踪代码依赖性，实现替代配置文件功能，类似flask装饰器指向路由的使用，后续框架部分详细介绍。 JUnit框架的注解注意：使用JUnit测试的类必须是public的。JUnit4常见的注解和要求：这些方法都必须是public，无参，无返回值。 @Test 声明：不是JRE提供的，而是有JUnit框架提供的； 使用：使用的方法必须是公共的、无参、void、非静态的；12@Test(timeout=1000)：设置超时时间，如果测试时间超过了你定义的timeout，测试失败 @Test(expected)： 申明出会发生的异常，比如 @Test（expected = Exception.class） @BeforeClass 标记在静态方法上。因为这个方法只执行一次。在类初始化时执行。 @AfterClass 标记在静态方法上。因为这个方法只执行一次。在所有方法完成后执行。 @Before 标记在非静态方法上。在@Test方法前面执行，而且是在每一个@Test方法前面都执行。 @After 标记在非静态方法上。在@Test方法后面执行，而且是在每一个@Test方法后面都执行。 @Ignore 标记在本次不参与测试的方法上。这个注解的含义就是“某些方法尚未完成，暂不参与此次测试”。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class TestJUnit &#123; @Test public void test()&#123; System.out.println("helloworld"); &#125; @Test public void method()&#123; int sum = 0; for (int i = 1; i &lt;= 10; i++) &#123; sum += i; &#125; System.out.println("sum = " + sum); &#125; @BeforeClass public static void bc()&#123; System.out.println("在所有测试方法之前运行，而且一个类只运行一次"); &#125; @AfterClass public static void ac()&#123; System.out.println("在所有测试方法之后运行，而且一个类只运行一次"); &#125; @Before public void b()&#123; System.out.println("每一个测试方法之前运行"); &#125; @After public void a()&#123; System.out.println("每一个测试方法之后运行"); &#125; @Ignore public static void c()&#123; System.out.println("不参与测试"); &#125;&#125;public class TestTest &#123; public static void main(String[] args) &#123; TestJUnit t = new TestJUnit(); t.test(); &#125;&#125; 自定义注解注解三步走，声明，使用，读取，生成一个我们自己的注解也需要编写这三部分。 声明：12【修饰符】 @interface 注解名&#123;&#125; 元注解 给注解加的注解叫元注解，简称为注解的注解。用来注解我们自定义的注解的一些基本信息的。一共有四个。 @Target：目标位置，用来指明某个注解将来可以加在哪些位置。这个目标位置存放在ElementType枚举类型的常量对象中。 123456789101112131415161718192021222324252627282930313233343536373839public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE&#125; 注意：TYPE（类型上，例如：类、接口等），FIELD（属性上），METHOD（方法上）等。 @Retention：生命周期，用来指明某个注解被使用后，可以保留到什么阶段。三个阶段：RetentionPolicy枚举类型的三个常量对象：SOURCE：源代码阶段 –&gt; CLASS：字节码阶段–&gt;RUNTIME：运行时阶段(只有这个阶段的注解，才能被反射代码读取到). 123* 源代码 ---&gt;.class --&gt;Class ---&gt; 运行时* SOURCE CLASS RUNTIME* javac.exe 类加载器 反射 @Inherited：该注解是否可以被子类继承。 @Documented：该注解是否可以被javadoc.exe文档读取到API中。默认情况下,javadoc是不包括注解的，但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理。1234567891011121314151617181920212223public class TestDefineAnnotation &#123; public static void main(String[] args) &#123; //读取一个注解，我们自定义注解只能在运行时读取它，读取注解需要用到反射 Class&lt;MyClass&gt; clazz = MyClass.class; MyAnnotation my = clazz.getAnnotation(MyAnnotation.class); System.out.println(my); &#125;&#125;//使用一个注解@MyAnnotationclass MyClass&#123; @MyAnnotation public void test()&#123; &#125;&#125;//自定义注解，声明一个注解@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation&#123; &#125; 注解的配置参数在注解中往往还需要传入参数。声明：123【修饰符】 @interface 注解名&#123; 数据类型 配置参数名() 【default 默认值】;&#125; 赋值: （1）如果一个注解声明了配置参数，而且没有默认值，那么在使用注解时必须手动给它赋值,赋值的标准格式：( 参数名 = 参数值); （2）如果一个注解它的配置参数只有一个，而且参数名是value，那么可以在赋值的时候省略value=; （3）配置参数的类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组. 12345678910111213141516171819202122232425262728293031323334353637import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;class TestDefineAnnotation2 &#123; public static void main(String[] args) &#123; //3、读取注解 Class&lt;YourClass&gt; c = YourClass.class; YourAnnotation y = c.getAnnotation(YourAnnotation.class); String value = y.value(); System.out.println(value); Class&lt;OtherClass&gt; c2 = OtherClass.class; YourAnnotation y2 = c2.getAnnotation(YourAnnotation.class); String value2 = y2.value(); System.out.println(value2); &#125;&#125;//2、使用@YourAnnotation("dingjie")class YourClass&#123;&#125;//这里因为@YourAnnotation的配置参数有默认值，可以不赋值@YourAnnotationclass OtherClass&#123;&#125;//1、声明@Retention(RetentionPolicy.RUNTIME)@interface YourAnnotation&#123; String value() default "jefflike";&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名内部类和局部内部类扩展]]></title>
    <url>%2F2018%2F05%2F28%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AA%E8%83%BD%E8%AE%BF%E9%97%AEfinal%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[为什么匿名内部类和局部内部类只能访问final变量前面我们提到了Java里的内部类，也提到了关于局部内部类与匿名类，可以访问到所在方法的局部常量，并且在JDK8.0版本以后，即使你在方法中并没有声明变量为final，默认编译的时候也是final类型的，即你不可以改变此方法中被局部内部类引用了的变量（就是变量）。在这里就简单的说一说为什么Java会这样设定。 局部内部类或匿名内部类的对象可以被外部方法作为返回值，返回到方法外使用，那么如果这样的话，就会出现矛盾。12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; Change c = method(); //这里method()已经结束，按理说局部a早就失效，那么下面调用change()，打印出a的值就矛盾了，即change()访问了一个不存在的变量，这是不允许的。 c.change(); &#125; public static Change method()&#123; int a = 10; class Inner implements Change&#123; public void change()&#123; System.out.println("a="+a); &#125; &#125; Change in = new Inner(); return in; &#125;&#125;interface Change&#123; void change();&#125; 如果说这里的a是一个变量，那么这里就已经产生矛盾了。 要理解这一点，我们需要知道局部内部类和匿名内部类访问局部变量的机制。 在java中，类是封装的，内部类也不例外。我们知道，非静态内部类能够访问外部类成员是因为它持有外部类对象的引用 Outer.this，就像子类对象能够访问父类成员是持有父类对象引用super一样。局部内部类也和一般内部类一样，只持有了Outer.this，能够访问外部类成员，但是它又是如何访问到局部变量的呢？ 实际上java是将局部变量作为参数传给了局部内部类的构造函数，而将其作为内部类的成员属性封装在了类中。我们看到的内部类访问局。部变量实际上只是访问了自己的成员属性而已，这和类的封装性是一致的。那么上面的代码实际上是这样：12345678910111213141516171819202122232425262728293031public class TestInner &#123; public static void main(String[] args) &#123; Change c = method(); c.change(); //change()访问的就不是method()的局部变量a， //而是Inner内部类的成员变量a，只是它的值是method()的局部变量a的副本 &#125; public static Change method()&#123; int a = 10; class Inner implements Change&#123; //实际上内部做了这样的操作，内部类的a只是方法中的copy，是内部类的私有变量，所以自己可以访问得到 private int a; Inner(int a)&#123; this.a =a; &#125; public void change()&#123; // 调用的也是内部私有变量a，copy的a不是方法里面的变量a System.out.println("a=" + this.a); &#125; &#125; Change in = new Inner(a);//a=10 return in; &#125;&#125;interface Change&#123; void change();&#125; 所以，方法里的a改不改，和我内部类里面的a实际上没有关系。 那么，如果java不做这个自动添加final特性，而是将这两种a认作是两个变量（常量），那么我们的代码是这样的：1234567891011121314151617181920212223public class TestInner &#123; public static void main(String[] args) &#123; Change c = method(); &#125; public static Change method()&#123; int a = 10; class Inner implements Change&#123; public void change()&#123; a = 20; //如果这里可以修改a的值 System.out.println("a=" + a);//20 &#125; &#125; Change in = new Inner(); in.change(); System.out.println(“a=”+a);//从阅读角度，这里预期打印a=20，然而只会打印出a=10，会让人误解，因为在Inner的change()中修改的是Inner内部类对象的this.a，它是method的局部变量a的副本 return in; &#125;&#125;interface Change&#123; void change();&#125; 一眼看下去，我们一定认为，内部类引用了方法里的a，这样代码的可读性太差了。 结论为了保证阅读与运行的一致性，只能规定局部变量a（和副本a）不能修改，这样阅读和运行就可保持一致。那么就只能限定a为final，即定义为常量。当然，不是常量，声明周期也结束了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类]]></title>
    <url>%2F2018%2F05%2F26%2FJava%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java类的成员分为五类：属性，方法，构造器，代码块，和内部类。 为什么使用内部类首先类指的是：具有相同特性的事物抽象出的一类抽象概念，而接口则是具有某种相同功能的事物的抽象出的概念。但是事物与事物之间的关系除了什么是什么的关系，还存在着什么有什么的关系，在python中是以组合的概念描述，在Java里，我们一般使用内部类的来表示，什么有什么的这种关系。当然Java的面向对象也是有组合概念的，内部类不只是表达组合关系，而且在内部类中可以使用外部类的属性与方法。比如说，一个人的类，他有很多的器官，人的器官要使用人的血液，组织液等属性。人的器官使用人的心跳供血等方法，那么你可能会想，那么我们把器官抽象成一个属性，然后在外部类中给他创建方法不就可以使用器官类了吗。但是在实际的环境中，器官也可能是是一类抽象出来的类，它也是一个十分复杂的抽象概念，他是有细胞，组织等属性方法的类，不是一个外部类属性可以用一两个属性就能概括出来的概念。这时候我们需要使用到Java的内部类来描述器官这个抽象概念。 内部类特征 在一个类内部存在着一个独立的另一类事物，他也有自己的数据描述，行为特征，那么我们使用内部类来描述这个内部独立类事物； 内部类只为外部类服务，单独存在没有意义，而且可以访问到外部类的私有属性方法等，为外部类服务。内部类的分类 成员内部类（类中方法外） 静态成员内部类 非静态成员内部类 局部内部类（方法体{},方法形参(),代码块{}中） 局部内部类 匿名内部类 静态成员内部类声明1234外部类&#123; [修饰符] static class 静态内部类名 [extends 父类名] [implements 接口名]&#123; &#125;&#125; 权限修饰符private，缺省，protected，public，static，abstract，final。注意：修饰方法的时候，abstract与static不可以一起使用。（static不让继承，abstract必须继承的矛盾） 成员属性，方法，构造器，代码块，内部类 使用1.静态内部类使用外部类的成员123456789101112131415class Outer&#123; private String outField = "外部类非静态属性"; private static String outStaticField = "外部类静态属性"; static class Inner&#123; public void testIn()&#123; //System.out.println("outField=" + outField);//无法使用非静态的属性，Non-static field 'outField' cannot be referenced from a static context System.out.println("outStaticField=" + outStaticField); &#125; public static void methodIn()&#123; System.out.println("内部类的静态方法"); &#125; &#125;&#125; 通过上面一段代码，我们可以类比的出，在内部静态类中使用外部类的属性时，只可以使用外部类的静态属性，方法与代码块。（静态只能访问静态，此时非静态还未生成） 2.外部类中使用静态内部类的成员1234567891011121314151617181920212223242526272829class Outer&#123; private String outField = "外部类非静态属性"; private static String outStaticField = "外部类静态属性"; static class Inner&#123; public void testIn()&#123; System.out.println("outStaticField=" + outStaticField); &#125; public static void methodIn()&#123; System.out.println("内部类的静态方法"); &#125; &#125; // 2.在外部类中使用内部类的属性与方法 public void OutUseInt()&#123; //1. 使用内部类的静态属性与方法 Inner.methodIn(); // 2. 使用内部类的非静态属性与方法 new Inner().testIn(); &#125; static &#123; //1. 使用内部类的静态属性与方法 Inner.methodIn(); // 2. 使用内部类的非静态属性与方法 new Inner().testIn(); &#125;&#125; 通过上面的代码，我们可以看出来，在外部类使用内部类的静态与非静态属性方法时，与正常调用一个类的调用方式一致，一般要写在外部类的代码块或方法中。使用类名调用静态属性方法，使用对象调用非静态属性与方法。 3.在外部类的外面使用静态内部类的成员1234567891011public class Main &#123; public static void main(String[] args) &#123; // 3.在外部类的外面调用内部类的静态属性方法 Outer.Inner.methodIn(); // 创建内部类对象 Outer.Inner obj = new Outer.Inner(); obj.testIn(); &#125;&#125; 在主函数中（外部类的外面）调用内部类的静态方法与非静态方法，就是按照上述的方式。关于内部类的类型声明时的数据类型名，是按照他生成的字节码来生成的，文件中生成的字节码为Outer$Inner.class。内部类的类型为Outer.Inner。 非静态成员内部类声明1234外部类&#123; [修饰符] class 非静态内部类名 [extends 父类] [implements 接口名]&#123; &#125;&#125; 权限修饰符private，缺省，protected，public，abstract，final。 非静态那么static就不可以使用了。 成员在非静态内部类中不允许声明静态的成员（是因为加载的顺序的问题），除了静态的常量（常量的值在编译时已经确定了）。 使用1.在非静态内部类中使用外部类的成员123456789101112131415class Outer&#123; private String outField = "外部类的非静态属性"; private static String outStaticField = "外部类的静态属性"; class Inner&#123; public static final int MAX_VALUE = 10000;//常量可以// private static String inField;//非静态类中不能声明一个静态的属性或方法 public void testIn()&#123; // 1.非静态成员类中可以使用外部类的静态或非静态的属性与方法 System.out.println("outField =" + outField); System.out.println("outStaticField =" + outStaticField); &#125; &#125;&#125; 非静态成员内部类可以使用外部类的静态或非静态的属性与方法。 2.在外部类中使用非静态内部类的成员123456789101112131415161718192021class Outer&#123; private String outField = "外部类的非静态属性"; private static String outStaticField = "外部类的静态属性"; class Inner&#123; public static final int MAX_VALUE = 10000;//常量可以// private static String inField;//非静态类中不能声明一个静态的属性或方法 public void testIn()&#123; // 1.非静态成员类中可以使用外部类的静态或非静态的属性与方法 System.out.println("outField =" + outField); System.out.println("outStaticField =" + outStaticField); &#125; &#125; // 此处不可以是一个静态的方法 public void testOut()&#123; Inner in = new Inner(); in.testIn(); &#125;&#125; 因为非静态成员内部类没有静态属性与方法，所以调用他的非静态的属性与方法时，都需要生成一个内部类的对象，在调用属性与方法，并且不可以在外部类的静态代码块或方法里调用一个非静态的属性。3.在外部类的外面使用非静态内部类的成员分为两种方法：首先传统方法，在后面可能不适用。1234567891011121314151617181920212223242526272829303132333435363738394041public class Main &#123; public static void main(String[] args) &#123; //3.在外部类的外面调用内部非静态成员内部类 // 先创建的是外部类的对象 Outer out = new Outer(); // 方法一：创建一个内部非静态成员类的对象 Outer.Inner in = out.new Inner();//这种写法略微有点怪异了，一般也不使用这种方式。但是这么做是可以的 //最后就是使用了 in.testIn(); // 方法二：getInner方法 Outer.Inner in1 = out.getInner(); in1.testIn(); &#125;&#125;class Outer&#123; private String outField = "外部类的非静态属性"; private static String outStaticField = "外部类的静态属性"; class Inner&#123; public static final int MAX_VALUE = 10000;//常量可以// private static String inField;//非静态类中不能声明一个静态的属性或方法 public void testIn()&#123; // 1.非静态成员类中可以使用外部类的静态或非静态的属性与方法 System.out.println("outField =" + outField); System.out.println("outStaticField =" + outStaticField); &#125; &#125; public void testOut()&#123; //2.在外部类中调用非静态成员内部类的属性与方法 Inner in = new Inner(); in.testIn(); &#125; public Inner getInner()&#123; return new Inner(); &#125;&#125; 以上就是两种方法，如何在外部类的外部调用一个内部成员非静态类的属性与方法。后面一种get获取内部类的方式更为通用。注意：非静态内部类的字节码文件名：外部类$内部类.class，非静态内部类的全名称：外部类.非静态内部类。 有名字的局部内部类声明123456外部类&#123; 方法&#123; 【修饰符】 class 局部内部类 [extends 父类] [implements 接口名]&#123; &#125; &#125;&#125; 声明在方法中，代码块中都可以，一般都在方法中。 修饰符abstract,final。 注意：局部内部类与局部变量进行类比，他是没有权限修饰符的，同时也不会出现静态的属性，并且他也是没有static修饰的，static修饰类的成员。 使用1.在局部内部类中使用外部类的成员12345678910111213141516171819202122232425262728293031323334class Outer&#123; private String outField; private static String outStaticField; public void test()&#123; int a = 10;//局部变量 //局部内部类 class Inner&#123; private static final String NAME = "常量";//常量// private static String info;//局部内部类没有静态的属性方法 public void testIn()&#123; // 1. 有名字的局部内部类调用外部类的属性与方法 System.out.println("outField = " + outField); System.out.println("outStaticField = " + outStaticField); System.out.println("a = " + a);//优先方法中局部变量的值，其次成员变量的值 &#125; &#125; &#125; // 此时不可以使用外部类的静态成员 public static Object method()&#123; //局部内部类 class Inner&#123; private static final String NAME = "常量";//常量 public void testIn()&#123;// System.out.println("outField = " + outField);//方法是静态的，局部内部类则不能调用非静态的属性 System.out.println("outStaticField = " + outStaticField); &#125; &#125; &#125;&#125; 限制：能不能使用外部类的非静态成员，看局部内部类所在的方法是否是静态的。局部内部类取类外的值优先取方法中的值，没有再取成员变量的值. 2.在外部类中使用局部内部类12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Outer&#123; private String outField; private static String outStaticField; public void test()&#123; int a = 10;//局部变量// Inner in = new Inner();//1.会报错，需要先声明后使用// in.testIn(); //局部内部类 class Inner&#123; private static final String NAME = "常量";//常量// private static String info;//局部内部类没有静态的属性方法 public void testIn()&#123; // 1. 有名字的局部内部类调用外部类的属性与方法 System.out.println("outField = " + outField); System.out.println("outStaticField = " + outStaticField); System.out.println("a = " + a);//使用外部类的局部变量 &#125; &#125; Inner in = new Inner();//先声明后使用，有作用域 in.testIn(); &#125; public void testInner()&#123;// Inner in = new Inner();//2. 作用域隔离，注意作用=域 &#125; public static Object method()&#123; //局部内部类 class Inner&#123; private static final String NAME = "常量";//常量 public void testIn()&#123;// System.out.println("outField = " + outField);//方法是静态的，局部内部类则不能调用非静态的属性 System.out.println("outStaticField = " + outStaticField);// System.out.println("a = " + a);//使用外部类的局部变量 &#125; &#125; return new Inner(); &#125;&#125; 注意：使用的方式类似于局部变量的使用，需要先定义再使用。注意内部类名称的作用域，错误的作用域是无法调用的。 3.在外部类的外面使用局部内部类1234567891011public class Main &#123; public static void main(String[] args) &#123; //A：使用Inner类型不可以// Outer.Inner//错误的，没有这个字节码文件的生成 //B：获取到Inner的对象，使用多态引用 Object obj = Outer.method(); System.out.println(obj); &#125;&#125; 注意：在外部类的外面不可以使用局部内部类的类型；在外部类的外面可以获取到局部内部类的对象； 4.在局部内部类中可以使用所在方法/代码块的局部常量（final声明的） JDK1.8之前：必须手动加final JDK1.8之后：编译器会默认自动给加上final，如果不可以加final，那么报错。123456789101112131415161718class Outer&#123; private String outField; private static String outStaticField; public void test()&#123; int a = 10;//局部变量，实际上jdk8.0之后默认加了final，这是一个常量 // a = 20; //不能修改这个值，修改了局部内部类就会报错了。 //局部内部类 class Inner&#123; private static final String NAME = "常量";//常量 public void testIn()&#123; System.out.println("a = " + a);//使用所在方法/代码块的局部常量 &#125; &#125; &#125;&#125; 注意：局部内部类的字节码文件名：外部类名+$编号+局部内部类名.class，我们无法直接表示出一个有名字局部内部类的类型和对象，所以需要我们在方法中返回一个局部内部类的对象用于使用。 匿名内部类声明创建对象和声明类同时进行，一个匿名内部类只能有一个唯一的对象。123new 父类(【实参列表】)&#123;&#125;new 父接口()&#123;&#125; 特点 不存在修饰符； 创建对象与声明类同时进行，而且一个匿名内部类只有一个对象； 匿名内部类和局部内部类是一样的，可以用所在方法的局部常量（final）修饰1234567891011121314151617181920212223242526272829303132class TestAnonymousInner &#123; public static void main(String[] args) &#123; //这个f1指向的是Father的子类的对象 //多态引用 Father f1 = new Father()&#123; &#125;; System.out.println(f1.getClass());// class 包名.TestAnonymousInner$1 Father f2 = new Father()&#123; &#125;; System.out.println(f2.getClass());// class 包名.TestAnonymousInner$2 Father f3 = new Father()&#123; //重写父类的方法 @Override public void test()&#123; System.out.println("子类3重写父类的方法"); &#125; &#125;; f3.test();// 子类3重写父类的方法 &#125;&#125;class Father&#123; public void test()&#123; System.out.println("父类的测试方法"); &#125;&#125; 这里的f1和f2与f3指向的是三个不同的匿名对象，并且匿名对象里可以重写父类的方法，如果父类是一个抽象类或者接口，那么子类匿名类必须要实现父类的抽象方法。 如果父类中只有一个有参构造器，那么子类匿名内部类则需要调用父类的有参构造器创建类。12345678910111213141516171819class Father&#123; //只有一个有参构造 Father(String info)&#123; &#125; void test() &#123; System.out.println("父类方法"); &#125;&#125;class TestAnonymousInner &#123; public static void main(String[] args) &#123; Father m = new Father("实参")&#123; &#125;; &#125;&#125; 使用1.如果父类没有此方法，子类匿名内部类实现了这个方法：12345678910111213141516171819public class TestUse &#123; public static void main(String[] args) &#123; //多态引用，编译时按照父类编译 Object obj = new Object()&#123; public void test()&#123; System.out.println("匿名内部类的测试方法"); &#125; &#125;;// obj.test();//错误的,父类Object中没有test() //对象.方法() //匿名内部类的匿名对象 new Object()&#123; public void test()&#123; System.out.println("匿名内部类的测试方法"); &#125; &#125;.test(); &#125;&#125; 2.如果父类也有此方法，子类匿名内部类重写了这个方法：1234567891011121314151617public class TestUse2 &#123; public static void main(String[] args) &#123; Fu f = new Fu()&#123; public void test()&#123; System.out.println("子类"); &#125; &#125;; f.test();//子类 &#125;&#125;class Fu&#123; public void test()&#123; System.out.println("父类"); &#125;&#125; 3.匿名类作形参1234567891011121314151617181920212223public class TestUse3 &#123; public static void main(String[] args) &#123;// method();//实参应该是MyInter类型的一个对象，因为接口不能直接创建对象，应该传它的实现类的对象 method(new MyInter()&#123; @Override public void test() &#123; System.out.println("MyInter实现类重写了test方法"); &#125; &#125;); &#125; public static void method(MyInter my)&#123; my.test(); &#125;&#125;interface MyInter&#123; void test();&#125; 知识巩固12345class Outer&#123; abstract class Inner&#123; public abstract void test(); &#125;&#125; 问题：这是一个外部类，里面声明了一个内部类，那么如果我想要继承内部类Inner那么，我们要怎么操作呢？ 继承的语法格式：class 子类名 extends 父类名{} 非静态内部类的全名称： 外部类名.内部类名 继承抽象类：必须重写抽象类的抽象方法 要调用非静态内部类的构造器，需要外部类的对象 子类继承父类时，一定在子类的构造器的首行，一定要调用父类的构造器1234567891011121314class MyInner extends Outer.Inner&#123;/* MyInner()&#123; new Outer().super(); &#125;*/ MyInner(Outer out)&#123; out.super(); &#125; //重写抽象类的抽象方法 public void test()&#123; &#125;&#125; 注意：最后两点容易被忽视，继承内部类的时候要调用非静态内部类的构造器，需要外部类的对象。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interface实现多继承]]></title>
    <url>%2F2018%2F05%2F25%2FInterface%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[接口的概念在Java的面向对象里，类的继承关系是单继承的，与python的多继承不同，单继承的概念比较狭隘，在实际的环境里单继承的设计也不适用，Son不仅会继承father的属性，同时son也会继承mother的属性，而这种情况下，单继承就做不到让两个父类的属性都被子类继承了。不仅如此，在类抽象父类的过程中，鸭子可以水中游，船也可以水中游，但是鸭子和船却不能很好的抽象出一个合理的父类来。 接口使得很多没有父子类关系的类型对象，可以通过某个接口（标准）的类型，实现统一管理。简单的来说，我认为Java设计出接口的概念是实现多继承的一种方式，同时也是实现鸭子类型的一种方式。 接口的定义与继承接口和类是同一个级别的概念。可以理解为特殊的类，特殊的抽象类。调用的语法与声明class基本一致，只是将class关键字换成了interface。 定义：12[修饰符] interface 接口名&#123;&#125; 继承：12345678[修饰符] class 实现类 implements 父接口名&#123;&#125;[修饰符] class 实现类 implements 父接口名1，父接口名2，...&#123;&#125;[修饰符] class 实现类 extends 父类 implements 父接口名1，父接口名2，...&#123;&#125; 接口的特点 接口不能直接实例化，即不能直接创建对象(与抽象类类似)，他也不存在构造器; 接口中的成员： JDK1.8之前：接口中的成员只有三类： （1）公共的静态的常量：public static final，这几个修饰符可以省略 （2）公共的抽象的方法：public abstract，这两个修饰符可以省略 （3）公共的内部接口 设计接口的目的就是用来被实现的。 一个类实现了接口，就要求这个类必须重写（实现）接口的抽象方法，否则这个类也得是个抽象类。 一个类可以同时实现很多个接口(类似于多继承)。 一个类可以同时继承父类，又实现接口们。如果继承和实现同时存在，继承优先级更高。 接口与实现类的对象之间构成多态引用。 接口可以继承接口，而且可以继承多个接口。 coding理解interface的作用我现在想写一个可以为数组排序的一个工具类，但是不同类型的数组要怎么排序是一个问题，假设我有一个学生对象的数组，那么对于这个学生对象的数组排序，我是按照年龄排序还是按照学号排序，再或者我下一次放入一个全是整形的数组进行排序，那么我们如何让我的这个工具类都可以正常的运行呢？ 定义一个接口：12345678910111213/** 我们定义的这个接口定义了一个规范，实现我们的这个接口的类都必须实现自己的一套排序方式* 并且大小顺序按照此规则来定* */public interface SortAble &#123; /* * 规定：当前对象this 和 指定对象obj比较大小时， * 当 this “大于” obj时，返回正整数 * 当 this “小于” obj时，返回负整数 * 当 this “等于” obj时，返回零 */ public abstract int compare(Object obj);&#125; 定义一个学生类，按照接口定义的要求实现比较的细节：1234567891011121314151617181920212223242526272829303132333435363738class Student implements Sortable&#123; private int id; private String name; public Student(int id, String name) &#123; super(); this.id = id; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "Student [id=" + id + ", name=" + name + "]"; &#125; //实现接口，标准的抽象方法 @Override public int compare(Object obj) &#123;// this的学生对象和obj的学生对象进行比较大小，按照学号比较 Student other = (Student) obj; if(this.id &gt; other.id)&#123; return 1; &#125;else if(this.id &lt; other.id)&#123; return -1; &#125; return 0; &#125;&#125; 实现排序的细节：123456789101112131415161718192021public class MyArrays &#123; //功能：为任意类型的数组进行从小到大排序 //参数：Object[] public static void sort(Object[] arr)&#123; //冒泡排序：从小到大 for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length-i; j++) &#123; //如果arr[j]和arr[j+1]两个对象符合Sortable标准 //那么，我们就可以把arr[j]转成Sortable类型 Student s = (Student) arr[j];//这两种转换都可以 //Sortable s = (Sortable) arr[j]; //if(arr[j] &gt; arr[j+1])&#123;//if(前面的元素 &gt; 后面的元素)&#123; if(s.compare(arr[j+1]) &gt; 0)&#123; Object temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125;&#125; 最后我们可以进行测试：123456789101112131415class TestMyArrays &#123; public static void main(String[] args) &#123; Student[] students = new Student[3]; students[0] = new Student(4,"张三"); students[1] = new Student(1,"李四"); students[2] = new Student(5,"丁杰"); MyArrays.sort(students); for (Student student : students) &#123; System.out.println(student); &#125; &#125;&#125; 运行结果：123Student [id=1, name=李四]Student [id=4, name=张三]Student [id=5, name=丁杰] 通过上面的例子我们可以的出结论，只要是我们实现了Sortable接口的类，它实例出的对象就可以进行排序输出了。 JDK8后的接口特性接口成员除了公共的静态的常量：public static final，公共的抽象的方法：public abstract，公共内部接口以外又增加了：1234567891011121314interface MyInter&#123; //静态方法,通过接口名进行调用。 public static void method()&#123; System.out.println(&quot;接口中允许有静态方法&quot;); &#125; //默认方法,通过实现类的对象调用。子类可以不实现就直接调用，子类也可以进行重写 public default void test()&#123; System.out.println(&quot;接口的默认方法&quot;); &#125; //抽象方法 public abstract void fangFa();&#125; 默认方法：当接口的多个实现类关于某个抽象方法的实现是一样的，那么可以在接口中给出默认实现。1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestInterface &#123; public static void main(String[] args) &#123; MyInter.method(); MyImpl my = new MyImpl(); my.fangFa(); my.test(); OtherImpl other = new OtherImpl(); other.test(); &#125;&#125;interface MyInter&#123; //静态方法 public static void method()&#123; System.out.println("接口中允许有静态方法"); &#125; //默认方法, public default void test()&#123; System.out.println("接口的默认方法"); &#125; //抽象方法 public abstract void fangFa();&#125;class MyImpl implements MyInter&#123; @Override public void fangFa() &#123; System.out.println("实现类重写接口的抽象方法"); &#125;&#125;class OtherImpl implements MyInter&#123; //重写接口中的默认方法 public void test()&#123; System.out.println("重写接口的默认方法......"); &#125; @Override public void fangFa() &#123; System.out.println("实现类重写接口的抽象方法"); &#125;&#125; 运行结果：1234接口中允许有静态方法实现类重写接口的抽象方法接口的默认方法重写接口的默认方法...... 也就是说，如果你不重写父接口的默认方法，那么你就相当于继承了这个接口的此方法了。同时增加了静态方法，静态方法是不可以继承的这看起来有点奇怪，但是可能在某个时候会被我们使用到吧。 继承类与接口时遇到的冲突一个类同时实现的多个接口都有一个一样的默认方法1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestProblem1 &#123; public static void main(String[] args) &#123; MySub m = new MySub(); m.method(); &#125;&#125;interface A&#123; public default void method()&#123; System.out.println("A接口的默认方法"); &#125;&#125;interface B&#123; public default void method()&#123; System.out.println("B接口的默认方法"); &#125;&#125;// 实现了A和B，A和B都有自己的默认方法class MySub implements A,B&#123; /* @Override public void method() &#123; A.super.method();//保留A的方法实现 &#125;*/ /* @Override public void method() &#123; B.super.method();//保留B的方法实现 &#125;*/ /* @Override public void method() &#123; A.super.method();//保留A的方法实现 B.super.method();//也保留B的方法实现 &#125;*/ //选择C @Override public void method() &#123; System.out.println("我选择其他"); &#125;&#125; 继承的父类与实现接口中的默认方法一样123456789101112131415161718192021222324252627282930313233public class TestProblem2 &#123; public static void main(String[] args) &#123; Sub sub = new Sub(); sub.method(); &#125;&#125;interface myInter&#123; public default void method()&#123; System.out.println("接口中的默认方法"); &#125;&#125;class Father&#123; public void method()&#123; System.out.println("父类和接口的默认方法一样的方法"); &#125;&#125;class Sub extends Father implements myInter&#123; //(1)默认保留的是父类 //(2)明确保留父类的/* public void method()&#123; super.method(); &#125;*/ //(3)明确保留接口的/* public void method()&#123; myInter.super.method(); &#125;*/ //(4)两者都不要，其他 public void method()&#123; System.out.println("其他"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序初始化的顺序（二）]]></title>
    <url>%2F2018%2F05%2F23%2FJava%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[之前的一篇博客里我写了关于在一个类中的程序初始化顺序，但是在Java的面向对象里，类之间还存在着继承的关系。所以关于程序的初始化顺序，我们可以再细划分为：父类静态变量，父类的静态代码块，父类构造器，父类非静态变量，父类非静态代码块，子类静态变量，子类静态代码块，子类构造器，子类非静态成员变量和子类非静态代码块。本篇博客我们讨论的就是关于程序初始化的过程中，上述的成员在初始化加载先后顺序。在此前我们讨论得出的结论：在一个类中，Java程序加载的顺序是：静态变量–&gt;静态代码块–&gt;非静态变量–&gt;非静态代码块–&gt;构造器. 父类的代码：1234567891011121314151617181920212223242526public class SuperClass &#123; //父类与子类都在一个包中，这里我们就使用default修饰符 //这是一个父类的静态变量,此时还是初始化的默认值null static String superStaticVariale; // 静态代码块，给String赋值 static &#123; superStaticVariale = "父类静态代码块赋值成功"; System.out.println("此时运行的是父类的静态代码块："+superStaticVariale); &#125; // 无参构造，覆盖静态代码块的值 SuperClass()&#123; superStaticVariale = "父类构造器赋值成功"; System.out.println("此时运行的是父类的构造器："+superStaticVariale); &#125; //定义一个非静态变量 String superVariale; // 定义一个非静态代码块 &#123; superVariale = "父类非静态代码块赋值"; System.out.println("此时运行的是父类的非静态代码块："+superVariale); &#125;&#125; 子类的代码：123456789101112131415161718192021222324public class SubClass extends SuperClass&#123; static String subStaticVariale; // 静态代码块，给String赋值 static &#123; subStaticVariale = "子类静态代码块赋值成功"; System.out.println("此时运行的是子类的静态代码块："+subStaticVariale); &#125; // 无参构造，覆盖静态代码块的值 SubClass()&#123; superStaticVariale = "子类构造器赋值成功"; System.out.println("此时运行的是子类的构造器："+superStaticVariale); &#125; //定义一个非静态变量 String subVariale; // 定义一个非静态代码块 &#123; subVariale = "子类非静态代码块赋值"; System.out.println("此时运行的是子类非静态代码块："+subVariale); &#125;&#125; 测试代码：123456public class Main &#123; public static void main(String[] args) &#123; SubClass s = new SubClass(); &#125;&#125; 运行结果：123456此时运行的是父类的静态代码块：父类静态代码块赋值成功此时运行的是子类的静态代码块：子类静态代码块赋值成功此时运行的是父类的非静态代码块：父类非静态代码块赋值此时运行的是父类的构造器：父类构造器赋值成功此时运行的是子类非静态代码块：子类非静态代码块赋值此时运行的是子类的构造器：子类构造器赋值成功 很显然，在继承关系中，代码的加载顺序是：父类的静态变量–&gt;父类的静态代码块–&gt;子类静态变量–&gt;子类的静态代码块–&gt;父类非静态变量–&gt;父类的非静态代码块–&gt;父类的构造器–&gt;子类非静态变量–&gt;子类非静态代码块–&gt;子类构造器 进一步测试：12345678public class Main &#123; public static void main(String[] args) &#123; SubClass s = new SubClass(); SubClass s1 = new SubClass(); SubClass s2 = new SubClass(); &#125;&#125; 运行结果：1234567891011121314此时运行的是父类的静态代码块：父类静态代码块赋值成功此时运行的是子类的静态代码块：子类静态代码块赋值成功此时运行的是父类的非静态代码块：父类非静态代码块赋值此时运行的是父类的构造器：父类构造器赋值成功此时运行的是子类非静态代码块：子类非静态代码块赋值此时运行的是子类的构造器：子类构造器赋值成功此时运行的是父类的非静态代码块：父类非静态代码块赋值此时运行的是父类的构造器：父类构造器赋值成功此时运行的是子类非静态代码块：子类非静态代码块赋值此时运行的是子类的构造器：子类构造器赋值成功此时运行的是父类的非静态代码块：父类非静态代码块赋值此时运行的是父类的构造器：父类构造器赋值成功此时运行的是子类非静态代码块：子类非静态代码块赋值此时运行的是子类的构造器：子类构造器赋值成功 得出结论：父类与子类的静态代码都只执行一次，然后非静态代码块与构造器是组合出现的。 简化一下代码：12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; C c= new C(); &#125;&#125;class A&#123; A()&#123; System.out.println("A的无参构造器"); &#125;&#125;class B extends A&#123;// B(int a)&#123; B()&#123; System.out.println("B的无参构造器"); &#125;&#125;class C extends B&#123; C()&#123; System.out.println("C的无参构造器"); &#125;&#125; 运行结果：123A的无参构造器B的无参构造器C的无参构造器 调用C的构造器生成C的实例对象会从最上级的父类的无参构造器开始逐层调用，那么我们的类都继承了一个超级父类Object，也就是在我们最初的错误代码中，我们调用Student的无参构造创建一个对象时，首先会调用这个对象的父类Object的无参构造器，12345678910111213141516171819class Student&#123; String name; &#123; name = "老大"; &#125; Student()&#123; this(name);//这样会报错 super(); System.out.println("题目要求写一个无参的构造器"); &#125; Student(String name)&#123; this.name = name; System.out.println(name); &#125; &#125; 子类实例化默认调用父类的无参构造器，也就是如上this调用在super()之前（实际中这两者不会同时出现），name此时是非静态属性，此时会报错错误: 无法在调用超类型构造器之前引用name。123456789101112131415161718class Student&#123; static String name; &#123; name = "老大"; &#125; Student()&#123; this(name); System.out.println("题目要求写一个无参的构造器"); &#125; Student(String name)&#123; this.name = name; System.out.println(name); &#125; &#125; 当name是静态属性时，代码块是非静态时，编译通过，调用子类的无参构造器时this(name)，输出结果是：12null题目要求写一个无参的构造器 此时的this()调用实参构造并没有赋值成功。1234567891011121314151617class Student&#123; static String name; static&#123; name = "老大"; &#125; Student()&#123; this(name); System.out.println("题目要求写一个无参的构造器"); &#125; Student(String name)&#123; this.name = name; System.out.println(name); &#125;&#125; 此时运行结果：12老大题目要求写一个无参的构造器 这样赋值成功。由此证明我们的结论是正确的，this()是在子类父类构造器之前进行的操作super(),当子类代码块是非静态时，子类非静态代码块会在执行父类构造器之后执行，所以this(name)时name还没有被赋值，所以打印是null。 结论： 一个类中可以在无参构造器中调用此类的有参构造器（顺序反过来）； 在执行子类的无参构造器时会默认调用最高级父类无参构造，并逐级调用直至子类的无参构造； Java程序的加载顺为父类的静态变量–&gt;父类的静态代码块–&gt;子类静态变量–&gt;子类的静态代码块–&gt;父类非静态变量–&gt;父类的非静态代码块–&gt;父类的构造器–&gt;子类非静态变量–&gt;子类非静态代码块–&gt;子类构造器，且静态变量或代码块无论构造器调用多少次，他只会执行一次，后面再调用构造器则会执行非静态属性及代码块构造器。 最后关于为什么子类会调用父类的构造器，这个从设计着的角度来看是为了给从父类继承的属性初始化，子类需要知道父类是如何给属性初始化的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言Array与Slice]]></title>
    <url>%2F2018%2F05%2F21%2FGo%E8%AF%AD%E8%A8%80Array%E4%B8%8ESlice%2F</url>
    <content type="text"><![CDATA[数组基础为什么要讨论Go语言的数组在其他语言里，比如Java和python里数组(列表)，都是引用传递，但是到了Go语言里，数组的传递方式依然是值传递。那么值传递的数组是怎么使用的呢？这篇文章里简单的整理一下Go语言的数组的使用与其配合的Slice的工作原理。 数组定义的三种方式1234567891011// 1.定义一个数组，并赋值var arr1 [5]int//[0 0 0 0 0]//var arr1 = [5]int&#123;1,2,3,4,5&#125;//[1 2 3 4 5]// 2.:=要给数组赋初值arr2 := [3]int&#123;1,2,3&#125;//[1 2 3]fmt.Println(arr1, arr2)// 3.奇葩的赋值方式，但是好用，不确定数组的长度arr3 := [...]int&#123;2,4,6,7,10&#125;//[2 4 6 7 10]fmt.Println(arr3) 遍历数组1234567891011121314151617181920//1.数组的遍历,长度为len()for i:=0;i&lt;len(arr2);i++&#123; fmt.Println(arr2[i])//1 2 3&#125;//2.range获取数组的下标，遍历数组for i:=range arr2&#123; fmt.Println(arr2[i])//1 2 3&#125;//3.range还可以获得数组的值for i, v:=range arr2&#123; fmt.Println(i, v)//1 2 3&#125;//4.只要v的情况,_在Go语言中是一种通用方法sum := 0for _, v := range arr2&#123; sum += v&#125; 函数内传入数组1234567891011121314//go语言的数组是值类型的，也就是说，在函数内是不会改变函数外调用的数组的值的func array2( arr [3]int)&#123; arr[0] = 100 for _,v :=range arr&#123; fmt.Println(v)//100,3,4,此处相当于将复制得来的数组改变了，但是外层的数组并没有改变 &#125;&#125;//var arr1 [5]intarr2 := [3]int&#123;2,3,4&#125;array1()//array2(arr1)//这里是会报错的，array2函数需要传入一个长度为3的数组，go语言里认为长度为3和长度为5的数组不是一个类型的，所以会飘红array2(arr2)fmt.Println(arr2)//[2 3 4] 注意： func内传入的形参是一个固定长度的数组，并且传递实参的时候只能传递一个相同长度的数组作为实参传递，否则程序会报错； 在函数中修改了数组的值，但是实际作为实参的数组的值却没有发生变化，这说明了数组只是传递了值，而不是将整个对象引用过去。形参copy了一个新的数组加以修改，而不是在原有的数组上进行修改。数组的“引用传递”Java与python中的数组本质上是一个对象，在引用传递的过程中，实际赋值操作时是将对象指向堆空间的内存地址进行传递，那么被赋值对象实际上与原对象指向的是同一块堆内存。修改其中的一个，另外一个也会相应的发生变化，这就是引用传递。Go实现类似应用传递的本质与上述的方法理论基本一致。Go指针在此处的作用大抵就是完成了上述的操作。12345678910func array3( arr *[3]int)&#123; arr[0] = 100 for _,v :=range arr&#123; fmt.Println(v)//100,3,4,此处相当于将复制得来的数组改变了，但是外层的数组并没有改变 &#125;&#125;//array3接收的是一个数组的指针，所以我们传一个arr的地址值进去array3(&amp;arr2)fmt.Println(arr2)//[100 3 4]，此时是相当于引用传递的，所以会改变数组的值 注意：从某种程度上来讲，Go语言是一门值传递语言，引入指针的概念后，更确切的说就是，Go语言的参数传递是值传递与指针传递的结合使用。 Slice我们一般翻译过来叫做切片。和其他语言的数组切片非常的相似，包括中括号取索引，半开半闭等，但是实际上Go语言的数组slice与他们相比又有很多独特的地方。 Slice切片的基本形式12345678910arr := [...]int&#123;2,4,6,8,10&#125;//两端都有s := arr[1:4]fmt.Println(s)//[4 6 8]//有前无后fmt.Println(arr[2:])//[6 8 10]//有后无前fmt.Println(arr[:4])//[2 4 6 8]//全切fmt.Println(arr[:])//[2 4 6 8 10] Go语言数组的正确打开方式其实通过上面的demo可以看出，不论是值引用方式还是指针引用方式，用起来都极为不便，func函数里的数组长度必须要求实参与之长度相同。这样用起来是十分麻烦的，这与Go语言所追求的极简的概念也有着冲突。其实我们平时使用的数组都是Slice方式的，这种方式使用数组是极为简便的。 12345678// 中括号不加数字就是一个切片func slice1(arr []int)&#123; //改动切片的数值 arr[0] = 100&#125;slice1(arr[:])fmt.Println(arr)//[100 4 6 8 10] Go语言在使用数组类似引用传递的操作时一般是不使用指针的，而是上述操作的切片的方式。go文档里说，slice是对数组的一个视图（view），只看我要看的这一小段。 reSlice123456//reslice操作,每次的下标都是针对自己的slicearr := [...]int&#123;2,4,6,8,10&#125;a := arr[:]a = a[:3]a = a[1:]fmt.Println(a)//[4,6] reSlice理解起来并不难，但是要是想进一步理解Go语言的切片需要理解Extending Slice.的概念。 Extending Slice下面的一段代码：1234567arr1 := [...]int&#123;0,1,2,3,4,5,6,7&#125;s1 := arr1[2:6]//很明显此时s1的长度是4，即下标是0-3，那么此时的s2会不会报错，答案是不会报错s2 := s1[3:5]fmt.Println(s2)//[5 6]s3 := s1[3:]fmt.Println(s3)//[5],默认是看不到cap()的值的，直接取s1[4]会报错 compare:12345arr = [0, 1, 2, 3, 4, 5, 6, 7]s1 = arr[2:6] # [2, 3, 4, 5]s2 = s1[3:5] # [5]print(s1, s2) Go在s2切片的时候下标已经超出s1的索引范围了，但是结果不仅没有报错，而且还正确的切到了下一个正确值6. golang中的slice除了len()还有一个cap()长度。虽然此时的len(s1)是4，但是cap(s1)还是6，slice是一个视图，视图再切片时还是能知道下面的数据（索引为4和5）的，所以只要不超过cap()长度，即使s1取不到4，5（超过len()长度），但是s2依然可以取到。 slice的实现待续。。。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序初始化的顺序（一）]]></title>
    <url>%2F2018%2F05%2F20%2FJava%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[今天在写构造器方法的时候，遇到了一个小问题，由这个问题引发了一连串的思考，在一个Java类中变量与类的初始化执行顺序是什么样的呢？ 发现问题1234567891011121314151617181920212223242526272829class Student&#123; private String name; void setName(String name)&#123; this.name = name; &#125; String getName()&#123; return name; &#125; Student()&#123; //this(this.name); this(name); System.out.println("题目要求写一个无参的构造器"); &#125; Student(String name)&#123; this.name = name; &#125; &#125;class TestStudent&#123; public static void main(String[] args)&#123; Student stu1 = new Student(); System.out.print(stu1.getName()); Student stu2 = new Student("老大"); System.out.println(stu2.getName()); &#125;&#125; 此时会报错：无法在调用超类型构造器之前引用name. 在使用构造器创建对象时，此时的成员变量name的值是否已经完成初始化，无参构造中调用它时报的这个错意味着什么。我们本篇博客就来讨论一下，一个类创建对象时到底做了哪些事？ 思考问题首先，对于一个类来说加载分为五个部分，分别是静态变量，静态代码块，非静态变量，非静态代码块以及构造器。 单个类成员加载顺序测试代码：123456789101112131415161718192021222324252627282930313233class Student&#123; // 静态变量 static String name; // 静态代码块 static&#123; System.out.println("刚运行到静态代码块时的静态变量值："+name); name = "静态name值"; System.out.println("静态代码块结束时的静态变量值："+name); &#125; //定义一个无参构造器 Student()&#123; System.out.println("刚运行到构造器时的静态变量值："+name); name = "这是一个无参的构造器"; System.out.println("构造器结束时的静态变量值："+name); &#125; //定义一个非静态变量 String name2; //定义一个非静态代码块 &#123; System.out.println("刚运行到非静态代码块时的非静态变量值："+name2); name2 = "非静态name值"; System.out.println("非静态代码块结束时的非静态变量值："+name2); &#125;&#125;class TestStudent&#123; public static void main(String[] args)&#123; Student stu = new Student(); &#125;&#125; 此时编译代码执行的结果是：123456刚运行到静态代码块时的静态变量值：null静态代码块结束时的静态变量值：静态name值刚运行到非静态代码块时的非静态变量值：null非静态代码块结束时的非静态变量值：非静态name值刚运行到构造器时的静态变量值：静态name值构造器结束时的静态变量值：这是一个无参的构造器 由此可以看出，当我们声明的类成员变量是一个静态成员变量的时候，在调用构造器之前，我们的静态成员变量已经生成并初始化成相应的数据类型的默认值(即此处String对象的默认值位null)。然后在静态代码块中，我们将静态变量赋值，然后程序跳转到非静态变量声明与赋值。再执行非静态代码块，最后直行到程序的无参构造器。 所以，通过此程序代码，我们得出结论：单个类的程序加载顺序是：静态变量–&gt;静态代码块–&gt;非静态变量–&gt;非静态代码块–&gt;构造器。 也就是说调用构造器时，静态与非静态的属性都已经完成初始化工作了，this(name)调用报错与name属性本身没有关系。 深入思考类加载顺序既然说到加载顺序，那么我们继续完成类成员的加载顺序。关于变量与代码块之间的关系，或者说根据我们上面的这段代码得出这个初步的结论我们还有待商榷，因为，我们的程序加载的顺序是自上而下的，也就是说，我们的得到的这个结论有可能是因为我们习惯性的排版导致的，我们声明各部分的顺序偶可能影响我们得出的结论。为了确定我们程序的严谨性，我们需要进一步的调整代码的顺序，来加强验证我们代码实验的逻辑严谨性。 12345678910111213141516171819202122232425262728293031323334public class Student2 &#123; // 静态代码块放到前面，此时name还未声明，所以会报错 static&#123; System.out.println("刚运行到静态代码块时的静态变量值："+name); name = "静态name值"; System.out.println("静态代码块结束时的静态变量值："+name); &#125; // 静态变量 static String name; //定义一个无参构造器 Student2()&#123; System.out.println("刚运行到构造器时的静态变量值："+name); name = "这是一个无参的构造器"; System.out.println("构造器结束时的静态变量值："+name); &#125; //定义一个非静态代码块 &#123; System.out.println("刚运行到非静态代码块时的非静态变量值："+name2); name2 = "非静态name值"; System.out.println("非静态代码块结束时的非静态变量值："+name2); &#125; //定义一个非静态变量 String name2;&#125;class TestStudent&#123; public static void main(String[] args)&#123; Student stu = new Student(); Student2 stu2 = new Student2(); &#125;&#125; 上面代码运行的结果：1Error:(6, 48) java: 非法前向引用 此时将代码块拿到变量声明的前面我们的代码出现了错误提示，这说明了我们一开始得到的结论并不严谨，我们这里可以得出代码块的执行是在变量声明之前的。所以，我们可以根据常识大胆的猜想，单个类程序加载的顺序是静态–&gt;非静态–&gt;构造器，其中变量声明与代码块的执行顺序与代码前后位置有关，并没有严格的前后之分，程序员将代码写在前边的的先执行。 验证猜想12345678910111213141516171819202122232425262728293031public class Student3 &#123; //定义一个无参构造器 Student3()&#123; System.out.println("刚运行到构造器时的静态变量值："+name); name = "这是一个无参的构造器"; System.out.println("构造器结束时的静态变量值："+name); &#125; //定义一个非静态代码块 &#123; name2 = "非静态name值"; System.out.println("非静态代码块结束时的静态变量值："+name); &#125; //定义一个非静态变量 String name2; // 静态代码块 static&#123; System.out.println("运行到静态代码块");// name = "静态代码块里赋的值"; &#125; // 静态变量 static String name;&#125;class TestStudent&#123; public static void main(String[] args)&#123; Student3 stu3 = new Student3(); &#125;&#125; 上面代码执行的结果：1234运行到静态代码块非静态代码块结束时的静态变量值：null刚运行到构造器时的静态变量值：null构造器结束时的静态变量值：这是一个无参的构造器 基本验证了我们的猜想是正确的，但是在结尾我又做了一个有趣的测试。 测试12345678910111213141516171819202122232425262728293031public class Student3 &#123; //定义一个无参构造器 Student3()&#123; System.out.println("刚运行到构造器时的静态变量值："+name); name = "这是一个无参的构造器"; System.out.println("构造器结束时的静态变量值："+name); &#125; //定义一个非静态代码块 &#123; name2 = "非静态name值"; System.out.println("非静态代码块结束时的静态变量值："+name); &#125; //定义一个非静态变量 String name2; // 静态代码块 static&#123; System.out.println("运行到静态代码块"); name = "静态代码块里赋的值";// 按道理说，我们这里没有声明就直接赋值操作了 &#125; // 静态变量 static String name;&#125;class TestStudent&#123; public static void main(String[] args)&#123; Student3 stu3 = new Student3(); &#125;&#125; 上面代码执行的结果：1234运行到静态代码块非静态代码块结束时的静态变量值：静态代码块里赋的值刚运行到构造器时的静态变量值：静态代码块里赋的值构造器结束时的静态变量值：这是一个无参的构造器 也就是说在静态代码块里，我们无法引用后面的静态变量，但是我们编译之前可以对他进行赋值，并且在后面的非静态代码块里我们还可以取到里面的值，再次做出假设，这是java虚拟机在编译时不让向前引用，此时的变量其实已经完成了声明初始化等一系列操作（都是存在方法区），只是通过不了编译而已。所以我认为，我们最早得到的结论应该才是正确的Java程序整个加载流程的顺序。 这中间也可能时JDK和IDE一起努力做了点什么，但是实际上也不影响，我们的代码块的存在本来就是为了完成变量的初始化工作的，所以将代码块放到属性声明之前是毫无意义的操作，所以这里只是遇到了测试一下而已，实际操作中毫无意义。 得出结论总结：在一个类中，初始化顺序为： 静态变量，静态变量初始化； 静态代码块； 非静态变量初始化； 非静态代码块； 构造器。 ##最后到这里，我们理清楚了单个类中的各部分的加载顺序，但是我们文章一开始提到的问题并没有解决，如果构造器执行是在静态和非静态属性及代码块之后的话，此时的成员变量应当已经有了初始化值了，再不济成员变量还有一个初始的null值，但是这里报了无法在调用超类型构造器之前引用name。这说明这里调用name关系到了这个类的父类构造器，所以我们后面继续探讨类加载在继承中的加载顺序，就可以解决这个问题了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
